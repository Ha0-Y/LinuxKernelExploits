## LKMs 编写

loadable kernel modules
```txt
LKM可以动态地加载到内存中，无须重新编译内核。由于LKM具有这样的特点，所以它经常被用于一些设备的驱动程序。
```

**踩坑：**
1. 在于虚拟机共享文件夹时编译发生错误，将`.c`文件移动到虚拟机才成功
2. Makefile使用 "/lib/modules/`uname -r`/build" 可以直接编译，但是兼容性会不会有问题？
3. Makefile使用 "/home/<user>/<kernel_dir>" 会报错，不清楚为何

### hello world

- MODULE_LICENSE：必须包含，否则会报错。[GPL以及相关变体](https://www.kernel.org/doc/html/latest/translations/zh_CN/process/license-rules.html)。
```txt
GPL: General Public License
```

- 入口和出口
```c
module_init()
module_exit()
```

- 操作模块，查看信息
```bash
sudo insmod hello_world.ko
sudo lsmod
dmesg   # 查看printk的信息
sudo rmmod hello_world.ko
```

### fops - 文件操作

- 首先，万物皆文件的哲学思想，这是一种抽象。我们可以编写 `file_operations`来进行相关操作
```c
struct file_operations {
        struct module *owner;
        loff_t (*llseek) (struct file *, loff_t, int);
        ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
        ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
        ssize_t (*read_iter) (struct kiocb *, struct iov_iter *);
        ssize_t (*write_iter) (struct kiocb *, struct iov_iter *);
        int (*iopoll)(struct kiocb *kiocb, struct io_comp_batch *,
                        unsigned int flags);
        int (*iterate) (struct file *, struct dir_context *);
        int (*iterate_shared) (struct file *, struct dir_context *);
        __poll_t (*poll) (struct file *, struct poll_table_struct *);
        long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
        long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
        int (*mmap) (struct file *, struct vm_area_struct *);
        unsigned long mmap_supported_flags;
        int (*open) (struct inode *, struct file *);
        int (*flush) (struct file *, fl_owner_t id);
        int (*release) (struct inode *, struct file *);
        int (*fsync) (struct file *, loff_t, loff_t, int datasync);
        int (*fasync) (int, struct file *, int);
        int (*lock) (struct file *, int, struct file_lock *);
        ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);
        unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
        int (*check_flags)(int);
        int (*flock) (struct file *, int, struct file_lock *);
        ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
        ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
        int (*setlease)(struct file *, long, struct file_lock **, void **);
        long (*fallocate)(struct file *file, int mode, loff_t offset,
                          loff_t len);
        void (*show_fdinfo)(struct seq_file *m, struct file *f);
#ifndef CONFIG_MMU
        unsigned (*mmap_capabilities)(struct file *);
#endif
        ssize_t (*copy_file_range)(struct file *, loff_t, struct file *,
                        loff_t, size_t, unsigned int);
        loff_t (*remap_file_range)(struct file *file_in, loff_t pos_in,
                                   struct file *file_out, loff_t pos_out,
                                   loff_t len, unsigned int remap_flags);
        int (*fadvise)(struct file *, loff_t, loff_t, int);
        int (*uring_cmd)(struct io_uring_cmd *ioucmd, unsigned int issue_flags);
        int (*uring_cmd_iopoll)(struct io_uring_cmd *, struct io_comp_batch *,
                                unsigned int poll_flags);
} __randomize_layout;
```

#### ioctl

- 内核提供的功能有限，我们可以使用 `ioctl` 进行功能扩展
- 给设备增加ioctl功能需要实现如下的函数
```c
unlocked_ioctl   // 64和32位最终的调用
compat_ioctl     // 32位必须使用，否则就会报错
```

### char device

> Linux系统将设备分为三大类：字符设备、块设备和网络设备。字符设备是其中较为基础的一类，它的读写操作需要一个字节一个字节的进行，不能随机读取设备中的某一数据，即要按照先后顺序。举例来说，比较常见的字符设备有鼠标、键盘、串口等。
> 字符设备驱动所做的工作主要是添加、初始化、删除cdev结构体，申请、释放设备号，填充file_operations结构体中的功能函数，比如open()、read()、write()、close()等。当我们创建一个字符设备时，一般会在/dev目录下生成一个设备文件，Linux用户层的程序就可以通过这个设备文件来操作这个字符设备。

1.在Linux文件系统中，每个文件都用一个struct inode结构体来描述，这个结构体里面记录了这个文件的所有信息，例如：文件类型，访问权限等。
2.在Linux操作系统中，每个驱动程序在应用层的/dev目录下都会有一个设备文件和它对应，并且该文件会有对应的主设备号和次设备号。
3.在Linux操作系统中，每个驱动程序都要分配一个主设备号，字符设备的设备号保存在struct cdev结构体中。

#### 设备号

- 32位：高12位主设备号，低20位次设备号

```c
#define MINORBITS         20
#define MINORMASK        ((1U << MINORBITS) - 1)
 
#define MAJOR(dev)       ((unsigned int) ((dev) >> MINORBITS))
#define MINOR(dev)       ((unsigned int) ((dev) & MINORMASK))
#define MKDEV(ma,mi)     (((ma) << MINORBITS) | (mi))
```

##### 申请设备号

- 三个函数: register_chrdev_region()、alloc_chrdev_region()和 register_chrdev()

```c
// 系统自动分配设备号，用于没有主设备号直接申请
int register_chrdev_region(dev_t from, unsigned count, const char *name); 

// 存在主设备号
int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char name);

// 上述两个设备的销毁
void unregister_chrdev_region(dev_t from, unsigned count)

// in kernel source 
// 直接获得一个主设备号下的所有次设备号，也是最简单的使用
static inline int register_chrdev(unsigned int major, const char *name,
                            const struct file_operations *fops)
{
        return __register_chrdev(major, 0, 256, name, fops);
}
static inline void unregister_chrdev(unsigned int major, const char *name)
{
        __unregister_chrdev(major, 0, 256, name);
}
```


#### 注册字符设备

- cdev

```c
struct cdev {
    struct kobject kobj;                // 内嵌的kobject对象
    struct module *owner;               // 所属模块
    const struct file_operations *ops;  //文件操作结构体
    struct list_head list;              // 链表句柄
    dev_t dev;                          // 设备号
    unsigned int count;
};

// 初始化
void cdev_init(struct cdev *p, const struct file_operations *p);　

// 注册
int cdev_add(struct cdev *p, dev_t dev, unsigned count)

// 动态申请 cdev 内存
strcut cdev *cdev_alloc(void);

// 销毁
void cdev_del(struct cdev *p)
```

#### 创建设备节点

1. 手动添加

```bash
mknod
```

2. class
```c
//定义一个类指针
static struct class *chr_dev_class;

//内核源码/drivers/base/core.c
struct device *device_create(struct class *class, struct device *parent,
                                dev_t devt, void *drvdata, const char *fmt, ...)

// 销毁
void device_destroy(struct class *class, dev_t devt)
```

#### 操作字符设备

```c
struct file_operations fops {
    .owner = THIS_MODULE,
    .open = fops_open(),
}
```

### misc device

- 杂项设备，最简单的字符设备，仍在 `/dev` 目录下

```c
struct miscdevice {                     //misc设备结构体
    int minor;                          //次设备号
    const char *name;                   //设备节点的名字
    const struct file_operations *fops; //文件操作集
    struct list_head list;
    struct device *parent;
    struct device *this_device;
    const struct attribute_group **groups;
    const char *nodename;
    umode_t mode;
};

int misc_register(struct miscdevice *misc);     //向系统中注册一个 misc 设备
int misc_deregister(struct miscdevice *misc)    //注销掉 misc 设备
```

### procfs

- proc 目录下

```c

// 创建文件夹
struct proc_dir_entry *proc_mkdir(const char *name, struct proc_dir_entry *parent);

// 创建文件
static inline 
struct proc_dir_entry *proc_create(const char *name, 
                mode_t mode,                            // 权限
                struct proc_dir_entry *parent,          // 父节点,一般是mkdir 对象
                const struct proc_ops *proc_fops // fops
);
```

- **更新之处**：原先的参数是 `file_operations` 后来更改为 `proc_ops`，差不多的用法

```c
struct proc_ops {
        unsigned int proc_flags;
        int     (*proc_open)(struct inode *, struct file *);
        ssize_t (*proc_read)(struct file *, char __user *, size_t, loff_t *);
        ssize_t (*proc_write)(struct file *, const char __user *, size_t, loff_t *);
        loff_t  (*proc_lseek)(struct file *, loff_t, int);
        int     (*proc_release)(struct inode *, struct file *);
        __poll_t (*proc_poll)(struct file *, struct poll_table_struct *);
        long    (*proc_ioctl)(struct file *, unsigned int, unsigned long);
#ifdef CONFIG_COMPAT
        long    (*proc_compat_ioctl)(struct file *, unsigned int, unsigned long);
#endif
        int     (*proc_mmap)(struct file *, struct vm_area_struct *);
        unsigned long (*proc_get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
} __randomize_layout;
```

### 参考

[pwn-college](https://github.com/pwncollege/pwnkernel)

- printk 参数

```c
#define	KERN_EMERG	"<0>"	/* system is unusable			*/
#define	KERN_ALERT	"<1>"	/* action must be taken immediately	*/
#define	KERN_CRIT	"<2>"	/* critical conditions			*/
#define	KERN_ERR	"<3>"	/* error conditions			*/
#define	KERN_WARNING	"<4>"	/* warning conditions			*/
#define	KERN_NOTICE	"<5>"	/* normal but significant condition	*/
#define	KERN_INFO	"<6>"	/* informational			*/
#define	KERN_DEBUG	"<7>"	/* debug-level messages			*/
```