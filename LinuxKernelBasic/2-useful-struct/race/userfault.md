## userfaultfd

>可以在用户态处理缺页异常的函数。

userfaultfd，这是 kernel 中提供的一种特殊的处理 page fault 的机制，能够让用户态程序自行处理自己的 page fault.

userfaultfd机制允许多线程程序中的**某个线程**为其他线程提供用户空间页面——如果该线程将这些页面注册到了userfaultfd对象上，那么当针对这些页面的缺页异常发生时，触发缺页异常的线程将**暂停运行**，内核将生成一个缺页异常事件并通过userfaultfd文件描述符传递给异常处理线程。异常处理线程可以做一些处理，然后唤醒之前暂停的线程。

```cpp
// from linux man page
#include <fcntl.h>             /* Definition of O_* constants */
#include <sys/syscall.h>       /* Definition of SYS_* constants */
#include <linux/userfaultfd.h> /* Definition of UFFD_* constants */
#include <unistd.h>

int syscall(SYS_userfaultfd, int flags);
```

### 页调度与延迟加载

有的内存既不在 RAM 也不在交换区(swap 分区)，例如mmap创建的内存映射页(存在页表项，但是物理页不在内存里)。
- 在内核中实现：mmap() 只是将 vma 的 vm_file 字段设置为被映射的文件对象，并且将 vma 的 fault() 回调函数设置为 filemap_fault()。也就是说，mmap() 系统调用并没有对虚拟内存进行任何的映射操作。
- 虚拟内存必须映射到物理内存才能使用。如果访问没有映射到物理内存的虚拟内存地址，CPU 将会触发缺页异常。
- 所以：mmap页在read/write访问之前，实际上还没有创建（还没有映射到实际的物理页），例如：`mmap(0x1337000, 0x1000, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_PRIVATE, fd, 0);` 内核并未将fd内容拷贝到0x1337000，只是将地址0x1337000映射到文件fd。读写会触发缺页异常

### 使用

注册一个 userfaultfd，通过 ioctl 监视一块内存区域，同时还需要专门启动一个用以进行轮询的线程 uffd monitor，该线程会通过 poll() 函数不断轮询直到出现缺页异常

1. 当有一个线程在这块内存区域内触发缺页异常时（比如说第一次访问一个匿名页），该线程（称之为 faulting 线程）进入到内核中处理缺页异常
2. 内核会调用 handle_userfault() 交由 userfaultfd 处理
3. faulting 线程进入阻塞状态，同时将一个 uffd_msg 发送给 monitor 线程，等待其处理结束
4. monitor 线程调用通过 ioctl 处理缺页异常，有如下选项：
`UFFDIO_COPY`：将用户自定义数据拷贝到 faulting page 上
`UFFDIO_ZEROPAGE` ：将 faulting page 置 0
`UFFDIO_WAKE`：用于配合上面两项中 UFFDIO_COPY_MODE_DONTWAKE 和 UFFDIO_ZEROPAGE_MODE_DONTWAKE 模式实现批量填充
5. 在处理结束后 monitor 线程发送信号唤醒 faulting 线程继续工作

该机制最初被设计来用以进行虚拟机 / 进程的迁移等用途，但是通过这个机制**我们可以控制进程执行流程的先后顺序，从而使得对条件竞争的利用成功率大幅提高。**

> 如果在进入函数后（copy_from_user() && copy_to_user()），实际拷贝开始前线程被中断换下 CPU，别的线程执行，修改了 ptr 指向的内存块的所有权（比如 kfree 掉了这个内存块），然后再执行拷贝时就可以实现 UAF。这种可能性当然是比较小的，但是如果 **user_buf 是一个 mmap 的内存块，并且我们为它注册了 userfaultfd**，那么在拷贝时出现缺页异常后此线程会先执行我们注册的处理函数，在处理函数结束前线程一直被暂停，结束后才会执行后面的操作，大大增加了竞争的成功率

### setxattr

- 既然学习了 userfaultfd，就不得不说 userfault + setxattr 的堆占位技术了。

setxattr 系统调用
- **kvmalloc 分配任意大小的 object 并 写入任意内容(copy_from_user)** 在不能写入的情况下比较好用
- 该 object 在 setxattr 执行结束时又会被放回 freelist 中
- kvmalloc: 大于pagesize vmalloc, 小于 kmalloc

```cpp
void *vmemdup_user(const void __user *src, size_t len) {
  void *p;

  p = kvmalloc(len, GFP_USER);
  if (!p) return ERR_PTR(-ENOMEM);

  if (copy_from_user(p, src, len)) {
    kvfree(p);
    return ERR_PTR(-EFAULT);
  }

  return p;
}
EXPORT_SYMBOL(vmemdup_user);

int setxattr_copy(const char __user *name, struct xattr_ctx *ctx) {
  int error;

  if (ctx->flags & ~(XATTR_CREATE | XATTR_REPLACE)) return -EINVAL;

  error = strncpy_from_user(ctx->kname->name, name, sizeof(ctx->kname->name));
  if (error == 0 || error == sizeof(ctx->kname->name)) return -ERANGE;
  if (error < 0) return error;

  error = 0;
  if (ctx->size) {
    if (ctx->size > XATTR_SIZE_MAX) return -E2BIG;

    ctx->kvalue = vmemdup_user(ctx->cvalue, ctx->size);
    if (IS_ERR(ctx->kvalue)) {
      error = PTR_ERR(ctx->kvalue);
      ctx->kvalue = NULL;
    }
  }

  return error;
}

static long setxattr(struct mnt_idmap *idmap, struct dentry *d,
                     const char __user *name, const void __user *value,
                     size_t size, int flags) {
  struct xattr_name kname;
  struct xattr_ctx ctx = {
      .cvalue = value,
      .kvalue = NULL,
      .size = size,
      .kname = &kname,
      .flags = flags,
  };
  int error;

  error = setxattr_copy(name, &ctx);
  if (error) return error;

  error = do_setxattr(idmap, d, &ctx);

  kvfree(ctx.kvalue);
  return error;
}
```

用户态调用如下函数
- 给文件设置属性

```cpp
#include <sys/xattr.h>

int setxattr(const char *path, const char *name, const void value[.size],
             size_t size, int flags);
```

因为 setxattr 的执行流会调用 copy_from_user 从用户空间拷贝数据，那么我们：
1. mmap 分配连续的两个页面，在第二个页面上 userfaultfd 监视。
2. 往第一个页面的末尾写入我们想要的数据，此时我们调用 setxattr 进行跨页面的拷贝，当 copy_from_user 拷贝到第二个页面时便会触发 userfaultfd，从而让 setxattr 的执行流程暂停，这样这个 object 就不会被释放掉。

![流程](./imgs/setxattr.png)

#### 问题：

能不能直接用 setxattr 而不使用 userfaultfd。
- free后可能会发生指针变化，因此具体情况具体分析吧


## 防护

unprivileged_userfault:
In order to also trap kernel page faults for the address space, either the process needs the CAP_SYS_PTRACE capability, or the system must have vm.unprivileged_userfaultfd set to 1. By default, vm.unprivileged_userfaultfd is set to 0.

可以使用root权限开启 userfaultfd 处理内核态 page_fault
```bash
$ cat /proc/sys/vm/unprivileged_userfaultfd
0

$ echo 1 | sudo tee /proc/sys/vm/unprivileged_userfaultfd
```


##  参考文章

- [CTF wiki](https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/race/userfaultfd/)
- [userfaultfd 探究](http://brieflyx.me/2020/linux-tools/userfaultfd-internals/)
- [userfaultfd QWB2021](https://cv196082.gitee.io/2022/08/16/userfaultfd/)
- [setxattr 堆占位](https://cv196082.gitee.io/2022/09/06/kernel%E5%A0%86%E5%8D%A0%E4%BD%8D/)