## kernel cred

- kernel 6.2

struct cred常用语内核 task 模块中，表示一个进程/任务的权限信息，包括uid、gid、euid…等身份信息，还有capability 信息。

```c
struct cred {
	atomic_t	usage;
#ifdef CONFIG_DEBUG_CREDENTIALS
	atomic_t	subscribers;	/* number of processes subscribed */
	void		*put_addr;
	unsigned	magic;
#define CRED_MAGIC	0x43736564
#define CRED_MAGIC_DEAD	0x44656144
#endif
	kuid_t		uid;		/* real UID of the task */
	kgid_t		gid;		/* real GID of the task */
	kuid_t		suid;		/* saved UID of the task */
	kgid_t		sgid;		/* saved GID of the task */
	kuid_t		euid;		/* effective UID of the task */
	kgid_t		egid;		/* effective GID of the task */
	kuid_t		fsuid;		/* UID for VFS ops */
	kgid_t		fsgid;		/* GID for VFS ops */
	unsigned	securebits;	/* SUID-less security management */
	kernel_cap_t	cap_inheritable; /* caps our children can inherit */
	kernel_cap_t	cap_permitted;	/* caps we're permitted */
	kernel_cap_t	cap_effective;	/* caps we can actually use */
	kernel_cap_t	cap_bset;	/* capability bounding set */
	kernel_cap_t	cap_ambient;	/* Ambient capability set */
#ifdef CONFIG_KEYS
	unsigned char	jit_keyring;	/* default keyring to attach requested
					 * keys to */
	struct key	*session_keyring; /* keyring inherited over fork */
	struct key	*process_keyring; /* keyring private to this process */
	struct key	*thread_keyring; /* keyring private to this thread */
	struct key	*request_key_auth; /* assumed request_key authority */
#endif
#ifdef CONFIG_SECURITY
	void		*security;	/* LSM security */
#endif
	struct user_struct *user;	/* real user ID subscription */
	struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */
	struct ucounts *ucounts;
	struct group_info *group_info;	/* supplementary groups for euid/fsgid */
	/* RCU deletion */
	union {
		int non_rcu;			/* Can we skip RCU deletion? */
		struct rcu_head	rcu;		/* RCU deletion hook */
	};
} __randomize_layout;
```

每个Linux进程都包含一个指向cred对象的指针。cred对象包含UID字段，表示进程权限。例如，GLOBAL_ROOT_UID表示任务具有root权限。当一个进程试图访问一个资源(例如一个文件)时，内核检查进程中cred对象中的UID，确定是否可以授予访问权限。除了UID，cred还包含capability.。该功能指定进程细粒度特权。例如，CAP_NET_BIND_SERVICE表示任务可以将套接字绑定到internet域特权端口。每个进程的凭证都是可配置的，在修改任务凭据时，内核遵循copy-and-replace方法。它会先复制凭据再修改副本，然后将进程中的cred指针更改为新修改的副本。在Linux中，每个进程只能更改自己的凭证。

### cred_jar slab

在 Linux 4.4 之前的版本中，其为 **kmalloc-192 的 alias**，即 cred 结构体与其他的 192 大小的 object 都会从同一个 kmem_cache——kmalloc-192 中分配。

- cred.c, SLAB_ACCOUNT 代表这是一个 单独的账户，相当于私有的，只要cred结构体才能使用

```cpp
static struct kmem_cache *cred_jar;

void __init cred_init(void)
{
	/* allocate a slab in which we can store credentials */
	cred_jar = kmem_cache_create("cred_jar", sizeof(struct cred), 0,
			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT, NULL);
}
```