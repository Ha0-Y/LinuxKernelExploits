## file

- kernel 6.2

struct file结构体描述一个文件的基本信息，包括文件地址、文件inode等，除此之外还保存着文件的访问信息，也就是说决定当前进程是否可读/写该文件(一定是打开成功才会有struct file，如果打开都无法打开的话，则不会有struct file)。

```c
struct file {
	union {
		struct llist_node	f_llist;
		struct rcu_head 	f_rcuhead;
		unsigned int 		f_iocb_flags;
	};
	struct path		f_path;
	struct inode		*f_inode;	/* cached value */
	const struct file_operations	*f_op;

	/*
	 * Protects f_ep, f_flags.
	 * Must not be taken from IRQ context.
	 */
	spinlock_t		f_lock;
	atomic_long_t		f_count;
	unsigned int 		f_flags;
	fmode_t			f_mode;
	struct mutex		f_pos_lock;
	loff_t			f_pos;
	struct fown_struct	f_owner;
	const struct cred	*f_cred;
	struct file_ra_state	f_ra;

	u64			f_version;
#ifdef CONFIG_SECURITY
	void			*f_security;
#endif
	/* needed for tty driver, and maybe others */
	void			*private_data;

#ifdef CONFIG_EPOLL
	/* Used by fs/eventpoll.c to link all the hooks to this file */
	struct hlist_head	*f_ep;
#endif /* #ifdef CONFIG_EPOLL */
	struct address_space	*f_mapping;
	errseq_t		f_wb_err;
	errseq_t		f_sb_err; /* for syncfs */
} __randomize_layout
  __attribute__((aligned(4)));	/* lest something weird decides that 2 is OK */
```

在Linux内核中，每个文件都有其所有者的UID和GID以及其他用户的访问权限和能力。对于可执行文件，它们还具有SUID/SGID标志，指示允许其他用户以所有者的特权运行的特殊权限。在Linux内核实现中，每个文件都**绑定到一个链接到凭证的inode对象**。当一个进程试图打开一个文件时，内核**调用函数inode_permission会在授予文件访问权之前检查inode和相应的权限**。打开文件后，内核断开与inode对象的凭据链接并将它们附加到file对象。除了维护凭证之外，file对象还包含文件的读/写权限。通过file对象，内核可以索引到cred对象，从而检查特权。此外，它还可以检查读写权限，从而确保进程不会向以只读模式打开的文件写入数据。

### filp slab

- `fs/file_table.c`

```cpp
void __init files_init(void)
{
	filp_cachep = kmem_cache_create("filp", sizeof(struct file), 0,
			SLAB_HWCACHE_ALIGN | SLAB_PANIC | SLAB_ACCOUNT, NULL);
	percpu_counter_init(&nr_files, 0, GFP_KERNEL);
}
```