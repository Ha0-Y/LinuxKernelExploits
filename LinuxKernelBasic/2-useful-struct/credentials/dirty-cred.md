## dirty cred

>无地址依赖的漏洞利用方式，灵感来自于 DirtyPipe。
> Zhenpeng Lin 博士在 2022-CCS 发表的论文 DirtyCred: Escalating Privilege in Linux Kernel，Dirty Cred 是该论文中提到的一种新的内核漏洞利用思路，同时也在Black Hat中作为议题。

- 记得 kernel pwn 入门时，[UAF](https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/heap/slub/uaf/)漏洞直接将 cred 结构体给覆盖掉部分uid,gid从而进行提权，但是现在那种方法好像不能用了，因为cred有着自己的slab

- DirtyCred优点：一是通用性强，适用于任意堆相关的漏洞；二是降低了exp适配难度，同一exp可用于不同版本和架构的内核；三是可以绕过主流的防护机制，例如CFI/KASLR/SMEP/SMAP/KPTI等。

### 内核凭证

Linux中凭据会引用一些包含特权信息的内核属性。通过这些属性，Linux内核可以检查用户的访问权限。在Linux内核中，凭据被实现为携带特权信息的内核对象。这些对象包括cred、file和inode。**因为inode对象只能在文件系统上创建新文件时分配，这没有为内存操作(成功利用程序的关键操作)提供足够的利用空间，所以只考虑cred和file对象来设计利用链**。

在这里主要利用 `task credentials` 和 `open file credentials`，具体表现为 `struct cred` & `struct file`

- struct cred 见 [cred](./cred.md)
- struct file 见 [file](./file.md)

### slab 分类

Generic Caches && Dedicated Caches：漏洞一般发生在通用cache中，而 cred/file 对象则位于专有cache中。内核中可通过`sudo cat /proc/slabinfo` 命令进行查看

#### 通用内存slab

>Generic Caches

Linux内核有不同的通用缓存来分配不同大小的内存。当从通用缓存分配内存时，内核将首先取整请求的大小并找到与大小请求匹配的缓存，然后从相应的缓存分配一个内存片段。在Linux内核中，如果分配请求没有指定它从哪些类型的缓存进行分配，那么分配在默认情况下发生在通用缓存上。对于属于相同通用缓存的分配，它们可以共享相同的内存地址，因为它们可以维护在相同的内存页面上。

在内核中，直接调用kmalloc 分配的内存，如果特别大(大于一页)则会直接调用伙伴系统申请页面。否则会调用通用slab 进行分配。

#### 特殊内存slab

>Dedicated Caches

内核中常用的结构体会使用 `kmem_cache_create`创造的独特的slab`(SLAB_ACCOUNT)`,增快速度.

Linux内核为性能和安全目的创建专用缓存。由于有些对象在内核中经常被使用，为这些对象专用缓存可以减少分配它们的时间，从而提高系统性能。专用缓存与通用缓存不共享相同的内存页，因此在通用缓存中分配的对象与专用缓存中的对象不相邻。它可以被视为缓存级隔离，从而减轻了来自通用缓存中的溢出影响

## Exploit

内核中对权限/身份的校验发生在具体操作之前，而**校验身份的动作往往不会被锁限制**。那么我们可以卡在身份验证和操作之间将目标结构替换掉来完成漏洞利用。这可能需要一些手段来将非内核凭证 slab 的漏洞转换为内核凭证 slab 区域的漏洞，和一些延长身份验证和具体操作之间的时间窗的手段。

### free credentials

#### OOB or UAF write

首先找到一个 victim 对象，和漏洞对象位于相同cache且包含一个凭证指针；再利用漏洞将 victim 的凭证指针的最后两字节覆写为0，这样该指针就可能指向内存页开头的另一个凭证对象；这样就有2个指针指向内存页的第1个凭证对象，可以释放该对象两次。就像 `CVE-2021-4154` 相同的利用方法。

问题：一是该页的地址的最低2字节都为0的概率是1/16（0x0000-0xf000）；二是有 freelist 保护；三是漏洞可能不允许只覆写最后2字节，得先泄露堆地址

#### DF

一般 Double-Free 发生在通用cache中，而内核凭证位于 dedicated cache 中，所以这里需要进行 cross-cache 内存布局。内核会回收未使用的内存页，然后分配给其他需要更多空间的cache。

### allocate privileged credentials as unprivileged users.

cred：低权限用户可以执行具有SUID权限的binary（为root用户所拥有），例如 su/ping/sudo/mount/pkexec，或者频繁创建特权级守护进程（例如sshd），就会分配特权cred对象。

file：直接打开具有只读权限的文件即可（例如 /etc/passwd）。

#### allocate privileged credentials as root 

内核发起新线程时，会复制父进程，包括cred对象（具有和父进程相同的权限）。
一是给内核工作队列创建大量任务，就会创建新的内核线程来执行任务；二是调用 usermode helper，这是一种允许内核创建用户模式进程的机制，例如将内核模块加载到内核空间（内核在加载内核模块时，需要在内核层执行 modprobe 程序，来在标准安装驱动路径下搜索目标驱动。）

### stabilize file exploitation

>fuse or userfaultfd 

userfaultfd允许用户空间处理页错误（但是从内核 v5.11 开始，用户层 userfaultfd 默认禁用）
FUSE允许用户实现用户空间的文件系统，用户可以注册handler函数来响应文件操作的请求。只要存在从用户向内核拷贝数据的程序点，二者都可以**暂停内核的执行**。

### Defence

隔离高权限和低权限凭证对象。高权限对象存放在虚拟内存中（virtual memory region），也即调用 vmalloc 分配的内存，范围是 VMALLOC_START ~ VMALLOC_END ；低权限对象存放在正常内存中（direct-mapped memory region），二者不会重叠。注意， vmalloc 保证虚拟地址空间上连续（需要配置页表，所以速度会慢一点），kmalloc 保证分配的内存在物理地址空间上连续。

## 参考

- [US-22-Lin-Cautious-A-New-Exploitation-Method](https://i.blackhat.com/USA-22/Thursday/US-22-Lin-Cautious-A-New-Exploitation-Method.pdf)
- [paper DirtyCred](https://zplin.me/papers/DirtyCred.pdf)