# linux kernel pipe

- /fs/pipe.c
- /include/fs/

## 创建 pipe 

- 用户态调用

```cpp
int pipe(int pipefd[2]);
```

- pipe.c

```cpp
SYSCALL_DEFINE2(pipe2, int __user *, fildes, int, flags)
{
	return do_pipe2(fildes, flags);
}

SYSCALL_DEFINE1(pipe, int __user *, fildes)
{
	return do_pipe2(fildes, 0);
}
```

### pipe_inode_info

pipe_inode_info则代表该管道的总体基本信息，通过 `bufs` 成员通过下标访问上面提到的16个pipe_buffer 结构体，其中 `head` 和 `tail` 成员分别代表头尾下标，pipe_buffer 通过head 和tail 组成一个环形队列的结构，

alloc_pipe_inode
- kzalloc 一个 pipe_inode_info 结构体，作为pipe
- kcalloc pipe->bufs 数组，明确点是一个queue。
- pipe_bufs 代表`pipe->bufs`默认的`pipe_buffer`数量
- kzalloc: kmalloc `__GFP_ZERO` flag 会对申请到的内存内容清零,因此开始的head和tail全为0

```cpp
struct pipe_inode_info *alloc_pipe_info(void)
{
	struct pipe_inode_info *pipe;
	unsigned long pipe_bufs = PIPE_DEF_BUFFERS;
	struct user_struct *user = get_current_user();
	unsigned long user_bufs;
	unsigned int max_size = READ_ONCE(pipe_max_size);

	pipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL_ACCOUNT);
	if (pipe == NULL)
		goto out_free_uid;

	if (pipe_bufs * PAGE_SIZE > max_size && !capable(CAP_SYS_RESOURCE))
		pipe_bufs = max_size >> PAGE_SHIFT;

	user_bufs = account_pipe_buffers(user, 0, pipe_bufs);

	if (too_many_pipe_buffers_soft(user_bufs) && pipe_is_unprivileged_user()) {
		user_bufs = account_pipe_buffers(user, pipe_bufs, PIPE_MIN_DEF_BUFFERS);
		pipe_bufs = PIPE_MIN_DEF_BUFFERS;
	}

	if (too_many_pipe_buffers_hard(user_bufs) && pipe_is_unprivileged_user())
		goto out_revert_acct;

	pipe->bufs = kcalloc(pipe_bufs, sizeof(struct pipe_buffer),
			     GFP_KERNEL_ACCOUNT);

	if (pipe->bufs) {
		init_waitqueue_head(&pipe->rd_wait);
		init_waitqueue_head(&pipe->wr_wait);
		pipe->r_counter = pipe->w_counter = 1;
		pipe->max_usage = pipe_bufs;
		pipe->ring_size = pipe_bufs;
		pipe->nr_accounted = pipe_bufs;
		pipe->user = user;
		mutex_init(&pipe->mutex);
		return pipe;
	}

out_revert_acct:
	(void) account_pipe_buffers(user, pipe_bufs, 0);
	kfree(pipe);
out_free_uid:
	free_uid(user);
	return NULL;
}
```

### pipe bufs ring_size 大小修改

`struct pipe_buffer` 的size为0x28，且使用kcalloc分配，而count为0x10，因此会分配0x280的堆块。
- 使用 kmalloc-1024.
- 使用的flag为 GFP_KERNEL_ACCOUNT,不是SLAB_ACCOUNT 说明是通用slab。

```cpp
...
unsigned long pipe_bufs = PIPE_DEF_BUFFERS; // 0x10

...
pipe->bufs = kcalloc(pipe_bufs, sizeof(struct pipe_buffer),
			     GFP_KERNEL_ACCOUNT);
...
```

> 但是 pipe 系统调用非常贴心地为我们提供了 F_SETPIPE_SZ 让我们可以重新分配 pipe_buffer 并指定其数量，从而可以让 bufs 在不同的 kmem_cache 中

1. fcntl

```cpp
long pipe_fcntl(struct file *file, unsigned int cmd, unsigned long arg)
{
	struct pipe_inode_info *pipe;
	long ret;

	pipe = get_pipe_info(file, false);
	if (!pipe)
		return -EBADF;

	__pipe_lock(pipe);

	switch (cmd) {
	case F_SETPIPE_SZ:
		ret = pipe_set_size(pipe, arg);
		break;
	case F_GETPIPE_SZ:
		ret = pipe->max_usage * PAGE_SIZE;
		break;
	default:
		ret = -EINVAL;
		break;
	}

	__pipe_unlock(pipe);
	return ret;
}
```

2. pipe_set_size 修改 pipe->bufs 对应的 slab
- round_pipe_size: 最终会返回我们输入的数字
- nr_slots 右移12位  `#define PAGE_SHIFT	12` $2^{12} ==  0x1000$

```cpp
static long pipe_set_size(struct pipe_inode_info *pipe, unsigned long arg)
{
	unsigned long user_bufs;
	unsigned int nr_slots, size;
	long ret = 0;

#ifdef CONFIG_WATCH_QUEUE
	if (pipe->watch_queue)
		return -EBUSY;
#endif

	size = round_pipe_size(arg);   
	nr_slots = size >> PAGE_SHIFT;   

	if (!nr_slots)
		return -EINVAL;

	/*
	 * If trying to increase the pipe capacity, check that an
	 * unprivileged user is not trying to exceed various limits
	 * (soft limit check here, hard limit check just below).
	 * Decreasing the pipe capacity is always permitted, even
	 * if the user is currently over a limit.
	 */
	if (nr_slots > pipe->max_usage &&
			size > pipe_max_size && !capable(CAP_SYS_RESOURCE))
		return -EPERM;

	user_bufs = account_pipe_buffers(pipe->user, pipe->nr_accounted, nr_slots);

	if (nr_slots > pipe->max_usage &&
			(too_many_pipe_buffers_hard(user_bufs) ||
			 too_many_pipe_buffers_soft(user_bufs)) &&
			pipe_is_unprivileged_user()) {
		ret = -EPERM;
		goto out_revert_acct;
	}

	ret = pipe_resize_ring(pipe, nr_slots);
	if (ret < 0)
		goto out_revert_acct;

	pipe->max_usage = nr_slots;
	pipe->nr_accounted = nr_slots;
	return pipe->max_usage * PAGE_SIZE;

out_revert_acct:
	(void) account_pipe_buffers(pipe->user, nr_slots, pipe->nr_accounted);
	return ret;
}
```

3. 然后调用 pipe_resize_ring
- calloc nr_slots 由我们输入决定
- 如果数量小于之前的 bufs 用过的数量，错误 ret。
- 如果大于，就会将之前pipe->bufs的内容复制一下，free掉之前的pipe->bufs
- 最后做一些变量修改，`pipe->ring_size = nr_slots` 

```cpp
int pipe_resize_ring(struct pipe_inode_info *pipe, unsigned int nr_slots)
{
	struct pipe_buffer *bufs;
	unsigned int head, tail, mask, n;

	bufs = kcalloc(nr_slots, sizeof(*bufs),
		       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);
	if (unlikely(!bufs))
		return -ENOMEM;

	spin_lock_irq(&pipe->rd_wait.lock);
	mask = pipe->ring_size - 1;
	head = pipe->head;
	tail = pipe->tail;

	n = pipe_occupancy(head, tail);
	if (nr_slots < n) {
		spin_unlock_irq(&pipe->rd_wait.lock);
		kfree(bufs);
		return -EBUSY;
	}

	/*
	 * The pipe array wraps around, so just start the new one at zero
	 * and adjust the indices.
	 */
	if (n > 0) {
		unsigned int h = head & mask;
		unsigned int t = tail & mask;
		if (h > t) {
			memcpy(bufs, pipe->bufs + t,
			       n * sizeof(struct pipe_buffer));
		} else {
			unsigned int tsize = pipe->ring_size - t;
			if (h > 0)
				memcpy(bufs + tsize, pipe->bufs,
				       h * sizeof(struct pipe_buffer));
			memcpy(bufs, pipe->bufs + t,
			       tsize * sizeof(struct pipe_buffer));
		}
	}

	head = n;
	tail = 0;

	kfree(pipe->bufs);
	pipe->bufs = bufs;
	pipe->ring_size = nr_slots;
	if (pipe->max_usage > nr_slots)
		pipe->max_usage = nr_slots;
	pipe->tail = tail;
	pipe->head = head;

	spin_unlock_irq(&pipe->rd_wait.lock);

	/* This might have made more room for writers */
	wake_up_interruptible(&pipe->wr_wait);
	return 0;
}
```

4. ring_size 在`struct pipe_inode_info`声明：(should be a power of 2)，2的指数
- 我们传入的数据，内核会进行处理。size = round_pipe_size(arg);
- 四舍五入：将这个数字取 `log2` 对于这个数字四舍五入，取 `pow` 作为返回值

```cpp
unsigned int round_pipe_size(unsigned int size)
{
	if (size > (1U << 31))
		return 0;

	/* Minimum pipe size, as required by POSIX */
	if (size < PAGE_SIZE)
		return PAGE_SIZE;

	return roundup_pow_of_two(size);
}
```
由上面可知：`fcntl(pipe_fd[i][1], F_SETPIPE_SZ, 0x1000 * 64)` 就是将 `pipe->bufs` ring_size 改成64, 相当于kmalloc 0x40个 `struct pipe_buffer`, 0x40 * 18 = 1792 使用 kmalloc-2k slab

```bash
$ sudo cat /proc/slabinfo
...
kmalloc-cg-2k        672    672   2048   16    8 : tunables    0    0    0 : slabdata     42     42      0
kmalloc-cg-1k        455    608   1024   32    8 : tunables    0    0    0 : slabdata     19     19      0
kmalloc-cg-512       576    576    512   32    4 : tunables    0    0    0 : slabdata     18     18      0
...
```

### 读写 pipe

**head用来写，tail用来读。**：offset 和 len。偏移和总长度，offset指向未读取数据开始，len代表数据总长度

pipe_write 源码，主要看创建页，然后写的过程。
- alloc_page 创建一个page，然后赋值给pipe->tmp_page
- 寻找head指针，赋值给bufs的header,header+1
- 存在追加模式：PIPE_BUF_FLAG_CAN_MERGE。尝试写的过程

```cpp

static ssize_t pipe_write(struct kiocb *iocb, struct iov_iter *from) {
  struct file *filp = iocb->ki_filp;
  struct pipe_inode_info *pipe = filp->private_data;
  unsigned int head;
  ssize_t ret = 0;
  size_t total_len = iov_iter_count(from);
  ssize_t chars;
  bool was_empty = false;
  bool wake_next_writer = false;

  /* Null write succeeds. */
  if (unlikely(total_len == 0)) return 0;

  __pipe_lock(pipe);

  if (!pipe->readers) {
    send_sig(SIGPIPE, current, 0);
    ret = -EPIPE;
    goto out;
  }

#ifdef CONFIG_WATCH_QUEUE
  if (pipe->watch_queue) {
    ret = -EXDEV;
    goto out;
  }
#endif

  /*
   * If it wasn't empty we try to merge new data into
   * the last buffer.
   *
   * That naturally merges small writes, but it also
   * page-aligns the rest of the writes for large writes
   * spanning multiple pages.
   */
  head = pipe->head;
  was_empty = pipe_empty(head, pipe->tail);
  chars = total_len & (PAGE_SIZE - 1);
  if (chars && !was_empty) {
    unsigned int mask = pipe->ring_size - 1;
    struct pipe_buffer *buf = &pipe->bufs[(head - 1) & mask];
    int offset = buf->offset + buf->len;

    if ((buf->flags & PIPE_BUF_FLAG_CAN_MERGE) && offset + chars <= PAGE_SIZE) {
      ret = pipe_buf_confirm(pipe, buf);
      if (ret) goto out;

      ret = copy_page_from_iter(buf->page, offset, chars, from);
      if (unlikely(ret < chars)) {
        ret = -EFAULT;
        goto out;
      }

      buf->len += ret;
      if (!iov_iter_count(from)) goto out;
    }
  }

  for (;;) {
    if (!pipe->readers) {
      send_sig(SIGPIPE, current, 0);
      if (!ret) ret = -EPIPE;
      break;
    }

    head = pipe->head;
    if (!pipe_full(head, pipe->tail, pipe->max_usage)) {
      unsigned int mask = pipe->ring_size - 1;
      struct pipe_buffer *buf;
      struct page *page = pipe->tmp_page;
      int copied;

      if (!page) {
        page = alloc_page(GFP_HIGHUSER | __GFP_ACCOUNT);
        if (unlikely(!page)) {
          ret = ret ?: -ENOMEM;
          break;
        }
        pipe->tmp_page = page;
      }

      /* Allocate a slot in the ring in advance and attach an
       * empty buffer.  If we fault or otherwise fail to use
       * it, either the reader will consume it or it'll still
       * be there for the next write.
       */
      spin_lock_irq(&pipe->rd_wait.lock);

      head = pipe->head;
      if (pipe_full(head, pipe->tail, pipe->max_usage)) {
        spin_unlock_irq(&pipe->rd_wait.lock);
        continue;
      }

      pipe->head = head + 1;
      spin_unlock_irq(&pipe->rd_wait.lock);

      /* Insert it into the buffer array */
      buf = &pipe->bufs[head & mask];
      buf->page = page;
      buf->ops = &anon_pipe_buf_ops;
      buf->offset = 0;
      buf->len = 0;
      if (is_packetized(filp))
        buf->flags = PIPE_BUF_FLAG_PACKET;
      else
        buf->flags = PIPE_BUF_FLAG_CAN_MERGE;
      pipe->tmp_page = NULL;

      copied = copy_page_from_iter(page, 0, PAGE_SIZE, from);
      if (unlikely(copied < PAGE_SIZE && iov_iter_count(from))) {
        if (!ret) ret = -EFAULT;
        break;
      }
      ret += copied;
      buf->len = copied;

      if (!iov_iter_count(from)) break;
    }

    if (!pipe_full(head, pipe->tail, pipe->max_usage)) continue;

    /* Wait for buffer space to become available. */
    if ((filp->f_flags & O_NONBLOCK) || (iocb->ki_flags & IOCB_NOWAIT)) {
      if (!ret) ret = -EAGAIN;
      break;
    }
    if (signal_pending(current)) {
      if (!ret) ret = -ERESTARTSYS;
      break;
    }

    /*
     * We're going to release the pipe lock and wait for more
     * space. We wake up any readers if necessary, and then
     * after waiting we need to re-check whether the pipe
     * become empty while we dropped the lock.
     */
    __pipe_unlock(pipe);
    if (was_empty)
      wake_up_interruptible_sync_poll(&pipe->rd_wait, EPOLLIN | EPOLLRDNORM);
    kill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);
    wait_event_interruptible_exclusive(pipe->wr_wait, pipe_writable(pipe));
    __pipe_lock(pipe);
    was_empty = pipe_empty(pipe->head, pipe->tail);
    wake_next_writer = true;
  }
out:
  if (pipe_full(pipe->head, pipe->tail, pipe->max_usage))
    wake_next_writer = false;
  __pipe_unlock(pipe);

  /*
   * If we do do a wakeup event, we do a 'sync' wakeup, because we
   * want the reader to start processing things asap, rather than
   * leave the data pending.
   *
   * This is particularly important for small writes, because of
   * how (for example) the GNU make jobserver uses small writes to
   * wake up pending jobs
   *
   * Epoll nonsensically wants a wakeup whether the pipe
   * was already empty or not.
   */
  if (was_empty || pipe->poll_usage)
    wake_up_interruptible_sync_poll(&pipe->rd_wait, EPOLLIN | EPOLLRDNORM);
  kill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);
  if (wake_next_writer)
    wake_up_interruptible_sync_poll(&pipe->wr_wait, EPOLLOUT | EPOLLWRNORM);
  if (ret > 0 && sb_start_write_trylock(file_inode(filp)->i_sb)) {
    int err = file_update_time(filp);
    if (err) ret = err;
    sb_end_write(file_inode(filp)->i_sb);
  }
  return ret;
}
```

pipe_read 源码
- len为0，会release buf(`pipe->bufs[tail & mask]`)。
- tail++

```cpp
static ssize_t
pipe_read(struct kiocb *iocb, struct iov_iter *to)
{
	size_t total_len = iov_iter_count(to);
	struct file *filp = iocb->ki_filp;
	struct pipe_inode_info *pipe = filp->private_data;
	bool was_full, wake_next_reader = false;
	ssize_t ret;

	/* Null read succeeds. */
	if (unlikely(total_len == 0))
		return 0;

	ret = 0;
	__pipe_lock(pipe);

	/*
	 * We only wake up writers if the pipe was full when we started
	 * reading in order to avoid unnecessary wakeups.
	 *
	 * But when we do wake up writers, we do so using a sync wakeup
	 * (WF_SYNC), because we want them to get going and generate more
	 * data for us.
	 */
	was_full = pipe_full(pipe->head, pipe->tail, pipe->max_usage);
	for (;;) {
		/* Read ->head with a barrier vs post_one_notification() */
		unsigned int head = smp_load_acquire(&pipe->head);
		unsigned int tail = pipe->tail;
		unsigned int mask = pipe->ring_size - 1;

#ifdef CONFIG_WATCH_QUEUE
		if (pipe->note_loss) {
			struct watch_notification n;

			if (total_len < 8) {
				if (ret == 0)
					ret = -ENOBUFS;
				break;
			}

			n.type = WATCH_TYPE_META;
			n.subtype = WATCH_META_LOSS_NOTIFICATION;
			n.info = watch_sizeof(n);
			if (copy_to_iter(&n, sizeof(n), to) != sizeof(n)) {
				if (ret == 0)
					ret = -EFAULT;
				break;
			}
			ret += sizeof(n);
			total_len -= sizeof(n);
			pipe->note_loss = false;
		}
#endif

		if (!pipe_empty(head, tail)) {
			struct pipe_buffer *buf = &pipe->bufs[tail & mask];
			size_t chars = buf->len;
			size_t written;
			int error;

			if (chars > total_len) {
				if (buf->flags & PIPE_BUF_FLAG_WHOLE) {
					if (ret == 0)
						ret = -ENOBUFS;
					break;
				}
				chars = total_len;
			}

			error = pipe_buf_confirm(pipe, buf);
			if (error) {
				if (!ret)
					ret = error;
				break;
			}

			written = copy_page_to_iter(buf->page, buf->offset, chars, to);
			if (unlikely(written < chars)) {
				if (!ret)
					ret = -EFAULT;
				break;
			}
			ret += chars;
			buf->offset += chars;
			buf->len -= chars;

			/* Was it a packet buffer? Clean up and exit */
			if (buf->flags & PIPE_BUF_FLAG_PACKET) {
				total_len = chars;
				buf->len = 0;
			}

			if (!buf->len) {
				pipe_buf_release(pipe, buf);
				spin_lock_irq(&pipe->rd_wait.lock);
#ifdef CONFIG_WATCH_QUEUE
				if (buf->flags & PIPE_BUF_FLAG_LOSS)
					pipe->note_loss = true;
#endif
				tail++;
				pipe->tail = tail;
				spin_unlock_irq(&pipe->rd_wait.lock);
			}
			total_len -= chars;
			if (!total_len)
				break;	/* common path: read succeeded */
			if (!pipe_empty(head, tail))	/* More to do? */
				continue;
		}

		if (!pipe->writers)
			break;
		if (ret)
			break;
		if ((filp->f_flags & O_NONBLOCK) ||
		    (iocb->ki_flags & IOCB_NOWAIT)) {
			ret = -EAGAIN;
			break;
		}
		__pipe_unlock(pipe);

		/*
		 * We only get here if we didn't actually read anything.
		 *
		 * However, we could have seen (and removed) a zero-sized
		 * pipe buffer, and might have made space in the buffers
		 * that way.
		 *
		 * You can't make zero-sized pipe buffers by doing an empty
		 * write (not even in packet mode), but they can happen if
		 * the writer gets an EFAULT when trying to fill a buffer
		 * that already got allocated and inserted in the buffer
		 * array.
		 *
		 * So we still need to wake up any pending writers in the
		 * _very_ unlikely case that the pipe was full, but we got
		 * no data.
		 */
		if (unlikely(was_full))
			wake_up_interruptible_sync_poll(&pipe->wr_wait, EPOLLOUT | EPOLLWRNORM);
		kill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);

		/*
		 * But because we didn't read anything, at this point we can
		 * just return directly with -ERESTARTSYS if we're interrupted,
		 * since we've done any required wakeups and there's no need
		 * to mark anything accessed. And we've dropped the lock.
		 */
		if (wait_event_interruptible_exclusive(pipe->rd_wait, pipe_readable(pipe)) < 0)
			return -ERESTARTSYS;

		__pipe_lock(pipe);
		was_full = pipe_full(pipe->head, pipe->tail, pipe->max_usage);
		wake_next_reader = true;
	}
	if (pipe_empty(pipe->head, pipe->tail))
		wake_next_reader = false;
	__pipe_unlock(pipe);

	if (was_full)
		wake_up_interruptible_sync_poll(&pipe->wr_wait, EPOLLOUT | EPOLLWRNORM);
	if (wake_next_reader)
		wake_up_interruptible_sync_poll(&pipe->rd_wait, EPOLLIN | EPOLLRDNORM);
	kill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);
	if (ret > 0)
		file_accessed(filp);
	return ret;
}
```

page结构体也是一个比较复杂的结构体，可以看[这里](https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/heap/heap_overview/#page)
- pipe->bufs 中 pipe_buffer 存在指向 page 的指针，我们在写pipe时会写入这个page中指向的内存，调用 `copy_page_from_iter` 
- 向新pipe中写点内容，alloc_pages。
- close pipe 时会将pagesfree掉

## Pipe Primitive

灵感来源于 dirty pipe,修改flag使其和 dirty pipe 漏洞成因一致，从而摆脱对地址的依赖
- liunx 内核将打开的文件通过缓存页的形式保存，对文件缓存页的访问鉴权是通过访问函数实现的，对缓存页本身操作并没有鉴权。多个不同进程访问同一个文件实际访问的是同一个缓存页。
- pipe 可以使用 splice 将其他文件的缓存页直接链接到 pipe 里。`PIPE_BUF_FLAG_CAN_MERGE` 的 flag属性,我们读取一个可读文件一字节进入pipe,然后在向pipe写，就会将内容写入原文件中。

```cpp
ssize_t splice(int fd_in, off64_t *off_in, int fd_out, off64_t *off_out, size_t len, unsigned int flags);
```


## references

- [pipe-buffer arb read/write](https://www.interruptlabs.co.uk/articles/pipe-buffer)
- [ctf-wiki page](https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/heap/heap_overview/#page)