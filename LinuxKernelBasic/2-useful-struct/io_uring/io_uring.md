# io_uring subsystem

## Linux IO

### 阻塞IO

read, write

```c
ssize_t read(int fd, void *buf, size_t count);
ssize_t write(int fd, const void *buf, size_t count);
```

二者称为阻塞式系统调用（blocking system calls）。程序调用这些函数时会进入 **sleep** 状态，然后被调度出去（让出处理器），直到 I/O 操作完成：

如果数据在文件中，并且文件内容已经缓存在 page cache 中，调用会立即返回；
如果数据在另一台机器上，就需要通过网络（例如 TCP）获取，会阻塞一段时间；
如果数据在硬盘上，也会阻塞一段时间。

容易想到，随着存储设备越来越快，程序越来越复杂， 阻塞式（blocking）已经这种最简单的方式已经不适用了。

### 非阻塞IO

select, poll, epoll: 应用程序在调用这些函数读写时不会阻塞，而是立即返回，返回的是一个 已经 ready 的文件描述符列表。
本质是轮询：几个fd一起查询，返回ready的集合

```c
int select(
    int nfds,
    fd_set *readfds,
    fd_set *writefds,
    fd_set *exceptfds,
    struct timeval *timeout
);

int poll(struct pollfd *ufds, unsigned int nfds, int timeout);
struct pollfd {
　　int fd;           /*文件描述符*/
　　short events;     /*监控的事件*/
　　short revents;    /*监控事件中满足条件返回的事件*/
};

int epoll_create(int size);
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); 
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout); 
```

但这种方式存在一个致命缺点：只支持 **network sockets 和 pipes** —— epoll() 甚至连 storage files 都不支持。

### AIO

async IO: 异步IO

用户通过 io_submit() 提交 I/O 请求，
过一会再调用 io_getevents() 来检查哪些 events 已经 ready 了。

```c
int io_setup(unsigned nr_events, aio_context_t *ctx_idp);
int io_submit(aio_context_t ctx_id, long nr, struct iocb **iocbpp);
int io_getevents(aio_context_t ctx_id, long min_nr, long nr,
                 struct io_event *events, struct timespec *timeout);
int io_cancel(aio_context_t ctx_id, struct iocb *iocb,
                     struct io_event *result);
int io_destroy(aio_context_t ctx_id);
```

虽然从技术上说接口是非阻塞的，但实际上有 很多可能的原因都会导致它阻塞，而且引发的方式难以预料

### io_uring

这项工作始于一个很简单的观察：随着设备越来越快， 中断驱动（interrupt-driven）模式效率已经低于轮询模式 （polling for completions） —— 这也是高性能领域最常见的主题之一。

io_uring 的基本逻辑与 linux-aio 是类似的：提供两个接口，一个将 I/O 请求提交到内核，一个从内核接收完成事件。

于AIO 不同：

- 在设计上是真正异步的（truly asynchronous）。只要 设置了合适的 flag，它在系统调用上下文中就只是将请求放入队列， 不会做其他任何额外的事情，保证了应用永远不会阻塞。
- 支持任何类型的 I/O：cached files、direct-access files 甚至 blocking sockets。
- 由于设计上就是异步的（async-by-design nature），因此无需 poll+read/write 来处理 sockets。 只需提交一个阻塞式读（blocking read），请求完成之后，就会出现在 completion ring。
- 灵活、可扩展：基于 io_uring 甚至能重写（re-implement）Linux 的每个系统调用。

#### 核心原理

每个 io_uring 实例都有两个**环形队列（ring）**，在内核和应用程序之间共享：
1. 提交队列：submission queue (SQ)
2. 完成队列：completion queue (CQ)


两个队列都是单生产者、单消费者，size 是 2 的幂次；

1. 请求

- 应用创建 SQ entries (SQE)，更新 SQ tail；
- 内核消费 SQE，更新 SQ head。

2. 完成

- 内核为完成的一个或多个请求创建 CQ entries (CQE)，更新 CQ tail；
- 应用消费 CQE，更新 CQ head。
- 完成事件（completion events）可能以任意顺序到达，到总是与特定的 SQE 相关联的。
- 消费 CQE 过程无需切换到内核态。

#### 系统调用API

```c
#include <linux/io_uring.h>
```

io_uring_setup:

- 创建一个 SQ 和一个 CQ，
- queue size 至少 entries 个元素，
- 返回一个文件描述符，随后用于在这个 io_uring 实例上执行操作。

```c
int io_uring_setup(u32 entries, struct io_uring_params *p);
```

io_uring_register: 注册文件或用户缓冲区，使内核能长时间持有对该文件在内核内部的数据结构引用

```c
int io_uring_register(unsigned int fd, unsigned int opcode, void *arg, unsigned int nr_args);
```

io_uring_enter: 这个系统调用用于初始化和完成（initiate and complete）I/O，使用共享的 SQ 和 CQ

```c
int io_uring_enter(unsigned int fd, unsigned int to_submit, unsigned int min_complete, unsigned int flags, sigset_t *sig);
```

#### liburing: 用户空间调用

>方便了在用户空间的调用

- [仓库地址](https://github.com/axboe/liburing)，内有案例

## kernel exploit中的应用

### setup

申请 ctx 结构体

### register

```c
SYSCALL_DEFINE4(io_uring_register, unsigned int, fd, unsigned int, opcode,
		void __user *, arg, unsigned int, nr_args)
{
  ...
	if (opcode >= IORING_REGISTER_LAST)
		return -EINVAL;
  
  ...
	ret = __io_uring_register(ctx, opcode, arg, nr_args);
  ...
	trace_io_uring_register(ctx, opcode, ctx->nr_user_files, ctx->nr_user_bufs, ret);
  ...
}
```

- `__io_uring_register()`，一个巨大的 switch-case处理

```c
static int __io_uring_register(struct io_ring_ctx *ctx, unsigned opcode,
			       void __user *arg, unsigned nr_args)
	__releases(ctx->uring_lock)
	__acquires(ctx->uring_lock)
{
	int ret;

	/*
	 * We don't quiesce the refs for register anymore and so it can't be
	 * dying as we're holding a file ref here.
	 */
	if (WARN_ON_ONCE(percpu_ref_is_dying(&ctx->refs)))
		return -ENXIO;

	if (ctx->submitter_task && ctx->submitter_task != current)
		return -EEXIST;

	if (ctx->restricted) {
		opcode = array_index_nospec(opcode, IORING_REGISTER_LAST);
		if (!test_bit(opcode, ctx->restrictions.register_op))
			return -EACCES;
	}

	switch (opcode) {
	case IORING_REGISTER_BUFFERS:
		ret = -EFAULT;
		if (!arg)
			break;
		ret = io_sqe_buffers_register(ctx, arg, nr_args, NULL);
		break;
	case ...
  ...
}
```

#### 申请堆

**在 switch-case 语句中存在许多函数，我们寻找自己需要的**

1. case 
- IORING_REGISTER_FILES2( `ret = io_register_rsrc(ctx, arg, nr_args, IORING_RSRC_FILE);` )
- IORING_REGISTER_BUFFERS2 (`ret = io_register_rsrc_update(ctx, arg, nr_args,IORING_RSRC_BUFFER);`)
- arg 和 size 都由我们控制

```c
// ret = 

__cold int io_register_rsrc(struct io_ring_ctx *ctx, void __user *arg,
			    unsigned int size, unsigned int type)
{
	struct io_uring_rsrc_register rr;

	/* keep it extendible */
	if (size != sizeof(rr))
		return -EINVAL;

	memset(&rr, 0, sizeof(rr));
	if (copy_from_user(&rr, arg, size))
		return -EFAULT;
	if (!rr.nr || rr.resv2)
		return -EINVAL;
	if (rr.flags & ~IORING_RSRC_REGISTER_SPARSE)
		return -EINVAL;

	switch (type) {
	case IORING_RSRC_FILE:
		if (rr.flags & IORING_RSRC_REGISTER_SPARSE && rr.data)
			break;
		return io_sqe_files_register(ctx, u64_to_user_ptr(rr.data),
					     rr.nr, u64_to_user_ptr(rr.tags));
	case IORING_RSRC_BUFFER:
		if (rr.flags & IORING_RSRC_REGISTER_SPARSE && rr.data)
			break;
		return io_sqe_buffers_register(ctx, u64_to_user_ptr(rr.data),
					       rr.nr, u64_to_user_ptr(rr.tags));
	}
	return -EINVAL;
}
```

2. 调用  io_sqe_files_register() 与 io_sqe_buffers_register() 函数, 都调用 `io_rsrc_data_alloc()` 函数
- 分配一个 `io_rsrc_data` 结构体
- alloc 时， nr可控，由用户传入


```c
__cold static int io_rsrc_data_alloc(struct io_ring_ctx *ctx,
				     rsrc_put_fn *do_put, u64 __user *utags,
				     unsigned nr, struct io_rsrc_data **pdata)
{
	struct io_rsrc_data *data;
	int ret = -ENOMEM;
	unsigned i;

	data = kzalloc(sizeof(*data), GFP_KERNEL);
	if (!data)
		return -ENOMEM;
	data->tags = (u64 **)io_alloc_page_table(nr * sizeof(data->tags[0][0]));
	if (!data->tags) {
		kfree(data);
		return -ENOMEM;
	}

	data->nr = nr;
	data->ctx = ctx;
	data->do_put = do_put;
	if (utags) {
		ret = -EFAULT;
		for (i = 0; i < nr; i++) {
			u64 *tag_slot = io_get_tag_slot(data, i);

			if (copy_from_user(tag_slot, &utags[i],
					   sizeof(*tag_slot)))
				goto fail;
		}
	}

	atomic_set(&data->refs, 1);
	init_completion(&data->done);
	*pdata = data;
	return 0;
fail:
	io_rsrc_data_free(data);
	return ret;
}
```

3. 因此 io_alloc_page_table() 函数的 size由我们控制，可以申请任意大小的堆

```c
#define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))
#define min_t(type, x, y)	__careful_cmp((type)(x), (type)(y), <)
static inline void *kmalloc_array(size_t n, size_t size, gfp_t flags)
{
    if (size != 0 && n > SIZE_MAX / size)
        return NULL;
    return __kmalloc(n * size, flags);
}

static inline void *kcalloc(size_t n, size_t size, gfp_t flags)
{
    return kmalloc_array(n, size, flags | __GFP_ZERO);
}


static __cold void **io_alloc_page_table(size_t size)
{
	unsigned i, nr_tables = DIV_ROUND_UP(size, PAGE_SIZE);
	size_t init_size = size;
	void **table;

	table = kcalloc(nr_tables, sizeof(*table), GFP_KERNEL_ACCOUNT);     // 数量可以控制，kcalloc 可以控制大小
	if (!table)
		return NULL;

	for (i = 0; i < nr_tables; i++) {
		unsigned int this_size = min_t(size_t, size, PAGE_SIZE);

		table[i] = kzalloc(this_size, GFP_KERNEL_ACCOUNT);                // size可以控制
		if (!table[i]) {
			io_free_page_table(table, init_size);
			return NULL;
		}
		size -= this_size;
	}
	return table;
}
```

4. 拷贝数据 `data->tags` 为我们上一步的 `void **table` 
- tag_slot 为 table[i] 也就是 kzalloc 的堆
- 然后调用 copy_from_user

```c
static inline u64 *io_get_tag_slot(struct io_rsrc_data *data, unsigned int idx)
{
	unsigned int off = idx & IO_RSRC_TAG_TABLE_MASK;
	unsigned int table_idx = idx >> IO_RSRC_TAG_TABLE_SHIFT;

	return &data->tags[table_idx][off];
}
```

- 知道了 data 和 tag 就可以很快的理解下面的代码

#### update

1. case
- IORING_REGISTER_FILES_UPDATE
- IORING_REGISTER_FILES_UPDATE2
- IORING_REGISTER_BUFFERS_UPDATE
- 更新内核对象中的数据

```c
static int __io_sqe_files_update(struct io_ring_ctx *ctx,
				 struct io_uring_rsrc_update2 *up,
				 unsigned nr_args)
{
	//...

	for (done = 0; done < nr_args; done++) {
		u64 tag = 0;

		if ((tags && copy_from_user(&tag, &tags[done], sizeof(tag))) ||
		    copy_from_user(&fd, &fds[done], sizeof(fd))) {
			err = -EFAULT;
			break;
		}
		//...
  }
}
static int __io_sqe_buffers_update(struct io_ring_ctx *ctx,
				   struct io_uring_rsrc_update2 *up,
				   unsigned int nr_args)
{
	//...

	for (done = 0; done < nr_args; done++) {
		struct io_mapped_ubuf *imu;
		int offset = up->offset + done;
		u64 tag = 0;

		err = io_copy_iov(ctx, &iov, iovs, done);
		if (err)
			break;
		if (tags && copy_from_user(&tag, &tags[done], sizeof(tag))) {
			err = -EFAULT;
			break;
		}

	//...
  }
}
```

#### 删除

1. case
- IORING_UNREGISTER_BUFFERS
- IORING_UNREGISTER_FILES

```c
static void io_rsrc_data_free(struct io_rsrc_data *data)
{
	size_t size = data->nr * sizeof(data->tags[0][0]);

	if (data->tags)
		io_free_page_table((void **)data->tags, size);
	kfree(data);
}

static void io_free_page_table(void **table, size_t size)
{
	unsigned i, nr_tables = DIV_ROUND_UP(size, PAGE_SIZE);

	for (i = 0; i < nr_tables; i++)
		kfree(table[i]);
	kfree(table);
}
```

#### 利用

- 可以随意更新内容
- 我们可以使用 copy_from_user 函数，结合 ldt 就可以爆破程序基地址。
- 如果能修改 tag 的地址，就可以任意写

## 参考

- [io_uring](https://arthurchiao.art/blog/intro-to-io-uring-zh/)