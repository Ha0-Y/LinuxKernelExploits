## buddy-system

页级别的内存管理 $2^{order}$

alloc_pages
free_page

### 形式

- struct zone -> free_area\[MAX_ORDER\]，MAX_ORDER为11。并且内存是连续的。
![应该长这样](../images/buddy-system.png)

1. free_area
```c
struct free_area {
	struct list_head	free_list[MIGRATE_TYPES];
	unsigned long		nr_free;
};
```

- free_area
    - free_list 字段便是用以存放指向空闲页面的指针，其通过 page 结构体的 lru 字段将 page 结构体连接成双向链表
    - nr_free记录了在当前 free_area 中的空闲页面块的数量，对于 free_area[0] 以外的 free_area 而言其单位并非是单个页框，而是以_内存块_为单位

### 分配页

buddy system 提供了一组用以进行页面分配的接口

如果**此order较小的内存没有了，就会切割order较大的内存来填充**。

并且 buddy system 遵循 LIFO

#### GFP masks: get free page

1. 内存管理区修饰符
2. 移动和替换修饰符
3. watermark modifiers
4. 回收修饰符
5. 行为修饰符
6. 组合类型标志

具体的可以查看[此处文章](https://arttnba3.cn/2022/06/30/OS-0X03-LINUX-KERNEL-MEMORY-5.11-PART-II/#%E4%B8%80%E3%80%81GFP%EF%BC%88get-free-page%EF%BC%89%E6%A0%87%E5%BF%97%E4%BD%8D)

#### alloc context

- 结构体如下
```c
struct alloc_context {
	struct zonelist *zonelist;
	nodemask_t *nodemask;
	struct zoneref *preferred_zoneref;
	int migratetype;

	/*
	 * highest_zoneidx 表示分配请求中最高的可用 zone 的下标。
	 * 由于 zone 的性质, 相较于 highest_zoneidx，
	 * 在更低的 zone 上的内存会由 lowmem_reserve[highest_zoneidx] 保护。
	 * 译注：就是水位线机制，不记得的回去看上一篇文章
	 *
	 * highest_zoneidx 同样被回收/压缩使用以限制目标 zone，
	 * 因为高于该下标的 zone 无法用于此分配请求
	 */
	enum zone_type highest_zoneidx;
	bool spread_dirty_pages;
};
```
#### __alloc_pages_nodemask()

分配页面的「核心函数」，返回 page 结构体

#### 上层API

```c
__alloc_pages_node  /*返回struct page的指针*/
    __alloc_pages
    	__alloc_pages_nodemask

alloc_pages         /*返回struct page的指针*/
    alloc_pages_current
    	__alloc_pages_nodemask
        
__get_free_pages    /*返回页面的虚拟地址*/
    alloc_pages
        alloc_pages_current
            __alloc_pages_nodemask
```

### 回收页

将相邻的物理内存，如过可以合并就合并，合并一个较大的order，放入一个free_area中

#### __free_one_page()

释放页面的核心函数，所有释放页都会调用此函数

## slab 向buddy system 申请

不同的slab如果耗尽了会申请不同 order 的页，例如，kmalloc-256 会从 order-0 申请页，而 kmalloc-512 会从 order-1 申请页，kmalloc-4k 会从 order-3 申请页。

### split page

如果 `free_list` 中没有空闲页，则 lower-order free_area 从 higher-order free_area 取页，higher-order free_area 将页一分为二，然后 lower-order free_area 将页返回给申请者（例如 alloc_pages()）。例如，当 order-2（4-page）的 free_list 耗尽之后，就从 order-3 申请页，order-3 的页分成两个 4-page 页，位于低地址的 4-page 返回给申请者，高地址的 4-page 保存在 order-2 的free_list 中供下次申请

![split page](../images/split-page.gif)

```cpp
static __always_inline
struct page *__rmqueue_smallest(struct zone *zone, unsigned int order,
                        int migratetype)
{
    unsigned int current_order;
    struct free_area *area;
    struct page *page;


    for (current_order = order; current_order < MAX_ORDER; ++current_order) {
        // Pick up the right order from free_area
        area = &(zone->free_area[current_order]);
        // Get the page from the free_list
        page = get_page_from_free_area(area, migratetype);
        // If no freed page in free_list, goes to high order to retrieve
        if (!page)
            continue;
        del_page_from_free_list(page, zone, current_order);
        expand(zone, page, order, current_order, migratetype);
        set_pcppage_migratetype(page, migratetype);
        return page;
    }

    return NULL;
}

static inline struct page *get_page_from_free_area(struct free_area *area,
                        int migratetype)
{
    return list_first_entry_or_null(&area->free_list[migratetype],
                    struct page, lru);
}
```

### merge page

如果 `free_list` 中有很多空闲页，页分配器会整合两个相邻的、order相同的页，并放入 higher-order free_area。


