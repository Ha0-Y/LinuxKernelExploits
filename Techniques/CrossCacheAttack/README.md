## Cross Cache Attack

>针对 buddy system 的一种利用手段,比较稳定的一种技巧

- slub allocator 底层逻辑是向 buddy system 请求页面后再划分成特定大小 object 返还给上层调用者
- 内存中用作不同 kmem_cache 的页面在内存上是有可能相邻的
- 若我们的漏洞对象存在于页面 A，溢出目标对象存在于页面 B，且 A、B两页面相邻，则我们便有可能实现跨越不同 kmem_cache 之间的堆溢出

也就是物理页 A,B 相邻，分给了不同的 cache。在 cache-A 中 溢出 A 会导致B会被修改。

**不同的cache可以关联起来，导致几乎任意大小的堆分配**

### page-level heap fengshui

页级堆风水即以**内存页为粒度**的内存排布方式，而内核内存页的排布对我们来说不仅未知且信息量巨大，因此这种利用手法实际上是让我们手工构造一个新的已知的页级粒度内存页排布

1. 向 buddy system 请求两份连续的内存页
2. 释放其中一份内存页，在 vulnerable kmem_cache 上堆喷，让其申请走这份内存页
3. 释放另一份内存页，在 victim kmem_cache 上堆喷，让其申请这份内存页

### 申请连续内存页

#### socket ring buffer

0. 消耗完byddy system 所有 **order比较小** 的页，方便再次申请时切割，得到连续的内存
1. 当我们创建一个 protocol 为 `PF_PACKET` 的 socket 之后，先调用 `setsockopt()` 将 PACKET_VERSION 设为 TPACKET_V1 / TPACKET_V2，再调用 setsockopt() 提交一个 PACKET_TX_RING ，存在如下调用链

```cpp
__sys_setsockopt()
    sock->ops->setsockopt()
    	packet_setsockopt() // case PACKET_TX_RING ↓
    		packet_set_ring()
    			alloc_pg_vec()
```

2. alloc_pg_vec
- pg_vec kcalloc block_nr 个结构体
- order 由 tp_block_size 决定

```cpp
static struct pgv *alloc_pg_vec(struct tpacket_req *req, int order)
{
	unsigned int block_nr = req->tp_block_nr;
	struct pgv *pg_vec;
	int i;

	pg_vec = kcalloc(block_nr, sizeof(struct pgv), GFP_KERNEL | __GFP_NOWARN);
	if (unlikely(!pg_vec))
		goto out;

	for (i = 0; i < block_nr; i++) {
		pg_vec[i].buffer = alloc_one_pg_vec_page(order);
		if (unlikely(!pg_vec[i].buffer))
			goto out_free_pgvec;
	}

out:
	return pg_vec;

out_free_pgvec:
	free_pg_vec(pg_vec, order, block_nr);
	pg_vec = NULL;
	goto out;
}
```

3. 在 alloc_one_pg_vec_page() 中会直接调用 __get_free_pages() 向 buddy system 请求内存页，因此我们可以利用该函数进行大量的页面请求

```cpp
static char *alloc_one_pg_vec_page(unsigned long order)
{
	char *buffer;
	gfp_t gfp_flags = GFP_KERNEL | __GFP_COMP |
			  __GFP_ZERO | __GFP_NOWARN | __GFP_NORETRY;

	buffer = (char *) __get_free_pages(gfp_flags, order);
	if (buffer)
		return buffer;
	//...
}
```

4. pgv 会在 socket 结束后free

```cpp
packet_release()
    packet_set_ring()
    	free_pg_vec()
```

pgv 中的页面会在 socket 被关闭后释放，这也方便我们后续的页级堆风水，不过需要注意的是低权限用户无法使用该函数，但是我们可以通过开辟新的命名空间来绕过该限制

#### io_uring

同理，我们按照 `__get_free_pages` 函数继续找，可以找到另一个调用链

```cpp
void *io_mem_alloc(size_t size)
{
	gfp_t gfp = GFP_KERNEL_ACCOUNT | __GFP_ZERO | __GFP_NOWARN | __GFP_COMP;
	void *ret;

	ret = (void *) __get_free_pages(gfp, get_order(size));
	if (ret)
		return ret;
	return ERR_PTR(-ENOMEM);
}
```

顺着找: io_uring order 分配

```cpp
io_uring_setup : p from user.
	io_uring_create : p => io_uring_param __user *p
		io_allocate_scq_urings: size => io_uring_param *p
```

free: 可以看到返回值为 rings 

```cpp
static void io_rings_free(struct io_ring_ctx *ctx)
{
	if (!(ctx->flags & IORING_SETUP_NO_MMAP)) {
		io_mem_free(ctx->rings);
		io_mem_free(ctx->sq_sqes);
		ctx->rings = NULL;
		ctx->sq_sqes = NULL;
	} else {
		io_pages_free(&ctx->ring_pages, ctx->n_ring_pages);
		ctx->n_ring_pages = 0;
		io_pages_free(&ctx->sqe_pages, ctx->n_sqe_pages);
		ctx->n_sqe_pages = 0;
	}
}
```

最后找到了 release，但是如何利用?

```cpp
io_uring_release
	io_ring_ctx_wait_and_kill
		io_ring_exit_work
			io_ring_ctx_free
				io_rings_free
```

## Exploit

### UAF example

- 主要参考[这一篇文章](https://veritas501.github.io/2023_03_07-Cross%20Cache%20Attack%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82%E5%88%86%E6%9E%90/)，方便我们理解这个漏洞利用方式。

1. 查看基本信息
```bash
$ sudo cat /sys/kernel/slab/filp/object_size 			# 每个filp object的大小
256
$ sudo cat /sys/kernel/slab/filp/slab_size        # 使用多大的slab
256
$ sudo cat /sys/kernel/slab/filp/objs_per_slab 		# 每个 slab 申请 object 最大值
32
$ sudo cat /sys/kernel/slab/filp/cpu_partial 			# cpu partial list 链表的节点个数
52
```

2. 堆喷射，清空目标cache在kernel中的内存碎片。
3. 申请(cpu_partial + 1) * objs_per_slab 个object
- 在极少数情况下，这些object会正好放在 53 个slab中；由于多数情况下在申请object前，多多少少会有几个object已经占用了一个slab，因此我们的object会分布于54个slab中，且第54个slab非满。
- 目前只考虑多数情况
4. 申请 objs_per_slab - 1 = 31 个object，从而使54个slab满
5. 申请一个漏洞object(vuln)，后续用来UAF, 这个vuln object在 55 个 slab 中
6. 申请 objs_per_slab + 1 = 33 个object，确保 vuln slab 满，并创造第56个slab
7. 触发漏洞object的UAF,也就是free掉 vuln object
- 由于漏洞object所在的slab是满的，因此会触发 put_cpu_partial()，但由于 cpu partial list 非满，所以现在还不会进入unfreeze_partials()。
8. 我们将 vuln 前后各 objs_per_slab 个object释放，从而让第 55 slab进入全空状态, 54, 57 全部partial
因为虽然内核可能开了freelist harden和freelist random保护，但从page的角度来说，依然是顺序的。因此前后各objs_per_slab = 16个object释放就能让第16个slab进入全空状态。（当然这也会导致第15和第17个slab进入半空状态，不过这不影响）
> 在第55个slab第一次从全满进入半满时，就会触发put_cpu_partial()将其放入 cpu partial list中。之后直到全空都不会再进入put_cpu_partial()。
9. 将1-53个slab中各释放一个object，将其从全满状态进入半满状态
这将对每个page触发一次put_cpu_partial()。由于53 = cpu_partial + 1，因此这必将导致最后几次在进入put_cpu_partial()时发现cpu partial list满了，从而进入unfreeze_partials()逻辑。然后发现第16个slab已经进入了全空状态，从而调用discard_slab()将这个page进行释放。
10. 这样在新获得的page中，存在 uaf, 可以供我们使用。

简化一下
- heap spray 清空slab 中的碎片，这样就可以向 buddy system 申请
- buddy system 申请 page, 其中一个 object: vuln heap
- 填满 page, 然后在 spray 一下
- free vuln heap
- free vuln 前后使 page 进入 buddy system
- spray victim 获得 vuln page, 通过 vuln 修改victim

### heap overflow

>结合上面的 页级堆风水进行利用

- pipe_bufver 结构体的开头就存在 page 指针，我们可以尝试修改其page指针，让两个pipe的page指向相同位置,就像 CVE-2021-22555 那种利用方式一样，同时pipe也能任意读写，美滋滋😋

## 参考链接

- [N1CTF Praymoon](https://blog.imv1.me/2022/11/10/N1CTF-2022-Praymoon-Write-Up/)
- [Linux kernel 6.2 source](https://elixir.bootlin.com/linux/v6.2.16/source)
- [d3ctf](https://arttnba3.cn/2023/05/02/CTF-0X08_D3CTF2023_D3KCACHE/)
- [cross cache overflow](https://paper.seebug.org/1889/)