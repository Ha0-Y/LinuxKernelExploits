## seq_operations

打开一次 `/proc/self/stat` 文件就会创建一次，大小 `0x20`
- 调用single_open()函数，而该函数中会为struct seq_operations 结构体申请一段内存空间

open()操作后，用户态获得一个文件描述符fd。
- 当用户态对该fd进行读操作read(fd,buf,size)时，在内核中会调用seq_operations->start函数指针。
- 如果利用漏洞改掉结构体中的start函数指针，就能实现控制流劫持。
- 还可以泄露内核基址

`/fs/seq_file.c` trace其默认实现
```cpp
int single_open(struct file *file, int (*show)(struct seq_file *, void *),
		void *data)
{
	struct seq_operations *op = kmalloc(sizeof(*op), GFP_KERNEL_ACCOUNT);
	int res = -ENOMEM;

	if (op) {
		op->start = single_start;
		op->next = single_next;
		op->stop = single_stop;
		op->show = show;
		res = seq_open(file, op);
		if (!res)
			((struct seq_file *)file->private_data)->private = data;
		else
			kfree(op);
	}
	return res;
}
EXPORT_SYMBOL(single_open);
```

seq_file 存在一个专用slab。ops使用kmalloc，因此可以忽略`struct seq_file`影响
```cpp
void __init seq_file_init(void)
{
	seq_file_cache = KMEM_CACHE(seq_file, SLAB_ACCOUNT|SLAB_PANIC);
}
```