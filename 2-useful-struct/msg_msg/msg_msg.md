## msg_msg

### System V 消息队列

msg_queue 结构体

```c
struct msg_queue {
	struct kern_ipc_perm q_perm;
	time64_t q_stime;		/* last msgsnd time */
	time64_t q_rtime;		/* last msgrcv time */
	time64_t q_ctime;		/* last change time */
	unsigned long q_cbytes;		/* current number of bytes on queue */
	unsigned long q_qnum;		/* number of messages in queue */
	unsigned long q_qbytes;		/* max number of bytes on queue */
	struct pid *q_lspid;		/* pid of last msgsnd */
	struct pid *q_lrpid;		/* last receive pid */

	struct list_head q_messages;
	struct list_head q_receivers;
	struct list_head q_senders;
} __randomize_layout;
```

当往一个消息队列发送消息时，会形成如下的结构

![msg_queue](./imgs/msg_queue.png)

#### 消息

msg_msg 结构体

```c
struct msg_msg {
	struct list_head m_list;
	long m_type;
	size_t m_ts;		/* message text size */
	struct msg_msgseg *next;
	void *security;
};
```

当**一条消息**长度超过一页时，会使用 msg_msgseg 指向剩余的消息

```c
struct msg_msgseg {
	struct msg_msgseg *next;
};
```

![msg_msg](./imgs/msg_msg.png)


#### 用户态 API

在用户态可以使用这些函数操作 msg_msg 
- 也可以直接使用 syscall 😤

```cpp
#include <sys/msg.h>

// 消息实体
struct mymsg {
	long    mtype;     /* Message type. */
	char    mtext[MSG_SZ];  /* Message text. */
}

// 创建和获取ipc内核对象，返回值就是 msqid
int msgget(key_t key, int flags);
 
// msgsnd 和 msgrcv 函数 sz = MSG_SZ 并且 msgp 为 &struct mymsg

// 将消息发送到消息队列
int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
 
// 从消息队列获取消息
ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);
 
// 查看、设置、删除ipc内核对象(用法和shmctl一样)
int msgctl(int msqid, int cmd, struct msqid_ds *buf);
```

内核函数调用关系 类似如下

```cpp
long ksys_msgsnd(int msqid, struct msgbuf __user *msgp, size_t msgsz,
		 int msgflg)
{
	long mtype;

	if (get_user(mtype, &msgp->mtype))
		return -EFAULT;
	return do_msgsnd(msqid, mtype, msgp->mtext, msgsz, msgflg);
}

SYSCALL_DEFINE4(msgsnd, int, msqid, struct msgbuf __user *, msgp, size_t, msgsz,
		int, msgflg)
{
	return ksys_msgsnd(msqid, msgp, msgsz, msgflg);
}
```

## 利用思路

1. 修改 m_ts: msg text size，我们改大，就可以读取 next 指针的结构体内容。几乎是任意地址读取（创建一个消息大小 = 0x1000-0x30+我们想要的size，使用到 msg_msgseg。只要我们改变 m_ts，就可以越界读）
2. 修改 m_list.next: 参考 CVE-2021-22555 主从消息 两个主消息指向同一个从消息，从而造成类似 UAF 问题
3. msg_msgseg->next，任意地址写，可能需要借助条件竞争。

msgsnd: 在内核中调用 do_msgsnd 然后调用 load_msg
- alloc 一个 message, 长度大于 PAGE_SIZE 会创建一个 msg_msgseg
- 我们修改 next 指针，造成任意地址写

```c
struct msg_msg *load_msg(const void __user *src, size_t len)
{
	struct msg_msg *msg;
	struct msg_msgseg *seg;
	int err = -EFAULT;
	size_t alen;

	msg = alloc_msg(len);
	if (msg == NULL)
		return ERR_PTR(-ENOMEM);

	alen = min(len, DATALEN_MSG);
	if (copy_from_user(msg + 1, src, alen))
		goto out_err;

	for (seg = msg->next; seg != NULL; seg = seg->next) {
		len -= alen;
		src = (char __user *)src + alen;
		alen = min(len, DATALEN_SEG);
		if (copy_from_user(seg + 1, src, alen))
			goto out_err;
	}

	err = security_msg_msg_alloc(msg);
	if (err)
		goto out_err;

	return msg;

out_err:
	free_msg(msg);
	return ERR_PTR(err);
}
```

接收消息
- 是否将消息free掉，取决于一个flag `MSG_COPY`, 如果存在这个 flag 就要 alloc 一块缓冲区
- msgflag 不包括 MSG_COPY 就会 free 掉 msg, 包含就会 free 掉 alloc 的缓冲区
- 调用 find_msg 寻找对应的 msg

```c
static long do_msgrcv(int msqid, void __user *buf, size_t bufsz, long msgtyp, int msgflg, long (*msg_handler)(void __user *, struct msg_msg *, size_t))
{
	··· ···
	if (msgflg & MSG_COPY) {
		if ((msgflg & MSG_EXCEPT) || !(msgflg & IPC_NOWAIT))
			return -EINVAL;
		copy = prepare_copy(buf, min_t(size_t, bufsz, ns->msg_ctlmax));
		if (IS_ERR(copy)) 				//搜索要发送的消息之前，准备一个消息备份(申请内存)，用来存放消息
			return PTR_ERR(copy);
	}
	··· ···
	for (;;) {
		··· ···
		msg = find_msg(msq, &msgtyp, mode);
		if (!IS_ERR(msg)) {
			··· ···
			if (msgflg & MSG_COPY) {
				msg = copy_msg(msg, copy); //找到之后拷贝到消息备份中
				goto out_unlock0;
			}
			··· ···
		}        
        ··· ···
	}
  //  ··· ···
	bufsz = msg_handler(buf, msg, bufsz);
	free_msg(msg); //释放消息备份

	return bufsz;
}
```

通过find_msg 寻找到对应的 message
- msg_type 在使用 MSG_COPY 时, mode=SEARCH_NUMBER 就是**遍历消息队列，按照顺序进行找消息**

```cpp
static inline int convert_mode(long *msgtyp, int msgflg)
{
	if (msgflg & MSG_COPY)
		return SEARCH_NUMBER;
	// ...
}

static struct msg_msg *find_msg(struct msg_queue *msq, long *msgtyp, int mode)
{
	struct msg_msg *msg, *found = NULL;
	long count = 0;

	list_for_each_entry(msg, &msq->q_messages, m_list) {
		if (testmsg(msg, *msgtyp, mode) &&
		    !security_msg_queue_msgrcv(&msq->q_perm, msg, current,
					       *msgtyp, mode)) {
			if (mode == SEARCH_LESSEQUAL && msg->m_type != 1) {
				*msgtyp = msg->m_type - 1;
				found = msg;
			} else if (mode == SEARCH_NUMBER) {
				if (*msgtyp == count)
					return msg;
			} else
				return msg;
			count++;
		}
	}

	return found ?: ERR_PTR(-EAGAIN);
}
```

## 缓解机制

禁用 msg_msg 结构体, 实现起来具体为禁用相关的 syscall , 让用户不能调用相关函数。
- Linux ptrace + epbf 技术修改掉对应的syscall
- Docker 定义 seccomp 沙箱

## 参考

[corCTF 2021: Wall Of Perdition](https://syst3mfailure.io/wall-of-perdition/)
[corCTF 2022: CoRJail](https://syst3mfailure.io/corjail/)