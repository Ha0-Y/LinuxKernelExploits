## msg_msg

### System V 消息队列

msg_queue 结构体

```c
struct msg_queue {
	struct kern_ipc_perm q_perm;
	time64_t q_stime;		/* last msgsnd time */
	time64_t q_rtime;		/* last msgrcv time */
	time64_t q_ctime;		/* last change time */
	unsigned long q_cbytes;		/* current number of bytes on queue */
	unsigned long q_qnum;		/* number of messages in queue */
	unsigned long q_qbytes;		/* max number of bytes on queue */
	struct pid *q_lspid;		/* pid of last msgsnd */
	struct pid *q_lrpid;		/* last receive pid */

	struct list_head q_messages;
	struct list_head q_receivers;
	struct list_head q_senders;
} __randomize_layout;
```

当往一个消息队列发送消息时，会形成如下的结构

![msg_queue](./imgs/msg_queue.png)

#### 消息

msg_msg 结构体

```c
struct msg_msg {
	struct list_head m_list;
	long m_type;
	size_t m_ts;		/* message text size */
	struct msg_msgseg *next;
	void *security;
};
```

当**一条消息**长度超过一页时，会使用 msg_msgseg 指向剩余的消息

```c
struct msg_msgseg {
	struct msg_msgseg *next;
};
```

![msg_msg](./imgs/msg_msg.png)


#### 接口

在用户态可以使用这些函数操作 msg_msg

```c
// 创建和获取ipc内核对象，返回值就是 msqid
int msgget(key_t key, int flags);
 
// 将消息发送到消息队列
int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
 
// 从消息队列获取消息
ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);
 
// 查看、设置、删除ipc内核对象(用法和shmctl一样)
int msgctl(int msqid, int cmd, struct msqid_ds *buf);
```

## 利用手法

1. 修改 size_t m_ts: text size，我们改大，就可以读取 next 指针的结构体内容。几乎是任意地址读取（创建一个消息大小 = 0x1000-0x30+我们想要的size，从而使用到msg_msgseg。只要我们改变 m_ts，就可以越界读）
2. 修改 m_list.prev & next: 参考CVE-2021-22555
3. msg_msgseg->next，任意地址写，可能需要借助条件竞争。

- load_msg: 修改next指针，造成任意地址写

```c
struct msg_msg *load_msg(const void __user *src, size_t len)
{
	struct msg_msg *msg;
	struct msg_msgseg *seg;
	int err = -EFAULT;
	size_t alen;

	msg = alloc_msg(len); 						         //根据消息长度生成上图那种结构体
	if (msg == NULL)
		return ERR_PTR(-ENOMEM);

	alen = min(len, DATALEN_MSG);                         //根据分段情况从用户空间分段拷贝，这里拷贝第一段
	if (copy_from_user(msg + 1, src, alen))
		goto out_err;

	for (seg = msg->next; seg != NULL; seg = seg->next) {   //按顺序拷贝剩下的部分
		len -= alen;
		src = (char __user *)src + alen;
		alen = min(len, DATALEN_SEG);
		if (copy_from_user(seg + 1, src, alen))
			goto out_err;
	}
    ··· ···
    ··· ···
}
```

- 是否将消息free掉，取决于一个flag `MSG_COPY`

```c
static long do_msgrcv(int msqid, void __user *buf, size_t bufsz, long msgtyp, int msgflg, long (*msg_handler)(void __user *, struct msg_msg *, size_t))
{
	··· ···
	if (msgflg & MSG_COPY) {
		if ((msgflg & MSG_EXCEPT) || !(msgflg & IPC_NOWAIT))
			return -EINVAL;
		copy = prepare_copy(buf, min_t(size_t, bufsz, ns->msg_ctlmax));
		if (IS_ERR(copy)) //搜索要发送的消息之前，准备一个消息备份(申请内存)，用来存放消息
			return PTR_ERR(copy);
	}
	··· ···
	for (;;) {
		··· ···
		msg = find_msg(msq, &msgtyp, mode);
		if (!IS_ERR(msg)) {
			··· ···
			if (msgflg & MSG_COPY) {
				msg = copy_msg(msg, copy); //找到之后拷贝到消息备份中
				goto out_unlock0;
			}
			··· ···
		}        
        ··· ···
	}
    ··· ···
	bufsz = msg_handler(buf, msg, bufsz); //将消息备份发送到用户
	free_msg(msg); //释放消息备份

	return bufsz;
}
```

## 缓解基址

- 禁用 msg_msg 结构体