## userfaultfd

> 用户态处理缺页异常的函数。

userfaultfd，这是 kernel 中提供的一种特殊的处理 page fault 的机制，能够让用户态程序自行处理自己的 page fault.

userfaultfd机制允许多线程程序中的某个线程为其他线程提供用户空间页面——如果该线程将这些页面注册到了userfaultfd对象上，那么当针对这些页面的缺页异常发生时，触发缺页异常的线程将**暂停运行**，内核将生成一个缺页异常事件并通过userfaultfd文件描述符传递给异常处理线程。异常处理线程可以做一些处理，然后唤醒之前暂停的线程。

### 页调度与延迟加载

有的内存既不在RAM也不在交换区，例如mmap创建的内存映射页。mmap页在read/write访问之前，实际上还没有创建（还没有映射到实际的物理页），例如：`mmap(0x1337000, 0x1000, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_PRIVATE, fd, 0);` 内核并未将fd内容拷贝到0x1337000，只是将地址0x1337000映射到文件fd。

### 使用

注册一个 userfaultfd，通过 ioctl 监视一块内存区域，同时还需要专门启动一个用以进行轮询的线程 uffd monitor，该线程会通过 poll() 函数不断轮询直到出现缺页异常

1. 当有一个线程在这块内存区域内触发缺页异常时（比如说第一次访问一个匿名页），该线程（称之为 faulting 线程）进入到内核中处理缺页异常
2. 内核会调用 handle_userfault() 交由 userfaultfd 处理
3. faulting 线程进入堵塞状态，同时将一个 uffd_msg 发送给 monitor 线程，等待其处理结束
4. monitor 线程调用通过 ioctl 处理缺页异常，有如下选项：
`UFFDIO_COPY`：将用户自定义数据拷贝到 faulting page 上
`UFFDIO_ZEROPAGE` ：将 faulting page 置 0
`UFFDIO_WAKE`：用于配合上面两项中 UFFDIO_COPY_MODE_DONTWAKE 和 UFFDIO_ZEROPAGE_MODE_DONTWAKE 模式实现批量填充
在处理结束后 monitor 线程发送信号唤醒 faulting 线程继续工作

该机制最初被设计来用以进行虚拟机 / 进程的迁移等用途，但是通过这个机制**我们可以控制进程执行流程的先后顺序，从而使得对条件竞争的利用成功率大幅提高。**

> 如果在进入函数后（copy_from_user() && copy_to_user()），实际拷贝开始前线程被中断换下 CPU，别的线程执行，修改了 ptr 指向的内存块的所有权（比如 kfree 掉了这个内存块），然后再执行拷贝时就可以实现 UAF。这种可能性当然是比较小的，但是如果 **user_buf 是一个 mmap 的内存块，并且我们为它注册了 userfaultfd**，那么在拷贝时出现缺页异常后此线程会先执行我们注册的处理函数，在处理函数结束前线程一直被暂停，结束后才会执行后面的操作，大大增加了竞争的成功率

### setattr

- 既然学习了 userfaultfd，就不得不说 userfault + setattr 的堆占位技术了。

通过 setxattr 系统调用可以在内核空间中**分配任意大小的 object 并写入任意内容**，但是该 object 在 setxattr 执行结束时又会被放回 freelist 中，那我们将前功尽弃。所以我们就类似，让进程在free前暂停。

setxattr 的执行流会调用 copy_from_user 从用户空间拷贝数据，那么我们：
mmap 分配连续的两个页面，在第二个页面上启用 userfaultfd 监视，并在第一个页面的末尾写入我们想要的数据，此时我们调用 setxattr 进行跨页面的拷贝，当 copy_from_user 拷贝到第二个页面时便会触发 userfaultfd，从而让 setxattr 的执行流程卡在此处，这样这个 object 就不会被释放掉，而是可以继续参与我们接下来的利用

```c
static long
setxattr(struct dentry *d, const char __user *name, const void __user *value,
     size_t size, int flags)
{
    //...
        kvalue = kvmalloc(size, GFP_KERNEL);
        if (!kvalue)
            return -ENOMEM;
        if (copy_from_user(kvalue, value, size)) {

    //,..

    kvfree(kvalue);

    return error;
}
```

![流程](./imgs/setattr.png)



##  参考文章

- [CTF wiki](https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/race/userfaultfd/)
- [userfaultfd 探究](http://brieflyx.me/2020/linux-tools/userfaultfd-internals/)
- [userfaultfd QWB2021](https://cv196082.gitee.io/2022/08/16/userfaultfd/)
- [setattr 堆占位](https://cv196082.gitee.io/2022/09/06/kernel%E5%A0%86%E5%8D%A0%E4%BD%8D/)