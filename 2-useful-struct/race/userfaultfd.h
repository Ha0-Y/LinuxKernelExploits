#include <linux/userfaultfd.h>

void die(char *msg);

// struct uffdio_api {
// 	__u64 api;
// #define UFFD_FEATURE_PAGEFAULT_FLAG_WP		(1<<0)
// #define UFFD_FEATURE_EVENT_FORK			(1<<1)
// #define UFFD_FEATURE_EVENT_REMAP		(1<<2)
// #define UFFD_FEATURE_EVENT_REMOVE		(1<<3)
// #define UFFD_FEATURE_MISSING_HUGETLBFS		(1<<4)
// #define UFFD_FEATURE_MISSING_SHMEM		(1<<5)
// #define UFFD_FEATURE_EVENT_UNMAP		(1<<6)
// #define UFFD_FEATURE_SIGBUS			(1<<7)
// #define UFFD_FEATURE_THREAD_ID			(1<<8)
// #define UFFD_FEATURE_MINOR_HUGETLBFS		(1<<9)
// #define UFFD_FEATURE_MINOR_SHMEM		(1<<10)
// 	__u64 features;
// 	__u64 ioctls;
// };

// 注册时要用一个struct uffdio_register结构传递注册信息:
// struct uffdio_range {
// __u64 start;    /* Start of range */
// __u64 len;      /* Length of range (bytes) */
// };
//
// struct uffdio_register {
// struct uffdio_range range;
// __u64 mode;     /* Desired mode of operation (input) */
// __u64 ioctls;   /* Available ioctl() operations (output) */
// };

// 专用的线程轮询和处理 "user-fault" 事件
static pthread_t monitor_thread;

/**
 * 从addr开始，监视len
 */
void register_userfaultfd(void *addr, unsigned long len,
                          void (*handler)(void *)) {
  long uffd;
  struct uffdio_api uffdio_api;
  struct uffdio_register uffdio_register;
  int s;

  /* Create and enable userfaultfd object */
  uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
  if (uffd == -1) die("userfaultfd");

  uffdio_api.api = UFFD_API;
  uffdio_api.features = 0;
  if (ioctl(uffd, UFFDIO_API, &uffdio_api) == -1) die("ioctl-UFFDIO_API");

  uffdio_register.range.start = (unsigned long)addr;
  uffdio_register.range.len = len;
  uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;
  if (ioctl(uffd, UFFDIO_REGISTER, &uffdio_register) == -1)
    die("ioctl-UFFDIO_REGISTER");

  // 开启 monitor_thread 线程
  s = pthread_create(&monitor_thread, NULL, handler, (void *)uffd);
  if (s != 0) die("pthread_create");
}

static char *page = NULL;  // 你要拷贝进去的数据
static long page_size;

// 死循环 轮询 page_fault
static void *fault_handler_thread(void *arg) {
  static struct uffd_msg msg;
  static int fault_cnt = 0;
  long uffd;

  struct uffdio_copy uffdio_copy;
  ssize_t nread;

  uffd = (long)arg;

  for (;;) {
    struct pollfd pollfd;
    int nready;
    pollfd.fd = uffd;
    pollfd.events = POLLIN;
    nready = poll(&pollfd, 1, -1);

    /*
     * 当 poll 返回时说明出现了缺页异常
     * 你可以在这里插入一些自定义的代码，比如说获取锁或者 sleep() 一类的操作
     * 让他在你想要的地方停顿，之后你再手动唤醒（或者就这样卡住）
     */

    if (nready == -1) die("poll");

    nread = read(uffd, &msg, sizeof(msg));
    if (nread == 0) die("EOF on userfaultfd!\n");
    if (nread == -1) die("read");

    // 缺页异常
    if (msg.event != UFFD_EVENT_PAGEFAULT)
      die("Unexpected event on userfaultfd\n");

    uffdio_copy.src = (unsigned long)page;
    // 将触发缺页异常的地址按页对齐作为后续拷贝的起始地址
    uffdio_copy.dst =
        (unsigned long)msg.arg.pagefault.address & ~(page_size - 1);
    uffdio_copy.len = page_size;
    uffdio_copy.mode = 0;
    uffdio_copy.copy = 0;
    // 将内容拷贝到 page fault 的 page 里面
    if (ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1) die("ioctl-UFFDIO_COPY");
  }
}

void userfaultfd_example() {
  // 页调度和延迟加载
  // mmap页在read/write访问之前，实际上还没有创建（还没有映射到实际的物理页）
  char *mmap_addr = (char *)mmap(NULL, 0x2000, PROT_READ | PROT_WRITE,
                                 MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  // handler 函数参数
  page = malloc(0x1000);
  strcpy(page, "userfaultfd pwn");
  page_size = sysconf(_SC_PAGE_SIZE);

  register_userfaultfd(mmap_addr+0x1000, 0x1000, fault_handler_thread);

  mmap_addr[0x1001] = 1;  // 缺页异常
}