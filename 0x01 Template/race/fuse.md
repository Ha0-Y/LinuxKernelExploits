## fuse

> Linux FUSE(Filesystem in Userspace)是一个Linux内核模块，允许用户空间程序通过系统调用接口来实现文件系统。FUSE允许开发人员在用户空间而不是内核空间中编写文件系统，这样就可以更轻松地开发、测试和调试文件系统，而无需修改内核代码。

Linux 5.15之后，userfaultfd机制存在两个限制：

1. 默认情况下，非特权用户不能使用该机制。
2. 即使非特权用户能够使用该机制，在没有特权的情况下，内核空间的缺页异常也无法被捕获。


fuse 允许其在用户态编程，在内核态使用 `copy_from_user()` 函数，触发缺页异常，调用 `fuse_ops->read`，而这个回调函数我们可以在用户态自定义。 

- fuse系统命令

```bash
$ man fuser
$ man fusermount
$ man fusermount3
```

### 编程

[libfuse](https://github.com/libfuse/libfuse) 实现了Linux FUSE的用户空间API，方便程序开发。

```base
sudo apt install fuse libfuse3 libfuse-dev
```

**FUSE编程 => 实现对应的文件操作方法**

```c
struct fuse_operations {
	int (*getattr) (const char *, struct stat *);
	int (*readlink) (const char *, char *, size_t);
	int (*getdir) (const char *, fuse_dirh_t, fuse_dirfil_t);
	int (*mknod) (const char *, mode_t, dev_t);
	int (*mkdir) (const char *, mode_t);
	int (*unlink) (const char *);
	int (*rmdir) (const char *);
	int (*symlink) (const char *, const char *);
	int (*rename) (const char *, const char *);
	int (*link) (const char *, const char *);
	int (*chmod) (const char *, mode_t);
	int (*chown) (const char *, uid_t, gid_t);
	int (*truncate) (const char *, off_t);
	int (*utime) (const char *, struct utimbuf *);
	int (*open) (const char *, struct fuse_file_info *);
	int (*read) (const char *, char *, size_t, off_t,
		     struct fuse_file_info *);
	int (*write) (const char *, const char *, size_t, off_t,
		      struct fuse_file_info *);
	int (*statfs) (const char *, struct statvfs *);
	int (*flush) (const char *, struct fuse_file_info *);
	int (*release) (const char *, struct fuse_file_info *);
	int (*fsync) (const char *, int, struct fuse_file_info *);
	int (*setxattr) (const char *, const char *, const char *, size_t, int);
	int (*getxattr) (const char *, const char *, char *, size_t);
	int (*listxattr) (const char *, char *, size_t);
	int (*removexattr) (const char *, const char *);
	int (*opendir) (const char *, struct fuse_file_info *);
	int (*readdir) (const char *, void *, fuse_fill_dir_t, off_t,
			struct fuse_file_info *);
	int (*releasedir) (const char *, struct fuse_file_info *);
	int (*fsyncdir) (const char *, int, struct fuse_file_info *);
	void *(*init) (struct fuse_conn_info *conn);
	void (*destroy) (void *);
	int (*access) (const char *, int);
	int (*create) (const char *, mode_t, struct fuse_file_info *);
	int (*ftruncate) (const char *, off_t, struct fuse_file_info *);
	int (*fgetattr) (const char *, struct stat *, struct fuse_file_info *);
	int (*lock) (const char *, struct fuse_file_info *, int cmd,
		     struct flock *);
	int (*utimens) (const char *, const struct timespec tv[2]);
	int (*bmap) (const char *, size_t blocksize, uint64_t *idx);
	int (*ioctl) (const char *, int cmd, void *arg,
		      struct fuse_file_info *, unsigned int flags, void *data);
	int (*poll) (const char *, struct fuse_file_info *,
		     struct fuse_pollhandle *ph, unsigned *reventsp);
	int (*write_buf) (const char *, struct fuse_bufvec *buf, off_t off,
			  struct fuse_file_info *);
	int (*read_buf) (const char *, struct fuse_bufvec **bufp,
			 size_t size, off_t off, struct fuse_file_info *);
	int (*flock) (const char *, struct fuse_file_info *, int op);
	int (*fallocate) (const char *, int, off_t, off_t,
			  struct fuse_file_info *);
};
```

- [example from github](https://github.com/LukeGix/FUSEFs_exploitation/blob/main/fusefs.c)

```c
// FUSE: Filesystem in USErspace
// fusefs.c - FUSE filesystem handler
// Made by @LukeGix 

#define FUSE_USE_VERSION 26

#include <fuse.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <err.h>
#include <sys/uio.h>
#include <assert.h>
#include <stdlib.h>

#define FILE_TARGET "/lol"

unsigned int file_size = 0;

char file_buffer[4096];
int len = 10;
static int FUSE_getattr(const char *path, struct stat *stbuf){
    int res = 0;
    memset(stbuf, 0, sizeof(struct stat));
    if (strcmp(path, "/") == 0) {
        stbuf->st_mode = S_IFDIR | 0755;
        stbuf->st_nlink = 2;
    } else if (strcmp(path, FILE_TARGET) == 0) {
        stbuf->st_mode = S_IFREG | 0666;
        stbuf->st_nlink = 1;
        stbuf->st_size = file_size;
        stbuf->st_blocks = 0;
    }
    else {
        res = -ENOENT;
    }
    return res;
}

// It defines the result of, for example, `ls`
static int FUSE_readdir(const char *path, void *buf, fuse_fill_dir_t filler, off_t offset, struct fuse_file_info *fi) {
    filler(buf, ".", NULL, 0);
    filler(buf, "..", NULL, 0);
    filler(buf, "lol", NULL, 0);
    return 0;
}

static int FUSE_open(const char *path, struct fuse_file_info *fi) {
    return 0;
}

static int FUSE_read(const char *path, char *buf, size_t size, off_t offset, struct fuse_file_info *fi){
    if(strcmp(path, FILE_TARGET) == 0){
        for(;;){
            printf("[+] Pausing kernel thread...\n");
	    sleep(200);
        }
	memcpy(buf, file_buffer, size);
    }

    return size;
}


static int FUSE_write(const char *path, const char *buf_to_write, size_t size, off_t offset, struct fuse_file_info *fi ){
	if(strcmp(path, FILE_TARGET) == 0){
		assert(offset <= 4096 && (file_size + size) <= 4096);
		//Write in no-append mode
		if(offset == 0){
		    memset(file_buffer, 0,4096);
		    file_size = 0;
		}
		memcpy(file_buffer+offset, buf_to_write, size);
		file_size += size;
	}
	return size;
}

// Just random stubs
static int FUSE_setxattr(const char *a, const char *b, const char *c, size_t d, int e){
	return 0;
}

static int FUSE_truncate(const char *a, off_t b, struct fuse_file_info *fi){
        return 0;
}

static int FUSE_chmod(const char *, mode_t, struct fuse_file_info *fi){
        return 0;
}

static int FUSE_chown(const char *, uid_t, gid_t, struct fuse_file_info *fi){
        return 0;
}

static int FUSE_utimens(const char *, const struct timespec tv[2], struct fuse_file_info *fi){
        return 0;
}


static struct fuse_operations FUSE_ops = {
    .getattr    = FUSE_getattr,
    .readdir    = FUSE_readdir,
    .open       = FUSE_open,
    .read       = FUSE_read,
    .write 	= FUSE_write,
    .setxattr 	= FUSE_setxattr,
    .truncate 	= FUSE_truncate,
    .chmod 	= FUSE_chmod,
    .chown 	= FUSE_chown,
    .utimens 	= FUSE_utimens
};

int main(int argc, char *argv[]) {
    	//Initialization of the filesystem
	return fuse_main(argc, argv, &FUSE_ops, NULL);
}
```

- 编译

```bash
$ gcc -o fuse_user main.c -D_FILE_OFFSET_BITS=64 -lfuse
```

- 挂载，挂载的文件系统的部分属性由我们控制。

```bash
$ mkdir -p /tmp/fuse
$ ./fuse_user /tmp/fuse
```

### 暂停进程

具体来说，就是userfaultfd handler被替换成了FUSE文件操作的read callback函数。当缺页异常发生时，FUSE callback将被调用。

有一点需要明确——UAF read和UAF write对应的都是**FUSE read callback**，这里并不需要write callback。为什么呢？因为FUSE callback发生在文件访问过程，并不是内存页的访问过程。虽然漏洞内核模块对于用户空间内存页的访问是有读有写的，但是从引发缺页异常到FUSE callback处理，对于文件来说，它都是首先被读到内存页中。读和写只是针对内存页而言的。

fuse 打开文件，使用mmap映射，让fuse访问 mmap 地址，就会导致进程暂停。

## 参考文章
- [how to use fuse](https://www.maastaar.net/fuse/linux/filesystem/c/2016/05/21/writing-a-simple-filesystem-using-fuse/)
- [fuse hack 101](https://exploiter.dev/blog/2022/FUSE-exploit.html)