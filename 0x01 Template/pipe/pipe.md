# linux kernel pipe

`struct pipe_buffer` 的size为0x28，且使用kcalloc分配，而count为0x10，因此会分配0x280的堆块。使用的flag为 GFP_KERNEL_ACCOUNT,不是SLAB_ACCOUNT 说明可以合并。

- /fs/pipe.c
- /include/fs/

## 创建 pipe 

- 用户态调用

```cpp
int pipe(int pipefd[2]);
```

- pipe.c

```cpp
SYSCALL_DEFINE2(pipe2, int __user *, fildes, int, flags)
{
	return do_pipe2(fildes, flags);
}

SYSCALL_DEFINE1(pipe, int __user *, fildes)
{
	return do_pipe2(fildes, 0);
}
```


### pipe_inode_info

alloc pipe_inode
- kzalloc 一个 pipe_inode_info 结构体，作为pipe
- kcalloc pipe->bufs 数组，明确点是一个queue。

```cpp
struct pipe_inode_info *alloc_pipe_info(void)
{
	struct pipe_inode_info *pipe;
	unsigned long pipe_bufs = PIPE_DEF_BUFFERS;
	struct user_struct *user = get_current_user();
	unsigned long user_bufs;
	unsigned int max_size = READ_ONCE(pipe_max_size);

	pipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL_ACCOUNT);
	if (pipe == NULL)
		goto out_free_uid;

	if (pipe_bufs * PAGE_SIZE > max_size && !capable(CAP_SYS_RESOURCE))
		pipe_bufs = max_size >> PAGE_SHIFT;

	user_bufs = account_pipe_buffers(user, 0, pipe_bufs);

	if (too_many_pipe_buffers_soft(user_bufs) && pipe_is_unprivileged_user()) {
		user_bufs = account_pipe_buffers(user, pipe_bufs, PIPE_MIN_DEF_BUFFERS);
		pipe_bufs = PIPE_MIN_DEF_BUFFERS;
	}

	if (too_many_pipe_buffers_hard(user_bufs) && pipe_is_unprivileged_user())
		goto out_revert_acct;

	pipe->bufs = kcalloc(pipe_bufs, sizeof(struct pipe_buffer),
			     GFP_KERNEL_ACCOUNT);

	if (pipe->bufs) {
		init_waitqueue_head(&pipe->rd_wait);
		init_waitqueue_head(&pipe->wr_wait);
		pipe->r_counter = pipe->w_counter = 1;
		pipe->max_usage = pipe_bufs;
		pipe->ring_size = pipe_bufs;
		pipe->nr_accounted = pipe_bufs;
		pipe->user = user;
		mutex_init(&pipe->mutex);
		return pipe;
	}

out_revert_acct:
	(void) account_pipe_buffers(user, pipe_bufs, 0);
	kfree(pipe);
out_free_uid:
	free_uid(user);
	return NULL;
}
```

### pipe_bufs 大小修改

bufs 数组获得: 40(size of struct pipe_buffer) * 10(pipe_bufs) = 0x280 使用 kmalloc-1024.

```cpp
...
unsigned long pipe_bufs = PIPE_DEF_BUFFERS;

...
pipe->bufs = kcalloc(pipe_bufs, sizeof(struct pipe_buffer),
			     GFP_KERNEL_ACCOUNT);
...
```

>pipe 系统调用非常贴心地为我们提供了 F_SETPIPE_SZ 让我们可以重新分配 pipe_buffer 并指定其数量，从而可以让 bufs 在不同的 kmem_cache 中

1. fcntl

```cpp
long pipe_fcntl(struct file *file, unsigned int cmd, unsigned long arg)
{
	struct pipe_inode_info *pipe;
	long ret;

	pipe = get_pipe_info(file, false);
	if (!pipe)
		return -EBADF;

	__pipe_lock(pipe);

	switch (cmd) {
	case F_SETPIPE_SZ:
		ret = pipe_set_size(pipe, arg);
		break;
	case F_GETPIPE_SZ:
		ret = pipe->max_usage * PAGE_SIZE;
		break;
	default:
		ret = -EINVAL;
		break;
	}

	__pipe_unlock(pipe);
	return ret;
}
```

2. case pipe_set_size
- round_pipe_size: 最终会返回我们输入的数字
- nr_slots 右移12位  `#define PAGE_SHIFT	12` $2^{12} ==  0x1000$

```cpp
static long pipe_set_size(struct pipe_inode_info *pipe, unsigned long arg)
{
	unsigned long user_bufs;
	unsigned int nr_slots, size;
	long ret = 0;

#ifdef CONFIG_WATCH_QUEUE
	if (pipe->watch_queue)
		return -EBUSY;
#endif

	size = round_pipe_size(arg);   
	nr_slots = size >> PAGE_SHIFT;   

	if (!nr_slots)
		return -EINVAL;

	/*
	 * If trying to increase the pipe capacity, check that an
	 * unprivileged user is not trying to exceed various limits
	 * (soft limit check here, hard limit check just below).
	 * Decreasing the pipe capacity is always permitted, even
	 * if the user is currently over a limit.
	 */
	if (nr_slots > pipe->max_usage &&
			size > pipe_max_size && !capable(CAP_SYS_RESOURCE))
		return -EPERM;

	user_bufs = account_pipe_buffers(pipe->user, pipe->nr_accounted, nr_slots);

	if (nr_slots > pipe->max_usage &&
			(too_many_pipe_buffers_hard(user_bufs) ||
			 too_many_pipe_buffers_soft(user_bufs)) &&
			pipe_is_unprivileged_user()) {
		ret = -EPERM;
		goto out_revert_acct;
	}

	ret = pipe_resize_ring(pipe, nr_slots);
	if (ret < 0)
		goto out_revert_acct;

	pipe->max_usage = nr_slots;
	pipe->nr_accounted = nr_slots;
	return pipe->max_usage * PAGE_SIZE;

out_revert_acct:
	(void) account_pipe_buffers(pipe->user, nr_slots, pipe->nr_accounted);
	return ret;
}
```

3. pipe_resize_ring
- calloc nr_slots 由我们输入决定
- 如果数量小于之前的 bufs 用过的数量，错误 ret。
- 如果大于，就会将之前pipe->bufs的内容复制一下，free掉之前的pipe->bufs
- 最后做一些变量修改

```cpp
int pipe_resize_ring(struct pipe_inode_info *pipe, unsigned int nr_slots)
{
	struct pipe_buffer *bufs;
	unsigned int head, tail, mask, n;

	bufs = kcalloc(nr_slots, sizeof(*bufs),
		       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);
	if (unlikely(!bufs))
		return -ENOMEM;

	spin_lock_irq(&pipe->rd_wait.lock);
	mask = pipe->ring_size - 1;
	head = pipe->head;
	tail = pipe->tail;

	n = pipe_occupancy(head, tail);
	if (nr_slots < n) {
		spin_unlock_irq(&pipe->rd_wait.lock);
		kfree(bufs);
		return -EBUSY;
	}

	/*
	 * The pipe array wraps around, so just start the new one at zero
	 * and adjust the indices.
	 */
	if (n > 0) {
		unsigned int h = head & mask;
		unsigned int t = tail & mask;
		if (h > t) {
			memcpy(bufs, pipe->bufs + t,
			       n * sizeof(struct pipe_buffer));
		} else {
			unsigned int tsize = pipe->ring_size - t;
			if (h > 0)
				memcpy(bufs + tsize, pipe->bufs,
				       h * sizeof(struct pipe_buffer));
			memcpy(bufs, pipe->bufs + t,
			       tsize * sizeof(struct pipe_buffer));
		}
	}

	head = n;
	tail = 0;

	kfree(pipe->bufs);
	pipe->bufs = bufs;
	pipe->ring_size = nr_slots;
	if (pipe->max_usage > nr_slots)
		pipe->max_usage = nr_slots;
	pipe->tail = tail;
	pipe->head = head;

	spin_unlock_irq(&pipe->rd_wait.lock);

	/* This might have made more room for writers */
	wake_up_interruptible(&pipe->wr_wait);
	return 0;
}
```

也就是通过设置 `pipe_bufs` 的数量来修改大小。
由上面可知：`fcntl(pipe_fd[i][1], F_SETPIPE_SZ, 0x1000 * 64)` 就是将 pipe_bufs 数组改成64, 相当于kmalloc 0x40个 `struct pipe_buffer`, 0x40 * 18 = 1792 使用 kmalloc-2k

```bash
$ sudo cat /proc/slabinfo
...
kmalloc-cg-2k        672    672   2048   16    8 : tunables    0    0    0 : slabdata     42     42      0
kmalloc-cg-1k        455    608   1024   32    8 : tunables    0    0    0 : slabdata     19     19      0
kmalloc-cg-512       576    576    512   32    4 : tunables    0    0    0 : slabdata     18     18      0
...
```

### 读写 pipe

pipe_write 源码，不是很长，结合注释，很容易看明白。主要看创建页，然后写的过程。
- alloc_page 创建一个page，然后赋值给pipe->tmp_page
- 寻找head指针，赋值给bufs的header,header+1

```cpp

static ssize_t pipe_write(struct kiocb *iocb, struct iov_iter *from) {
  struct file *filp = iocb->ki_filp;
  struct pipe_inode_info *pipe = filp->private_data;
  unsigned int head;
  ssize_t ret = 0;
  size_t total_len = iov_iter_count(from);
  ssize_t chars;
  bool was_empty = false;
  bool wake_next_writer = false;

  /* Null write succeeds. */
  if (unlikely(total_len == 0)) return 0;

  __pipe_lock(pipe);

  if (!pipe->readers) {
    send_sig(SIGPIPE, current, 0);
    ret = -EPIPE;
    goto out;
  }

#ifdef CONFIG_WATCH_QUEUE
  if (pipe->watch_queue) {
    ret = -EXDEV;
    goto out;
  }
#endif

  /*
   * If it wasn't empty we try to merge new data into
   * the last buffer.
   *
   * That naturally merges small writes, but it also
   * page-aligns the rest of the writes for large writes
   * spanning multiple pages.
   */
  head = pipe->head;
  was_empty = pipe_empty(head, pipe->tail);
  chars = total_len & (PAGE_SIZE - 1);
  if (chars && !was_empty) {
    unsigned int mask = pipe->ring_size - 1;
    struct pipe_buffer *buf = &pipe->bufs[(head - 1) & mask];
    int offset = buf->offset + buf->len;

    if ((buf->flags & PIPE_BUF_FLAG_CAN_MERGE) && offset + chars <= PAGE_SIZE) {
      ret = pipe_buf_confirm(pipe, buf);
      if (ret) goto out;

      ret = copy_page_from_iter(buf->page, offset, chars, from);
      if (unlikely(ret < chars)) {
        ret = -EFAULT;
        goto out;
      }

      buf->len += ret;
      if (!iov_iter_count(from)) goto out;
    }
  }

  for (;;) {
    if (!pipe->readers) {
      send_sig(SIGPIPE, current, 0);
      if (!ret) ret = -EPIPE;
      break;
    }

    head = pipe->head;
    if (!pipe_full(head, pipe->tail, pipe->max_usage)) {
      unsigned int mask = pipe->ring_size - 1;
      struct pipe_buffer *buf;
      struct page *page = pipe->tmp_page;
      int copied;

      if (!page) {
        page = alloc_page(GFP_HIGHUSER | __GFP_ACCOUNT);
        if (unlikely(!page)) {
          ret = ret ?: -ENOMEM;
          break;
        }
        pipe->tmp_page = page;
      }

      /* Allocate a slot in the ring in advance and attach an
       * empty buffer.  If we fault or otherwise fail to use
       * it, either the reader will consume it or it'll still
       * be there for the next write.
       */
      spin_lock_irq(&pipe->rd_wait.lock);

      head = pipe->head;
      if (pipe_full(head, pipe->tail, pipe->max_usage)) {
        spin_unlock_irq(&pipe->rd_wait.lock);
        continue;
      }

      pipe->head = head + 1;
      spin_unlock_irq(&pipe->rd_wait.lock);

      /* Insert it into the buffer array */
      buf = &pipe->bufs[head & mask];
      buf->page = page;
      buf->ops = &anon_pipe_buf_ops;
      buf->offset = 0;
      buf->len = 0;
      if (is_packetized(filp))
        buf->flags = PIPE_BUF_FLAG_PACKET;
      else
        buf->flags = PIPE_BUF_FLAG_CAN_MERGE;
      pipe->tmp_page = NULL;

      copied = copy_page_from_iter(page, 0, PAGE_SIZE, from);
      if (unlikely(copied < PAGE_SIZE && iov_iter_count(from))) {
        if (!ret) ret = -EFAULT;
        break;
      }
      ret += copied;
      buf->len = copied;

      if (!iov_iter_count(from)) break;
    }

    if (!pipe_full(head, pipe->tail, pipe->max_usage)) continue;

    /* Wait for buffer space to become available. */
    if ((filp->f_flags & O_NONBLOCK) || (iocb->ki_flags & IOCB_NOWAIT)) {
      if (!ret) ret = -EAGAIN;
      break;
    }
    if (signal_pending(current)) {
      if (!ret) ret = -ERESTARTSYS;
      break;
    }

    /*
     * We're going to release the pipe lock and wait for more
     * space. We wake up any readers if necessary, and then
     * after waiting we need to re-check whether the pipe
     * become empty while we dropped the lock.
     */
    __pipe_unlock(pipe);
    if (was_empty)
      wake_up_interruptible_sync_poll(&pipe->rd_wait, EPOLLIN | EPOLLRDNORM);
    kill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);
    wait_event_interruptible_exclusive(pipe->wr_wait, pipe_writable(pipe));
    __pipe_lock(pipe);
    was_empty = pipe_empty(pipe->head, pipe->tail);
    wake_next_writer = true;
  }
out:
  if (pipe_full(pipe->head, pipe->tail, pipe->max_usage))
    wake_next_writer = false;
  __pipe_unlock(pipe);

  /*
   * If we do do a wakeup event, we do a 'sync' wakeup, because we
   * want the reader to start processing things asap, rather than
   * leave the data pending.
   *
   * This is particularly important for small writes, because of
   * how (for example) the GNU make jobserver uses small writes to
   * wake up pending jobs
   *
   * Epoll nonsensically wants a wakeup whether the pipe
   * was already empty or not.
   */
  if (was_empty || pipe->poll_usage)
    wake_up_interruptible_sync_poll(&pipe->rd_wait, EPOLLIN | EPOLLRDNORM);
  kill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);
  if (wake_next_writer)
    wake_up_interruptible_sync_poll(&pipe->wr_wait, EPOLLOUT | EPOLLWRNORM);
  if (ret > 0 && sb_start_write_trylock(file_inode(filp)->i_sb)) {
    int err = file_update_time(filp);
    if (err) ret = err;
    sb_end_write(file_inode(filp)->i_sb);
  }
  return ret;
}
```

page结构体也是一个比较复杂的结构体，可以看[这里](https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/heap/heap_overview/#page)
- pipe->bufs 中 pipe_buffer 存在指向 page 的指针，我们在写pipe时会写入这个page中指向的内存，调用 `copy_page_from_iter` 
- 

## Pipe Primitive

灵感来源于 dirty pipe,修改flag使其和dirty pipe 漏洞成因一致，从而摆脱对地址的依赖

## references

- [pipe-buffer arb read/write](https://www.interruptlabs.co.uk/articles/pipe-buffer)
- [ctf-wiki page](https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/heap/heap_overview/#page)