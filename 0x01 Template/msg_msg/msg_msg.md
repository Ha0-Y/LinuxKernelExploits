## msg_msg

### 消息队列

msg_queue 结构体

```c
struct msg_queue {
	struct kern_ipc_perm q_perm;
	time64_t q_stime;		/* last msgsnd time */
	time64_t q_rtime;		/* last msgrcv time */
	time64_t q_ctime;		/* last change time */
	unsigned long q_cbytes;		/* current number of bytes on queue */
	unsigned long q_qnum;		/* number of messages in queue */
	unsigned long q_qbytes;		/* max number of bytes on queue */
	struct pid *q_lspid;		/* pid of last msgsnd */
	struct pid *q_lrpid;		/* last receive pid */

	struct list_head q_messages;
	struct list_head q_receivers;
	struct list_head q_senders;
} __randomize_layout;
```

当往一个消息队列发送消息时，会形成如下的结构

![msg_queue](./imgs/msg_queue.png)

#### 消息

msg_msg 结构体

```c
struct msg_msg {
	struct list_head m_list;
	long m_type;
	size_t m_ts;		/* message text size */
	struct msg_msgseg *next;
	void *security;
};
```

当**一条消息**长度超过一页时，会使用 msg_msgseg 指向剩余的消息

```c
struct msg_msgseg {
	struct msg_msgseg *next;
};
```

![msg_msg](./imgs/msg_msg.png)


#### 接口

在用户态可以使用这些函数操作 msg_msg

```c
// 创建和获取ipc内核对象，返回值就是 msqid
int msgget(key_t key, int flags);
 
// 将消息发送到消息队列
int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
 
// 从消息队列获取消息
ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);
 
// 查看、设置、删除ipc内核对象(用法和shmctl一样)
int msgctl(int msqid, int cmd, struct msqid_ds *buf);
```

