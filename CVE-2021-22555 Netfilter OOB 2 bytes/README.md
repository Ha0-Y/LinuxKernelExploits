## 编译选项

影响版本：Linux v2.6.19-rc1~v5.12-rc7 v5.12-rc8已修补，漏洞存在了15年，评分7.8。 已修复的版本有 5.12，5.10.31, 5.4.113, 4.19.188, 4.14.231, 4.9.267, 4.4.267。 由syzkaller发现

- 主要靠阅读[此篇文章](https://bsauce.github.io/2021/09/23/CVE-2021-22555/)学习，在作者的github提供了[作者的config](https://github.com/bsauce/kernel-exploit-factory/blob/main/CVE-2021-22555/config)文件，直接抄一份。修改编译器版本

- 或者menuconfig在网络选项中将netfilter相关选项全部勾选。
```config
CONFIG_IP_NF_** 全为y
CONFIG_NETFILTER_** 全部为 `y`
CONFIG_E1000和CONFIG_E1000E，变更为=y

CONFIG_USER_NS=y
CONFIG_NET_NS=y
CONFIG_COMPAT=y
```

- `pahole` 工具版本问题，不能过高和过低。🤣 ubuntu18/20比较适合。

## 大致原理

- 详情（包括参考文章）请见[pdf](./study.pdf)

`net/netfilter/x_tables.c` 中 Netfilter 模块的ip_tables子模块， 当调用setsockopt()和选项IPT_SO_SET_REPLACE（或 IP6T_SO_SET_REPLACE）时，在32位转化为64位时计算错误，导致在调用 xt_compat_match_from_user() 函数时 **堆溢出写 0**。
再利用时可能会造成些许的数据偏差，到最后利用就时**两字节堆溢出写0**。

## exploit

内核开启 kaslr,smap,smep,kpti。

### heap overflow to uaf

1. 创建0x1000个主从消息，主消息0x1000, 从消息0x400。先填充主消息，后填充从消息
2. 释放1024，2048，3096的主消息
3. 触发堆溢出，将释放的某个消息的 `msg_msg->m_list->next` 末尾两字节修改为0，指向其余消息，造成两个消息指向同一个堆
4. 定位占位的消息
5. 主消息1释放从消息，然后使用skb占位，从而可以使用主消息2修改其中的内容。但是在释放消息时需要**确保从消息的指针不会出错才行（free_msg的操作）**

### msg_msg 修复

1. 避免msg_msg 崩溃(msgrcv会free掉，进行双链表的unlink，进行指针的检查)，需要leak出msg_msg的prev和next指针。但是检查不严格，在正常情况下，只需要保证next、prev指针所指向内存地址可写即可
2. 泄露辅助消息地址
3. 泄露主消息地址


### bypass kaslr

- 使用 pipe_buffer->ops 中的结构体 leak 

### ROP

- close pipe 时会调用 `pipe_buffer->ops->release`
- bypass smep, smap, kpti，直接向内核堆(secondary_msg 0x400 足够的)中使用sk_buff写入rop链


- 别人调试时，函数调用，rsi指向pipe_buffer地址
1. mov rsp，rsi将栈转移到我们的rop（pipe_buffer 下面）中。
2. add rsp, xxx
3. push rsi; pop rsp


## 复现

花了很长时间，最后没有成功😭😭😭，遂放弃

## summary

此漏洞的利用确实打开内核heap overflow 和 use after free的思路，可以heap overflow 转化为 uaf，进而利用
