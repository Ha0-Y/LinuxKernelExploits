## 原理

### kpti

- KPTI(Kernel PageTable Isolation)全称内核页表隔离。在 [KPTI 机制](https://ctf-wiki.org/pwn/linux/kernel-mode/defense/isolation/user-kernel/kpti/)中，内核态空间的内存和用户态空间的内存的隔离进一步得到了增强。
    - 内核态中的页表包括用户空间内存的页表和内核空间内存的页表。
    - 用户态的页表只包括用户空间内存的页表以及必要的内核空间内存的页表，如用于处理系统调用、中断等信息的内存。

在没有 kpti 之前，内核空间和用户空间都是存在同一个页表中，这样做的好处有很多，比如效率高，从用户态切换到内核态的时候不需要切换页表，但也带来了很多问题，比较严重的问题就是内核和用户态的隔离变弱了，导致在用户态就能通过侧信道等一系列手段获得内核态的一些信息，进而对内核进行攻击。

### prefetch

硬件预取：在一定的策略被触发时，CPU 将进行硬件预取，将数据按照不同的策略加载到不同层级的 Cache 当中。

软件预取：通过程序员手动或编译器自动在代码中插入预取指令，从而向 CPU 发送预取提示，让 CPU 进行数据预取，从而提高程序的性能。x64 架构 CPU 使用 PREFETCHh 类指令（PREFETCHT0～T2、PREFETCHNTA）作为预取指令，它包含在 SSE 指令集当中，几乎所有 Intel CPU 都支持 SSE 指令集。PREFETCHh 类指令建议 CPU 加载数据到 Cache 当中，且该类指令不需要特权，执行失败也不会导致异常。

x86_64 有一组预取指令 `prefetch` ，这些指令可以将指定地址预取到`cpu cache`(L1,L2,L3 cache)中，当然这个地址也会被刷新到 快表tlb(translation lookaside buffer) 中，如果将要预取的地址已经存在在 tlb 中了（就是之前使用过这个地址），那么预取将会快速完成，但是当地址不存在的时候，预取指令将会完成的比较慢（这很好理解，因为之前没有访问过）所以地址对应的 pte(page table entry) 不在 tlb 中，所以还得遍历页表找到物理地址然后把对应地址数据拷贝到cpu cache,中，比之前者多了两步操作

### side-channel attack

在计算机安全中，侧信道攻击是基于计算机协议或算法的基本实现方式而可以收集的额外信息的攻击，而不是基于漏洞或算法本身。时间信息、功耗、电磁泄漏和声音等都可以作为额外信息，用于旁道攻击的进行：

缓存攻击：基于攻击者监视受害者在虚拟化环境或云服务类型的共享物理系统中进行缓存访问的能力的攻击。
计时攻击：基于测量各种计算（例如将攻击者的给定密码与受害者的未知密码进行比较）执行的时间的攻击。
数据残留：敏感数据在被删除后被读取。

测信道攻击的例子
1. Attacker先通过Flush清空对应的cache line
2. 触发Victim访问该数据
3. Attacker会访问同一数据并测量访问时间

### Meltdown & Spectre CPU 漏洞

>Meltdown对应CVE-2017-5754（乱序执行缓存污染），Spectre对应CVE-2017-5753（边界检查绕过）与CVE-2017-5715（分支目标注入）。
> 在漏洞纰漏出来时，Meltdown漏洞影响几乎所有的Intel CPU和部分ARM CPU，而Spectre则影响所有的Intel CPU和AMD CPU，以及主流的ARM CPU。AMD不受Meltdown的影响。

Meltdown攻击是一种直接针对底层硬件机制（CPU的乱序执行机制、Cache机制和异常处理机制）的时间侧信道攻击。

#### 乱序执行

乱序执行（out-of-order execution）是指 CPU 采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理的技术。该技术提高了 CPU 的运行程序的速度。

Meltdown攻击的本质是利用CPU进行的安全检查和乱序执行之间的race condition，给攻击者创造一个很短的攻击窗口。乱序执行是指当CPU中的某些指令需要等待某些资源，比如内存读取时，CPU不会在当前指令停止，而是利用空闲的计算能力继续执行后续的指令。这大大地增加了计算能力的利用率，从而提升了CPU性能。在支持乱序执行的CPU上，指令的执行并不是顺序进行的。比如后面的指令可能在前面指令执行结束之前就开始执行。然而，为了保证程序的正确性，指令退休（retirement）必须是顺序进行的，而CPU的安全检查是在指令退休时才会进行。这样的结果是，在CPU对某一条指令进行安全检查之前，一部分在该指令后面的指令会由于CPU的乱序执行而被提前执行。例如，一条用户空间的指令访问内核内存会导致CPU抛出异常，然而该异常只有在这条指令退休的时候才会被CPU处理，而由于乱序执行而被提前执行的指令会被CPU丢弃。由于CPU保证程序的正确性，乱序执行本不会产生安全隐患。然而，由于乱序执行的指令对缓存的操作在这些指令被丢弃时不会被重置，攻击者就可以通过缓存侧信道的方式来获取这些乱序执行的信息，从而导致了Meltdown攻击。本质上，Spectre攻击的原理也是一样的

#### 预测执行

CPU基于先有经验预先执行了后续可能执行的代码，比如说一个循环中的代码循环了很多次就有了‘经验’。

Spectre攻击利用了CPU的预测执行对系统进行攻击。预测执行是另外一种CPU优化特性。在分支指令执行时，由于分支指令执行可能需要内存读取（上百个CPU周期），在分支指令执行结束之前，CPU会预测哪一个分支会被运行，提取相应的指令代码并执行，以提高CPU指令流水线的性能。CPU的预测执行是通过分支预测单元(BPU)进行的。简单的理解，BPU储存了某个分支指令最近执行过的分支跳转的结果。CPU的预测执行遇到分支指令时，会根据BPU的预测结果进行跳转。当预测执行发现预测错误时，预测执行的结果将会被丢弃，CPU的状态会被重置。然而，与乱序执行类似，预测执行对CPU缓存的影响会被保留。Spectre和Meltdown攻击在这一点上比较类似。

### exploit

在开启 KPTI 时：用户态的页表只包括用户空间内存的页表以及必要的内核空间内存的页表，如用于处理系统调用、中断等信息的内存。但这些仍包括在用户态页表中的内核空间内存的页表却没有进行随机化，而是直接使用其在内核中的实际地址映射到了用户空间。

这一行为导致攻击者可以通过侧信道攻击来泄漏相关内核函数的实际地址。当程序执行系统调用时，会将仍映射在用户空间的 entry_SYSCALL_64 内核函数加载到 CPU cache 当中。在这个时候，通过 prefetch 指令去预取相关空间地址以试图命中该条 cache，如果命中的话，因为相关数据已经预取到 CPU 的 cache 当中了，因此耗时应该是最小的。我们通过时间的计算来获得地址

## 复现

- Intel 的 CPU，我们攻击的点是cache缓存。
- 内核要开启kaslr 和 KPTI，一般都开启了，如果是qemu启动自行添加。

本机是AMD CPU，作者文章中也说明 AMD 的 CPU 无法成功👀。
```txt
I’ve managed to have this work on multiple Intel CPUs (including i5-8265U, i7-8750H,  i7-9700F, i7-9750H, Xeon(R) CPU E5-2640) - I got it working on some VPS instances too but was unable to figure out the Intel CPU model there. It seems to work across a wide range of kernel versions with KPTI - I’ve tested it on Arch 6.0.12-hardened1-1-hardened, Ubuntu 5.15.0-56-generic, 6.0.12-1-MANJARO, 5.10.0-19-amd64, and a custom 5.18.3 build. It also works in KVM guests to leak the guest OS KASLR base (one would need to forward the host CPU features with "-cpu host" in QEMU for prefetch to even work though). I'm not sure how the TLB side-effects are preserved in a VM scenario though across CR3 writes and potential VM exits - if anyone has ideas, please let me know! As of now, I don’t think this attack affects AMD, but I also don't have direct access to any AMD hardware (see edit in the end). Lastly, I don't believe the repeated syscalls are necessary in my exploit as later tests show that it worked without making them with each measurement most likely due to the global bit, but I still kept it in my exploit just to guarantee its existence in the TLB.
```

- 使用intel cpu云主机。
    - 不管跑几遍脚本，KASLR base 是固定的地址。
    - 重启后，相同机器得到的偏移相同。

- 样本比较少
    - 可能会根据芯片的不同产生变化。
    - 可能因操作系统而产生变化
    - qemu启动产生的结果会不会不同

- 重启多尝试，可以看出有一定的缓解，但是不多，因为偏移是固定的（重启也是），在具体的漏洞利用可以尝试一下爆破获得基址。

1. ubuntu20 
```bash
### poc 1
KASLR base 0xffffffffa0600000
root@vultr:~# grep startup_64 /proc/kallsyms
ffffffff9fe00000 T startup_64
>>> hex(0xffffffffa0600000-0xffffffff9fe00000)
'0x800000'

### poc 2
KASLR base 0xffffffff97400000
root@vultr:/home/ubuntu# grep startup_64 /proc/kallsyms
ffffffff96c00000 T startup_64
>>> hex(0xffffffff97400000-0xffffffff96c00000)
'0x800000'
```

2. ubuntu22 
```bash
### poc 1
KASLR base 0xffffffff98800000
root@vultr:/home/ubuntu# grep startup_64 /proc/kallsyms
ffffffff97e00000 T startup_64
>>> hex(0xffffffff98800000-0xffffffff97e00000)
'0xa00000'

### poc 2
KASLR base 0xffffffff8d200000
root@vultr:/home/ubuntu# grep startup_64 /proc/kallsyms
ffffffff8c800000 T startup_64
>>> hex(0xffffffff8d200000-0xffffffff8c800000)
'0xa00000'
```

3. ubuntu23 
```bash
### poc 1
KASLR base 0xffffffff9e600000
root@vultr:/home/ubuntu# grep startup_64 /proc/kallsyms
ffffffff9d800000 T startup_64
>>> hex(0xffffffff9e600000-0xffffffff9d800000)
'0xe00000'

### poc 2
KASLR base 0xffffffff90400000
root@vultr:/home/ubuntu# grep startup_64 /proc/kallsyms
ffffffff8f600000 T startup_64
>>> hex(0xffffffff90400000-0xffffffff8f600000)
'0xe00000'
```

## 修复

作者披露于 `12/18/2022`。根据上面的结果，现在可以使用，误差比较小。

但是阅读一下这个[exploit.c](https://github.com/bcoles/kasld/blob/master/src/entrybleed.c)，在 kernel 6.2 patch。并且此脚本解决了我们上面偏移获取的问题。


## 参考文章

[Will's Root entrybleed](https://www.willsroot.io/2022/12/entrybleed.html)
[CVE-2022-4543分析&复现](https://sunichi.github.io/2022/12/25/CVE-2022-4543/)
[CVE-2022-4543及kpti机制](https://cainiao159357.github.io/2023/02/08/CVE-2022-4543%E5%8F%8Akpti%E6%9C%BA%E5%88%B6/)
[meltdoen & spectre](https://meltdownattack.com/)
[meltdown & spectre分析](https://zhuanlan.zhihu.com/p/263081764)