# CVE-2022-2588 

> double free 配合 cross cache attack && dirty cred

## 介绍

影响版本：Linux v3.17 (commit) ~v5.19.1。 v5.19.2已修补。

内核编译选项

```conf
CONFIG_BINFMT_MISC=y                      # 否则启动VM时报错
CONFIG_USER_NS=y                          # 触发漏洞需要 User Namespace
CONFIG_NET_CLS_ROUTE4=y                   # 漏洞函数所在的模块
CONFIG_DUMMY=y 
CONFIG_NET_SCH_QFQ=y                      # 触发poc需要用到
CONFIG_NET_CLS_ACT / CONFIG_NET_CLS_BASIC # 默认已开启
CONFIG_NET_SCH_SFQ=y                      # exp中触发漏洞需用到 sfq随机公平队列
CONFIG_NET_EMATCH_META=y                  # 堆喷对象时需要用到
CONFIG_E1000=y
CONFIG_E1000E=y。
```

### 原理

将 `route4_filter` 对象从链表中删除和释放时的检查条件不一致，导致该对象被释放后仍存于链表中，后面可以触发 Double-Free。需要 User Namespaces 才能触发。采用 DirtCred 方法进行提权。

1. patch

```cpp
diff --git a/net/sched/cls_route.c b/net/sched/cls_route.c
index a35ab8c27866e..3f935cbbaff66 100644
--- a/net/sched/cls_route.c
+++ b/net/sched/cls_route.c
@@ -526,7 +526,7 @@ static int route4_change(struct net *net, struct sk_buff *in_skb,
    rcu_assign_pointer(f->next, f1);
    rcu_assign_pointer(*fp, f);

-   if (fold && fold->handle && f->handle != fold->handle) {
+   if (fold) {
        th = to_hash(fold->handle);
        h = from_hash(fold->handle >> 16);
```

2. 源码

kernel 5.18
- 漏洞触发点位于 route4_change 中，会生成并初始化一个 route4_filter 结构

```cpp
static int route4_change(struct net *net, struct sk_buff *in_skb,
			 struct tcf_proto *tp, unsigned long base, u32 handle,
			 struct nlattr **tca, void **arg, u32 flags,
			 struct netlink_ext_ack *extack)
{

// ......

  // fold
	fold = *arg;
	if (fold && handle && fold->handle != handle)
			return -EINVAL;

	err = -ENOBUFS;
  // 新生成的route4_filter
	f = kzalloc(sizeof(struct route4_filter), GFP_KERNEL);    
	if (!f)
		goto errout;

	err = tcf_exts_init(&f->exts, net, TCA_ROUTE4_ACT, TCA_ROUTE4_POLICE);
	if (err < 0)
		goto errout;

	if (fold) {
		f->id = fold->id;
		f->iif = fold->iif;
		f->res = fold->res;
		f->handle = fold->handle;

		f->tp = fold->tp;
		f->bkt = fold->bkt;
		new = false;
	}

  // 设置新生成的f的参数
	err = route4_set_parms(net, tp, base, f, handle, head, tb,
			       tca[TCA_RATE], new, flags, extack);
	if (err < 0)
		goto errout;

// .......

  // 在这里，检查变量，并且比较handle是否相同。
	if (fold && fold->handle && f->handle != fold->handle) {
		th = to_hash(fold->handle);
		h = from_hash(fold->handle >> 16);
		b = rtnl_dereference(head->table[th]);
		if (b) {
			fp = &b->ht[h];
			for (pfp = rtnl_dereference(*fp); pfp;
			     fp = &pfp->next, pfp = rtnl_dereference(*fp)) {
				if (pfp == fold) {
          // 在这里，将fold从从fp移除
					rcu_assign_pointer(*fp, fold->next);
					break;
				}
			}
		}
	}

  route4_reset_fastmap(head);
	*arg = f;
  // 在这里，调用 route4_delete_filter_work 释放fold
	if (fold) {
		tcf_unbind_filter(tp, &fold->res);
		tcf_exts_get_net(&fold->exts);
    // 启动内核任务，调用 route4_delete_filter_work() 释放 old filter
		tcf_queue_work(&fold->rwork, route4_delete_filter_work);
	}
}

// ......
```

1. 可以看出从链表unlink的条件和删除的条件不同
- 删除只检查了fold，而从链表中unlink检查了handle, 缺少了handle检查。可能导致其free掉之后仍然在fp链表中。(fold->handle 为0，就可以不进入if线。)
- 我们可以插入一个handle为0的结构体，然后尝试删除这个结构体，得到一个fold被free后但是仍然在fp链表中


4. 可以使用其他函数在释放在释放fold一次 
- 查找谁调用了 `route4_delete_filter_work`
- route4_delete函数

```cpp
static int route4_delete(struct tcf_proto *tp, void *arg, bool *last,
			 bool rtnl_held, struct netlink_ext_ack *extack)
{
	struct route4_head *head = rtnl_dereference(tp->root);
	struct route4_filter *f = arg;
	struct route4_filter __rcu **fp;
	struct route4_filter *nf;
	struct route4_bucket *b;
	unsigned int h = 0;
	int i, h1;

	if (!head || !f)
		return -EINVAL;

	h = f->handle;
	b = f->bkt;

	fp = &b->ht[from_hash(h >> 16)];
	for (nf = rtnl_dereference(*fp); nf;
	     fp = &nf->next, nf = rtnl_dereference(*fp)) {
		if (nf == f) {
			/* unlink it */
			RCU_INIT_POINTER(*fp, rtnl_dereference(f->next));

			/* Remove any fastmap lookups that might ref filter
			 * notice we unlink'd the filter so we can't get it
			 * back in the fastmap.
			 */
			route4_reset_fastmap(head);

			/* Delete it */
			tcf_unbind_filter(tp, &f->res);
			tcf_exts_get_net(&f->exts);
			tcf_queue_work(&f->rwork, route4_delete_filter_work);

			/* Strip RTNL protected tree */
			for (i = 0; i <= 32; i++) {
				struct route4_filter *rt;

				rt = rtnl_dereference(b->ht[i]);
				if (rt)
					goto out;
			}

			/* OK, session has no flows */
			RCU_INIT_POINTER(head->table[to_hash(h)], NULL);
			kfree_rcu(b, rcu);
			break;
		}
	}

out:
	*last = true;
	for (h1 = 0; h1 <= 256; h1++) {
		if (rcu_access_pointer(head->table[h1])) {
			*last = false;
			break;
		}
	}

	return 0;
}
```

## Exploit

1. 这里可以 double free 的两个结构
- 一个是 kmalloc-192 的 route4_filter
- 另一个是一个指针数组空间，大小属于 kmalloc-256。（如果编译内核时开启了 CONFIG_NET_CLS_ACT，那么 route4_filter->exts.actions 对象也会 Double-free。）
- 我们可以利用这两种漏洞对象来进行 DirtyCred 攻击，分别替换进程凭证（task credentials，利用 kmalloc-192）和文件凭证（open file credentials，利用 kmalloc-256）。

```cpp
static void __route4_delete_filter(struct route4_filter *f)
{
	tcf_exts_destroy(&f->exts);
	tcf_exts_put_net(&f->exts);
	kfree(f);
}

static void route4_delete_filter_work(struct work_struct *work)
{
	struct route4_filter *f = container_of(to_rcu_work(work),
					       struct route4_filter,
					       rwork);
	rtnl_lock();
	__route4_delete_filter(f);
	rtnl_unlock();
}
```

2. Double-free 触发崩溃的解决：
- 我们用到的漏洞对象是 kmalloc-256 ，但漏洞同时也会把一个 kmalloc-192 释放两次，就会触发内核 Double-free 检测，导致崩溃。解决办法是，在两次释放 kmalloc-192 之间间隔释放同一页的其他 slab，就能避免崩溃。

3. cross-cache:我们将释放某个 kmalloc-256 cache page，将该页归还给buddy system，然后分配 file 结构来复用该页（filp cache）
- 分配一堆 kmalloc-256 堆块，包含漏洞对象
- 利用漏洞第1次释放漏洞对象，并释放一堆 kmalloc-256，以归还漏洞对象所在的页；
- 分配大量低权限 file 对象来占据漏洞对象（cross-cache attack）；
- 利用漏洞第2次释放漏洞对象，堆喷高权限 file 对象来替换低权限 file 对象。
- 这样我们的漏洞对象就会出现在特权对象中，虽然对slab有检查（通用和非通用），但是不会对内存页进行检查

4. 修改文件文件内容，这里是`/etc/passwd` 修改。exp从作者那里拿过来的，有点看不懂 XD。


画个图更容易理解

<img src="./imgs/read.png" style="zoom:40%" />


复现环境，使用syzkaller 指定内核进行。并且没有地址相关的依赖，可以实现通杀。

```bash
cve@syzkaller:~$ ./exp_file_credentials 
self path /home/cve/./exp_file_credentials
prepare done
Old limits -> soft limit= 14096          hard limit= 14096 
starting exploit, num of cores: 2
defrag done
[   61.566280] netlink: 194 bytes leftover after parsing attributes in process `exp_file_creden'.
[   61.566762] netlink: 194 bytes leftover after parsing attributes in process `exp_file_creden'.
[   61.566982] netlink: 194 bytes leftover after parsing attributes in process `exp_file_creden'.
[   61.567203] netlink: 194 bytes leftover after parsing attributes in process `exp_file_creden'.
[   61.570399] netlink: 194 bytes leftover after parsing attributes in process `exp_file_creden'.
[   61.570653] netlink: 194 bytes leftover after parsing attributes in process `exp_file_creden'.
[   61.570869] netlink: 194 bytes leftover after parsing attributes in process `exp_file_creden'.
[   61.572671] netlink: 194 bytes leftover after parsing attributes in process `exp_file_creden'.
[   61.572913] netlink: 194 bytes leftover after parsing attributes in process `exp_file_creden'.
[   61.573078] netlink: 194 bytes leftover after parsing attributes in process `exp_file_creden'.
spray 256 done
freed the filter object
256 freed done
double free done
spraying files
found overlap, id : 0, 1021
start slow write
closed overlap
got cmd, start spraying /etc/passwd
should be after the slow write
write done, spent 12.842886 s
spray done
succeed
cve@syzkaller:~$ su user   # 密码是user
Password: 
[   86.168318] systemd-journald[154]: File /var/log/journal/21c541678a974ec98d7efa58533501cc/user-1000.journal corrupted or uncleanly shut down, renaming and replacing.
user@syzkaller:/home/cve# id
uid=0(user) gid=0(root) groups=0(root)
user@syzkaller:/home/cve# 
```

## 参考

- [Markakd CVE-2022-2588](https://github.com/Markakd/CVE-2022-2588/tree/e8f095689777f1e95bd65c93eb1ad242b2dbc737)
- [CVE-2021-3715 black hat](https://zplin.me/talks/BHEU21_trash_kernel_bug.pdf)